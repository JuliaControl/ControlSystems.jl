<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · ControlSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><script src="../../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li class="is-active"><a class="tocitem" href>Analysis</a></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystems.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystems.are</code></a></li><li><a href="#ControlSystems.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystems.are</code></a></li><li><a href="#ControlSystems.balance"><code>ControlSystems.balance</code></a></li><li><a href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a></li><li><a href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a></li><li><a href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a></li><li><a href="#ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}"><code>ControlSystems.ctrb</code></a></li><li><a href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a></li><li><a href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a></li><li><a href="#ControlSystems.dcgain"><code>ControlSystems.dcgain</code></a></li><li><a href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a></li><li><a href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a></li><li><a href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a></li><li><a href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a></li><li><a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.grampd</code></a></li><li><a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystems.hinfnorm</code></a></li><li><a href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a></li><li><a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a></li><li><a href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.margin</code></a></li><li><a href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a></li><li><a href="#ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystems.observer_controller</code></a></li><li><a href="#ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.observer_predictor</code></a></li><li><a href="#ControlSystems.obsv"><code>ControlSystems.obsv</code></a></li><li><a href="#ControlSystems.poles-Tuple{AbstractStateSpace}"><code>ControlSystems.poles</code></a></li><li><a href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a></li><li><a href="#ControlSystems.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystems.relative_gain_array</code></a></li><li><a href="#ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystems.relative_gain_array</code></a></li><li><a href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a></li><li><a href="#ControlSystems.tzeros-Tuple{TransferFunction}"><code>ControlSystems.tzeros</code></a></li><li><a href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a></li><li><a href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li></ul><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.damp-Tuple{LTISystem}" href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wn, zeta, ps = damp(sys)</code></pre><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dampreport-Tuple{IO, LTISystem}" href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dampreport(sys)</code></pre><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dcgain" href="#ControlSystems.dcgain"><code>ControlSystems.dcgain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dcgain(sys, ϵ=0)</code></pre><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p><p><code>ϵ</code> can be provided to evaluate the dcgain with a small perturbation into the stability region of the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.delaymargin-Tuple{LTISystem}" href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dₘ = delaymargin(G::LTISystem)</code></pre><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L530-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}" href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T = gangoffour(P, C; minimal=true)
gangoffour(P::AbstractVector, C::AbstractVector; minimal=true)</code></pre><p>Given a transfer function describing the plant <code>P</code> and a transfer function describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = P/(1+PC)</code> Load disturbance to measurement signal</li><li><code>CS = C/(1+PC)</code> Measurement noise to control signal</li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li></ul><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L558-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}" href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T, RY, RU, RE = gangofseven(P,C,F)</code></pre><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = P/(1+PC)</code></li><li><code>CS = C/(1+PC)</code></li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li><li><code>RY = PCF/(1+PC)</code></li><li><code>RU = CF/(1+P*C)</code></li><li><code>RE = F/(1+P*C)</code></li></ul><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L583-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ωgₘ, gₘ, ωϕₘ, ϕₘ = margin(sys::LTISystem, w::Vector; full=false, allMargins=false)</code></pre><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><p>If <code>!allMargins</code>, return only the smallest margin</p><p>If <code>full</code> return also <code>fullPhase</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L404-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}" href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">markovparam(sys, n)</code></pre><p>Compute the <code>n</code>th markov parameter of state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L106-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.poles-Tuple{AbstractStateSpace}" href="#ControlSystems.poles-Tuple{AbstractStateSpace}"><code>ControlSystems.poles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">poles(sys)</code></pre><p>Compute the poles of system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}" href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L258-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.relative_gain_array-Tuple{AbstractMatrix}" href="#ControlSystems.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystems.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(A::AbstractMatrix; tol = 1.0e-15)</code></pre><p>Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L360-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}" href="#ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystems.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(G, w::AbstractVector)
relative_gain_array(G, w::Number)</code></pre><p>Calculate the relative gain array of <code>G</code> at frequencies <code>w</code>.  G(iω) .* pinv(tranpose(G(iω)))</p><p>The RGA can be used to find input-output pairings for MIMO control using individially tuned loops. Pair the inputs and outputs such that the RGA(ωc) at the crossover frequency becomes as close to diagonal as possible. Avoid pairings such that RGA(0) contains negative diagonal elements. </p><ul><li>The sum of the absolute values of the entries in the RGA is a good measure of the &quot;true condition number&quot; of G, the best condition number that can be achieved by input/output scaling of <code>G</code>, -Glad, Ljung.</li><li>The RGA is invariant to input/output scaling of <code>G</code>.</li><li>If the RGA contains large entries, the system may be sensitive to model errors, -Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;:<ul><li>Uncertainty in the input channels (diagonal input uncertainty). Plants with</li></ul>large RGA-elements around the crossover frequency are fundamentally   difficult to control because of sensitivity to input uncertainty (e.g. caused   by uncertain or neglected actuator dynamics). In particular, decouplers or   other inverse-based controllers should not be used for plants with large RGAeleme<ul><li>Element uncertainty. Large RGA-elements imply sensitivity to element-by-element uncertainty.</li></ul>However, this kind of uncertainty may not occur in practice due to physical couplings   between the transfer function elements. Therefore, diagonal input uncertainty   (which is always present) is usually of more concern for plants with large RGAelemen</li></ul><p>The relative gain array is computed using the The unit-consistent (UC) generalized inverse Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L327-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tzeros-Tuple{TransferFunction}" href="#ControlSystems.tzeros-Tuple{TransferFunction}"><code>ControlSystems.tzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tzeros(sys)</code></pre><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpkdata-Tuple{LTISystem}" href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z, p, k = zpkdata(sys)</code></pre><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><p><code>z</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>p</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>k</code> : Matrix{Float64}, (ny x nu)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/analysis.jl#L120-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}" href="#ControlSystems.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystems.are</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are(::Continuous, A, B, Q, R)</code></pre><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>Uses <code>MatrixEquations.arec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}" href="#ControlSystems.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystems.are</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are(::Discrete, A, B, Q, R; kwargs...)</code></pre><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where Q&gt;=0 and R&gt;0</p><p>Uses <code>MatrixEquations.ared</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.ared</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balance" href="#ControlSystems.balance"><code>ControlSystems.balance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S, P, B = balance(A[, perm=true])</code></pre><p>Compute a similarity transform <code>T = S*P</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L451-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sysr, G, T = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>. <code>T</code> is the similarity transform between the old state <code>x</code> and the new state <code>z</code> such that <code>Tz = x</code>.</p><p>See also <code>gram</code>, <code>baltrunc</code></p><p>Reference: Varga A., Balancing-free square-root algorithm for computing singular perturbation approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L488-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysr, G, T = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, n = nothing, residual = false)</code></pre><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>, and truncating it to order <code>n</code>. If <code>n</code> is not provided, it&#39;s chosen such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed.</p><p><code>T</code> is the similarity transform between the old state <code>x</code> and the newstate <code>z</code> such that <code>Tz = x</code>.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L529-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.covar-Tuple{AbstractStateSpace, Any}" href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>P = covar(sys, W)</code></p><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of the output <code>y</code> of a <code>StateSpace</code> model <code>sys</code> driven by white Gaussian noise <code>w</code> with covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> (δ is the Dirac delta).</p><p>Remark: If <code>sys</code> is unstable then the resulting covariance is a matrix of <code>Inf</code>s. Entries corresponding to direct feedthrough (D<em>W</em>D&#39; .!= 0) will equal <code>Inf</code> for continuous-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}" href="#ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}"><code>ControlSystems.ctrb</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ctrb(A, B)</code> or <code>ctrb(sys)</code></p><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram(sys, opt; kwargs...)</code></pre><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p><p>See also <a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a> For keyword arguments, see <a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.grampd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U = grampd(sys, opt; kwargs...)</code></pre><p>Return a Cholesky factor <code>U</code> of the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian <code>G = U*U&#39;</code>. If <code>opt</code> is <code>:o</code>, computes the observability grammian <code>G = U&#39;U</code>.</p><p>Obtain a <code>Cholesky</code> object by <code>Cholesky(U)</code> for observability grammian</p><p>Uses <code>MatrixEquations.plyapc/plyapd</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.plyapc/plyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L51-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}" href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystems.hinfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = hinfnorm(sys; tol=1e-6)</code></pre><p>Compute the H∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain Ninf is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code>  if <code>G</code> is stable (σ_max = largest singular value)       :=        <code>Inf&#39;           if</code>G` is unstable</p><p><code>tol</code> is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>linfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L216-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, R1, R2)
sysi = innovation_form(sys; sysw=I, syse=I, R1=I, R2=I)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w ~ R1
y  = Cx + e ~ R2</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>If <code>sysw</code> (<code>syse</code>) is given, the covariance resulting in filtering noise with <code>R1</code> (<code>R2</code>) through <code>sysw</code> (<code>syse</code>) is used as covariance.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L611-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.linfnorm-Tuple{AbstractStateSpace}" href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = linfnorm(sys; tol=1e-6)</code></pre><p>Compute the L∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain <code>Ninf</code> is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code> (σ_max denotes the largest singular value)</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L244-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}" href="#ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystems.observer_controller</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cont = observer_controller(sys, L::AbstractMatrix, K::AbstractMatrix)</code></pre><p>Return the observer_controller <code>cont</code> that is given by <code>ss(A - B*L - K*C + K*D*L, K, L, 0)</code></p><p>Such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-KC</code> and <code>A-BL</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: Model of system</li><li><code>L</code>: State-feedback gain <code>u = -Lx</code></li><li><code>K</code>: Observer gain</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L664-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.observer_predictor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observer_predictor(sys::AbstractStateSpace, R1, R2)
observer_predictor(sys::AbstractStateSpace, K)</code></pre><p>Return the observer_predictor system x̂&#39; = (A - KC)x̂ + (B-KD)u + Ky ŷ  = Cx + Du with the input equation [B-KD K] * [u; y]</p><p>If covariance matrices <code>R1, R2</code> are given, the kalman gain <code>K</code> is calculaded.</p><p>See also <code>innovation_form</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L641-L653">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.obsv" href="#ControlSystems.obsv"><code>ControlSystems.obsv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obsv(A, C, n=size(A,1))
obsv(sys, n=sys.nx)</code></pre><p>Compute the observability matrix with <code>n</code> rows for the system described by <code>(A, C)</code> or <code>sys</code>. Providing the optional <code>n &gt; sys.nx</code> returns an extended observability matrix.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syst = similarity_transform(sys, T; unitary=false)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on <code>sys</code> such that</p><pre><code class="nohighlight hljs">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre><p>If <code>unitary=true</code>, <code>T</code> is assumed unitary and the matrix adjoint is used instead of the inverse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L584-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}" href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lyap(A, Q; kwargs...)</code></pre><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p><p>Uses <code>MatrixEquations.lyapc / MatrixEquations.lyapd</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.lyapc / ControlSystems.MatrixEquations.lyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(sys, p=2; tol=1e-6)</code></pre><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the H∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the H∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>hinfnorm</code> instead. See <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a> for further documentation.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a <code>StateSpace</code> model if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ee8a1bb019aee6f443c3b76ab4ddf3849c6cc7ac/src/matrix_comps.jl#L188-L203">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/">« Constructors</a><a class="docs-footer-nextpage" href="../synthesis/">Synthesis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 21 February 2022 10:51">Monday 21 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
