<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · ControlSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/analysis/">Analysis</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../../examples/automatic_differentiation/">Automatic differentiation</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li class="is-active"><a class="tocitem" href>Analysis</a><ul class="internal"><li><a class="tocitem" href="#Videos"><span>Videos</span></a></li></ul></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a></li><li><a href="#ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a></li><li><a href="#ControlSystemsBase.balance"><code>ControlSystemsBase.balance</code></a></li><li><a href="#ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.balreal</code></a></li><li><a href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.baltrunc</code></a></li><li><a href="#ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystemsBase.covar</code></a></li><li><a href="#ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}"><code>ControlSystemsBase.ctrb</code></a></li><li><a href="#ControlSystemsBase.damp-Tuple{LTISystem}"><code>ControlSystemsBase.damp</code></a></li><li><a href="#ControlSystemsBase.dampreport-Tuple{IO, LTISystem}"><code>ControlSystemsBase.dampreport</code></a></li><li><a href="#ControlSystemsBase.dcgain"><code>ControlSystemsBase.dcgain</code></a></li><li><a href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>ControlSystemsBase.delaymargin</code></a></li><li><a href="#ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.gangoffour</code></a></li><li><a href="#ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}"><code>ControlSystemsBase.gangofseven</code></a></li><li><a href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.gram</code></a></li><li><a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.grampd</code></a></li><li><a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystemsBase.hinfnorm</code></a></li><li><a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a></li><li><a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a></li><li><a href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.linfnorm</code></a></li><li><a href="#ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.margin</code></a></li><li><a href="#ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}"><code>ControlSystemsBase.markovparam</code></a></li><li><a href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystemsBase.observer_controller</code></a></li><li><a href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemsBase.observer_filter</code></a></li><li><a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>ControlSystemsBase.observer_predictor</code></a></li><li><a href="#ControlSystemsBase.obsv"><code>ControlSystemsBase.obsv</code></a></li><li><a href="#ControlSystemsBase.poles-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.poles</code></a></li><li><a href="#ControlSystemsBase.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystemsBase.reduce_sys</code></a></li><li><a href="#ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystemsBase.relative_gain_array</code></a></li><li><a href="#ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystemsBase.relative_gain_array</code></a></li><li><a href="#ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.similarity_transform</code></a></li><li><a href="#ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}"><code>ControlSystemsBase.time_scale</code></a></li><li><a href="#ControlSystemsBase.tzeros-Tuple{TransferFunction}"><code>ControlSystemsBase.tzeros</code></a></li><li><a href="#ControlSystemsBase.zpkdata-Tuple{LTISystem}"><code>ControlSystemsBase.zpkdata</code></a></li><li><a href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li></ul><p>For robust analysis, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#System-analysis">RobustAndOptimalControl.jl</a>.</p><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.damp-Tuple{LTISystem}" href="#ControlSystemsBase.damp-Tuple{LTISystem}"><code>ControlSystemsBase.damp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wn, zeta, ps = damp(sys)</code></pre><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.dampreport-Tuple{IO, LTISystem}" href="#ControlSystemsBase.dampreport-Tuple{IO, LTISystem}"><code>ControlSystemsBase.dampreport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dampreport(sys)</code></pre><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.dcgain" href="#ControlSystemsBase.dcgain"><code>ControlSystemsBase.dcgain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dcgain(sys, ϵ=0)</code></pre><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p><p><code>ϵ</code> can be provided to evaluate the dcgain with a small perturbation into the stability region of the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.delaymargin-Tuple{LTISystem}" href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>ControlSystemsBase.delaymargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dₘ = delaymargin(G::LTISystem)</code></pre><p>Return the delay margin, dₘ. For discrete-time systems, the delay margin is normalized by the sample time, i.e., the value represents the margin in number of sample times.  Only supports SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L528-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.gangoffour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T = gangoffour(P, C; minimal=true)
gangoffour(P::AbstractVector, C::AbstractVector; minimal=true)</code></pre><p>Given a transfer function describing the plant <code>P</code> and a transfer function describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = (1+PC)\P</code> Load disturbance to measurement signal</li><li><code>CS = (1+PC)\C</code> Measurement noise to control signal</li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li></ul><p>If <code>minimal=true</code>, <a href="../constructors/#ControlSystemsBase.minreal"><code>minreal</code></a> will be applied to all transfer functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L557-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}" href="#ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}"><code>ControlSystemsBase.gangofseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T, RY, RU, RE = gangofseven(P,C,F)</code></pre><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = P/(1+PC)</code></li><li><code>CS = C/(1+PC)</code></li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li><li><code>RY = PCF/(1+PC)</code></li><li><code>RU = CF/(1+P*C)</code></li><li><code>RE = F/(1+P*C)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L579-L592">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.margin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wgm, gm, wpm, pm = margin(sys::LTISystem, w::Vector; full=false, allMargins=false)</code></pre><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><p>If <code>!allMargins</code>, return only the smallest margin</p><p>If <code>full</code> return also <code>fullPhase</code> See also <a href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>delaymargin</code></a> and <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/api/#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L400-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}" href="#ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}"><code>ControlSystemsBase.markovparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">markovparam(sys, n)</code></pre><p>Compute the <code>n</code>th markov parameter of discrete-time state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.poles-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.poles-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.poles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">poles(sys)</code></pre><p>Compute the poles of system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}" href="#ControlSystemsBase.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystemsBase.reduce_sys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_sys(A::AbstractMatrix, B::AbstractMatrix, C::AbstractMatrix, D::AbstractMatrix, meps::AbstractFloat)</code></pre><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}" href="#ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystemsBase.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(A::AbstractMatrix; tol = 1.0e-15)</code></pre><p>Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L356-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}" href="#ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystemsBase.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(G, w::AbstractVector)
relative_gain_array(G, w::Number)</code></pre><p>Calculate the relative gain array of <code>G</code> at frequencies <code>w</code>.  G(iω) .* pinv(tranpose(G(iω)))</p><p>The RGA can be used to find input-output pairings for MIMO control using individually tuned loops. Pair the inputs and outputs such that the RGA(ωc) at the crossover frequency becomes as close to diagonal as possible. Avoid pairings such that RGA(0) contains negative diagonal elements. </p><ul><li>The sum of the absolute values of the entries in the RGA is a good measure of the &quot;true condition number&quot; of G, the best condition number that can be achieved by input/output scaling of <code>G</code>, -Glad, Ljung.</li><li>The RGA is invariant to input/output scaling of <code>G</code>.</li><li>If the RGA contains large entries, the system may be sensitive to model errors, -Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;:<ul><li>Uncertainty in the input channels (diagonal input uncertainty). Plants with</li></ul>large RGA-elements around the crossover frequency are fundamentally   difficult to control because of sensitivity to input uncertainty (e.g. caused   by uncertain or neglected actuator dynamics). In particular, decouplers or   other inverse-based controllers should not be used for plants with large RGAeleme<ul><li>Element uncertainty. Large RGA-elements imply sensitivity to element-by-element uncertainty.</li></ul>However, this kind of uncertainty may not occur in practice due to physical couplings   between the transfer function elements. Therefore, diagonal input uncertainty   (which is always present) is usually of more concern for plants with large RGA elements.</li></ul><p>The relative gain array is computed using the The unit-consistent (UC) generalized inverse Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L323-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.tzeros-Tuple{TransferFunction}" href="#ControlSystemsBase.tzeros-Tuple{TransferFunction}"><code>ControlSystemsBase.tzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tzeros(sys)</code></pre><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.zpkdata-Tuple{LTISystem}" href="#ControlSystemsBase.zpkdata-Tuple{LTISystem}"><code>ControlSystemsBase.zpkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z, p, k = zpkdata(sys)</code></pre><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><ul><li><code>z</code> : Matrix{Vector{ComplexF64}}, (ny × nu)</li><li><code>p</code> : Matrix{Vector{ComplexF64}}, (ny × nu)</li><li><code>k</code> : Matrix{Float64}, (ny × nu)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/analysis.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}" href="#ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are(::Continuous, A, B, Q, R)</code></pre><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>In an LQR problem, <code>Q</code> is associated with the state penalty <span>$x&#39;Qx$</span> while <code>R</code> is associated with the control penalty <span>$u&#39;Ru$</span>. See <a href="../synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>lqr</code></a> for more details.</p><p>Uses <code>MatrixEquations.arec</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.arec</code>, note that they define the input arguments in a different order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}" href="#ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are(::Discrete, A, B, Q, R; kwargs...)</code></pre><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where Q&gt;=0 and R&gt;0</p><p>In an LQR problem, <code>Q</code> is associated with the state penalty <span>$x&#39;Qx$</span> while <code>R</code> is associated with the control penalty <span>$u&#39;Ru$</span>. See <a href="../synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>lqr</code></a> for more details.</p><p>Uses <code>MatrixEquations.ared</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.ared</code>, note that they define the input arguments in a different order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.balance" href="#ControlSystemsBase.balance"><code>ControlSystemsBase.balance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S, P, B = balance(A[, perm=true])</code></pre><p>Compute a similarity transform <code>T = S*P</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L482-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.balreal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sysr, G, T = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>diagm(G)</code>. <code>T</code> is the similarity transform between the old state <code>x</code> and the new state <code>z</code> such that <code>Tz = x</code>.</p><p>See also <a href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>gram</code></a>, <a href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>baltrunc</code></a>.</p><p>Reference: Varga A., Balancing-free square-root algorithm for computing singular perturbation approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L519-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.baltrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysr, G, T = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, n = nothing, residual = false)</code></pre><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>diagm(G)</code>, and truncating it to order <code>n</code>. If <code>n</code> is not provided, it&#39;s chosen such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed.</p><p><code>T</code> is the similarity transform between the old state <code>x</code> and the newstate <code>z</code> such that <code>Tz = x</code>.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder.</p><p>For more advanced model reduction, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Model-reduction">RobustAndOptimalControl.jl - Model Reduction</a>.</p><p><strong>Extended help</strong></p><p>Note: Gramian computations are sensitive to input-output scaling. For the result of a numerical balancing, gramian computation or truncation of MIMO systems to be meaningful, the inputs and outputs of the system must thus be scaled in a meaningful way. A common (but not the only) approach is:</p><ul><li>The outputs are scaled such that the maximum allowed control error, the maximum expected reference variation, or the maximum expected variation, is unity.</li><li>The input variables are scaled to have magnitude one. This is done by dividing each variable by its maximum expected or allowed change, i.e., <span>$u_{scaled} = u / u_{max}$</span></li></ul><p>Without such scaling, the result of balancing will depend on the units used to measure the input and output signals, e.g., a change of unit for one output from meter to millimeter will make this output 1000x more important.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L560-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}" href="#ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystemsBase.covar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">P = covar(sys, W)</code></pre><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of the output <code>y</code> of a <code>StateSpace</code> model <code>sys</code> driven by white Gaussian noise <code>w</code> with covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> (δ is the Dirac delta).</p><p>Remark: If <code>sys</code> is unstable then the resulting covariance is a matrix of <code>Inf</code>s. Entries corresponding to direct feedthrough (D<em>W</em>D&#39; .!= 0) will equal <code>Inf</code> for continuous-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}" href="#ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}"><code>ControlSystemsBase.ctrb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ctrb(A, B)
ctrb(sys)</code></pre><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.gram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram(sys, opt; kwargs...)</code></pre><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p><p>See also <a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a> For keyword arguments, see <a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a>.</p><p><strong>Extended help</strong></p><p>Note: Gramian computations are sensitive to input-output scaling. For the result of a numerical balancing, gramian computation or truncation of MIMO systems to be meaningful, the inputs and outputs of the system must thus be scaled in a meaningful way. A common (but not the only) approach is:</p><ul><li>The outputs are scaled such that the maximum allowed control error, the maximum expected reference variation, or the maximum expected variation, is unity.</li><li>The input variables are scaled to have magnitude one. This is done by dividing each variable by its maximum expected or allowed change, i.e., <span>$u_{scaled} = u / u_{max}$</span></li></ul><p>Without such scaling, the result of balancing will depend on the units used to measure the input and output signals, e.g., a change of unit for one output from meter to millimeter will make this output 1000x more important.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L100-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.grampd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U = grampd(sys, opt; kwargs...)</code></pre><p>Return a Cholesky factor <code>U</code> of the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian <code>G = U*U&#39;</code>. If <code>opt</code> is <code>:o</code>, computes the observability grammian <code>G = U&#39;U</code>.</p><p>Obtain a <code>Cholesky</code> object by <code>Cholesky(U)</code> for observability grammian</p><p>Uses <code>MatrixEquations.plyapc/plyapd</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.plyapc/plyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}" href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystemsBase.hinfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = hinfnorm(sys; tol=1e-6)</code></pre><p>Compute the H∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain Ninf is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code>  if <code>G</code> is stable (σ_max = largest singular value)       :=        <code>Inf&#39;           if</code>G` is unstable</p><p><code>tol</code> is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>linfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L247-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, R1, R2[, R12])
sysi = innovation_form(sys; sysw=I, syse=I, R1=I, R2=I)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w ~ R1
y  = Cx + Du + e ~ R2</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>If <code>sysw</code> (<code>syse</code>) is given, the covariance resulting in filtering noise with <code>R1</code> (<code>R2</code>) through <code>sysw</code> (<code>syse</code>) is used as covariance.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L697-L716">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, K)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + Kv
y  = Cx + Du + v</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L728-L744">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.linfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = linfnorm(sys; tol=1e-6)</code></pre><p>Compute the L∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain <code>Ninf</code> is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code> (σ_max denotes the largest singular value)</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L275-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}" href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystemsBase.observer_controller</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cont = observer_controller(sys, L::AbstractMatrix, K::AbstractMatrix; direct=false)</code></pre><p><strong>If <code>direct = false</code></strong></p><p>Return the observer_controller <code>cont</code> that is given by <code>ss(A - B*L - K*C + K*D*L, K, L, 0)</code> such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-KC</code> and <code>A-BL</code>.</p><p>This controller does not have a direct term, and corresponds to state feedback operating on state estimated by <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a>. Use this form if the computed control signal is applied at the next sampling instant, or with an otherwise large delay in relation to the measurement fed into the controller.</p><p>Ref: &quot;Computer-Controlled Systems&quot; Eq 4.37</p><p><strong>If <code>direct = true</code></strong></p><p>Return the observer<em>controller <code>cont</code> that is given by <code>ss((I-KC)(A-BL), (I-KC)(A-BL)K, L, LK)</code> such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-BL</code> and <code>A-BL-KC</code>. This controller has a direct term, and corresponds to state feedback operating on state estimated by [`observer</em>filter`](@ref). Use this form if the computed control signal is applied immediately after receiveing a measurement. This version typically has better performance than the one without a direct term.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use this formulation, the observer gain <code>K</code> should have been designed for the pair <code>(A, CA)</code> rather than <code>(A, C)</code>. To do this, pass <code>direct = true</code> when calling <a href="../synthesis/#ControlSystemsBase.place"><code>place</code></a> or <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p></div></div><p>Ref: Ref: &quot;Computer-Controlled Systems&quot; pp 140 and &quot;Computer-Controlled Systems&quot; pp 162 prob 4.7</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: Model of system</li><li><code>L</code>: State-feedback gain <code>u = -Lx</code></li><li><code>K</code>: Observer gain</li></ul><p>See also <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a> and <a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>innovation_form</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L800-L830">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}" href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemsBase.observer_filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observer_filter(sys, K; output_state = false)</code></pre><p>Return the observer filter </p><p class="math-container">\[\begin{aligned}
x̂(k|k) &amp;= (I - KC)Ax̂(k-1|k-1) + (I - KC)Bu(k-1) + Ky(k) \\
\end{aligned}\]</p><p>with the input equation <code>[(I - KC)B K] * [u(k-1); y(k)]</code>.</p><p>Note the time indices in the equations, the filter assumes that the user passes the <em>current</em> <span>$y(k)$</span>, but the <em>past</em> <span>$u(k-1)$</span>, that is, this filter is used to estimate the state <em>before</em> the current control input has been applied. This causes a state-feedback controller acting on the estimate produced by this observer to have a direct term.</p><p>This is similar to <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a>, but in contrast to the predictor, the filter output depends on the current measurement, whereas the predictor output only depend on past measurements.</p><p>The observer filter is equivalent to the <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a> for continuous-time systems.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To use this formulation, the observer gain <code>K</code> should have been designed for the pair <code>(A, CA)</code> rather than <code>(A, C)</code>. To do this, pass <code>direct = true</code> when calling <a href="../synthesis/#ControlSystemsBase.place"><code>place</code></a> or <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p></div></div><p>Ref: &quot;Computer-Controlled Systems&quot; Eq 4.32</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L844-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}" href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>ControlSystemsBase.observer_predictor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observer_predictor(sys::AbstractStateSpace, K; h::Int = 1, output_state = false)
observer_predictor(sys::AbstractStateSpace, R1, R2[, R12]; output_state = false)</code></pre><p>If <code>sys</code> is continuous, return the observer predictor system</p><p class="math-container">\[\begin{aligned}
x̂&#39; &amp;= (A - KC)x̂ + (B-KD)u + Ky \\
ŷ  &amp;= Cx + Du
\end{aligned}\]</p><p>with the input equation <code>[B-KD K] * [u; y]</code></p><p>If <code>sys</code> is discrete, the prediction horizon <code>h</code> may be specified, in which case measurements up to and including time <code>t-h</code> and inputs up to and including time <code>t</code> are used to predict <code>y(t)</code>.</p><p>If covariance matrices <code>R1, R2</code> are given, the kalman gain <code>K</code> is calculated using <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p><p>If <code>output_state</code> is true, the output is the state estimate <code>x̂</code> instead of the output estimate <code>ŷ</code>.</p><p>See also <a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>innovation_form</code></a>, <a href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a> and <a href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>observer_filter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L749-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.obsv" href="#ControlSystemsBase.obsv"><code>ControlSystemsBase.obsv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obsv(A, C, n=size(A,1))
obsv(sys, n=sys.nx)</code></pre><p>Compute the observability matrix with <code>n</code> rows for the system described by <code>(A, C)</code> or <code>sys</code>. Providing the optional <code>n &gt; sys.nx</code> returns an extended observability matrix.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.similarity_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syst = similarity_transform(sys, T; unitary=false)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on <code>sys</code> such that</p><pre><code class="nohighlight hljs">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre><p>If <code>unitary=true</code>, <code>T</code> is assumed unitary and the matrix adjoint is used instead of the inverse. See also <a href="lib/@ref"><code>balance_statespace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L619-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}" href="#ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}"><code>ControlSystemsBase.time_scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_scale(sys::AbstractStateSpace{Continuous}, a; balanced = false)
time_scale(G::TransferFunction{Continuous},     a; balanced = true)</code></pre><p>Rescale the time axis (change time unit) of <code>sys</code>.</p><p>For systems where the dominant time constants are very far from 1, e.g., in electronics, rescaling the time axis may be beneficial for numerical performance, in particular for continuous-time simulations.</p><p>Scaling of time for a function <span>$f(t)$</span> with Laplace transform <span>$F(s)$</span> can be stated as</p><p class="math-container">\[f(at) \leftrightarrow \dfrac{1}{a} F\big(\dfrac{s}{a}\big)\]</p><p>The keyword argument <code>balanced</code> indicates whether or not to apply a balanced scaling on the <code>B</code> and <code>C</code> matrices. For statespace systems, this defaults to false since it changes the state representation, only <code>B</code> will be scaled. For transfer functions, it defaults to true.</p><p><strong>Example:</strong></p><p>The following example show how a system with a time constant on the order of one micro-second is rescaled such that the time constant becomes 1, i.e., the time unit is changed from seconds to micro-seconds. </p><pre><code class="language-julia hljs">Gs  = tf(1, [1e-6, 1])     # micro-second time scale modeled in seconds
Gms = time_scale(Gs, 1e-6) # Change to micro-second time scale
Gms == tf(1, [1, 1])       # Gms now has micro-seconds as time unit</code></pre><p>The next example illustrates how the time axis of a time-domain simulation changes by time scaling </p><pre><code class="language-julia hljs">t = 0:0.1:50 # original time axis
a = 10       # Scaling factor
sys1 = ssrand(1,1,5)
res1 = step(sys1, t)      # Perform original simulation
sys2 = time_scale(sys, a) # Scale time
res2 = step(sys2, t ./ a) # Simulate on scaled time axis, note the `1/a`
isapprox(res1.y, res2.y, rtol=1e-3, atol=1e-3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L646-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}" href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lyap(A, Q; kwargs...)</code></pre><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p><p>Uses <code>MatrixEquations.lyapc / MatrixEquations.lyapd</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.lyapc / ControlSystemsBase.MatrixEquations.lyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(sys, p=2; tol=1e-6)</code></pre><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the H∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the L∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>hinfnorm</code> instead. See <a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a> for further documentation.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a <code>StateSpace</code> model if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e72a1ca802a76e9ddf64dd9e7bab1372a26831ad/lib/ControlSystemsBase/src/matrix_comps.jl#L219-L234">source</a></section></article><h2 id="Videos"><a class="docs-heading-anchor" href="#Videos">Videos</a><a id="Videos-1"></a><a class="docs-heading-anchor-permalink" href="#Videos" title="Permalink"></a></h2><p>Basic usage of robustness analysis with JuliaControl</p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/zTW4mlWNumo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/">« Constructors</a><a class="docs-footer-nextpage" href="../synthesis/">Synthesis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 11 July 2023 13:28">Tuesday 11 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
