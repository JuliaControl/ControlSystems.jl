<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis · ControlSystems.jl</title><meta name="title" content="Analysis · ControlSystems.jl"/><meta property="og:title" content="Analysis · ControlSystems.jl"/><meta property="twitter:title" content="Analysis · ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/analysis/">Analysis</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../../examples/automatic_differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../../examples/tuning_from_data/">Tune a controller using experimental data</a></li><li><a class="tocitem" href="../../examples/zoh/">Analysis of sampled-data (continuous/discrete) systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li class="is-active"><a class="tocitem" href>Analysis</a><ul class="internal"><li><a class="tocitem" href="#Videos"><span>Videos</span></a></li></ul></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a></li><li><a href="#ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a></li><li><a href="#ControlSystemsBase.balance"><code>ControlSystemsBase.balance</code></a></li><li><a href="#ControlSystemsBase.balance_statespace"><code>ControlSystemsBase.balance_statespace</code></a></li><li><a href="#ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.balreal</code></a></li><li><a href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.baltrunc</code></a></li><li><a href="#ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemsBase.controllability</code></a></li><li><a href="#ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystemsBase.covar</code></a></li><li><a href="#ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}"><code>ControlSystemsBase.ctrb</code></a></li><li><a href="#ControlSystemsBase.damp-Tuple{LTISystem}"><code>ControlSystemsBase.damp</code></a></li><li><a href="#ControlSystemsBase.dampreport-Tuple{IO, LTISystem}"><code>ControlSystemsBase.dampreport</code></a></li><li><a href="#ControlSystemsBase.dcgain"><code>ControlSystemsBase.dcgain</code></a></li><li><a href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>ControlSystemsBase.delaymargin</code></a></li><li><a href="#ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.gangoffour</code></a></li><li><a href="#ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}"><code>ControlSystemsBase.gangofseven</code></a></li><li><a href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.gram</code></a></li><li><a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.grampd</code></a></li><li><a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystemsBase.hinfnorm</code></a></li><li><a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a></li><li><a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a></li><li><a href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.linfnorm</code></a></li><li><a href="#ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.margin</code></a></li><li><a href="#ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}"><code>ControlSystemsBase.markovparam</code></a></li><li><a href="#ControlSystemsBase.observability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemsBase.observability</code></a></li><li><a href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystemsBase.observer_controller</code></a></li><li><a href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemsBase.observer_filter</code></a></li><li><a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>ControlSystemsBase.observer_predictor</code></a></li><li><a href="#ControlSystemsBase.obsv"><code>ControlSystemsBase.obsv</code></a></li><li><a href="#ControlSystemsBase.plyap-Tuple{AbstractStateSpace, Vararg{Any}}"><code>ControlSystemsBase.plyap</code></a></li><li><a href="#ControlSystemsBase.poles-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.poles</code></a></li><li><a href="#ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystemsBase.relative_gain_array</code></a></li><li><a href="#ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystemsBase.relative_gain_array</code></a></li><li><a href="#ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.similarity_transform</code></a></li><li><a href="#ControlSystemsBase.stab_unstab-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.stab_unstab</code></a></li><li><a href="#ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}"><code>ControlSystemsBase.time_scale</code></a></li><li><a href="#ControlSystemsBase.tzeros-Union{Tuple{TransferFunction{&lt;:ControlSystemsBase.TimeEvolution, ControlSystemsBase.SisoRational{T}}}, Tuple{T}} where T"><code>ControlSystemsBase.tzeros</code></a></li><li><a href="#ControlSystemsBase.zpkdata-Tuple{LTISystem}"><code>ControlSystemsBase.zpkdata</code></a></li><li><a href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li></ul><p>For robust analysis, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#System-analysis">RobustAndOptimalControl.jl</a>.</p><h1 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.damp-Tuple{LTISystem}" href="#ControlSystemsBase.damp-Tuple{LTISystem}"><code>ControlSystemsBase.damp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Wn, zeta, ps = damp(sys)</code></pre><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.dampreport-Tuple{IO, LTISystem}" href="#ControlSystemsBase.dampreport-Tuple{IO, LTISystem}"><code>ControlSystemsBase.dampreport</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dampreport(sys)</code></pre><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.dcgain" href="#ControlSystemsBase.dcgain"><code>ControlSystemsBase.dcgain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dcgain(sys, ϵ=0)</code></pre><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p><p><code>ϵ</code> can be provided to evaluate the dcgain with a small perturbation into the stability region of the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L139-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.delaymargin-Tuple{LTISystem}" href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>ControlSystemsBase.delaymargin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dₘ = delaymargin(G::LTISystem)</code></pre><p>Return the delay margin, dₘ. For discrete-time systems, the delay margin is normalized by the sample time, i.e., the value represents the margin in number of sample times.  Only supports SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L621-L626">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.gangoffour</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T = gangoffour(P, C; minimal=true)
gangoffour(P::AbstractVector, C::AbstractVector; minimal=true)</code></pre><p>Given a transfer function describing the plant <code>P</code> and a transfer function describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = (1+PC)\P</code> Load disturbance to measurement signal</li><li><code>CS = (1+PC)\C</code> Measurement noise to control signal</li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li></ul><p>If <code>minimal=true</code>, <a href="../constructors/#ControlSystemsBase.minreal"><code>minreal</code></a> will be applied to all transfer functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L650-L662">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}" href="#ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}"><code>ControlSystemsBase.gangofseven</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T, RY, RU, RE = gangofseven(P,C,F)</code></pre><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = P/(1+PC)</code></li><li><code>CS = C/(1+PC)</code></li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li><li><code>RY = PCF/(1+PC)</code></li><li><code>RU = CF/(1+P*C)</code></li><li><code>RE = F/(1+P*C)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L672-L685">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.margin</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">wgm, gm, wpm, pm = margin(sys::LTISystem, w::Vector; full=false, allMargins=false, adjust_phase_start=true)</code></pre><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><ul><li>If <code>!allMargins</code>, return only the smallest margin</li><li>If <code>full</code> return also <code>fullPhase</code></li><li><code>adjust_phase_start</code>: If true, the phase will be adjusted so that it starts at -90*intexcess degrees, where <code>intexcess</code> is the integrator excess of the system.</li></ul><p>See also <a href="#ControlSystemsBase.delaymargin-Tuple{LTISystem}"><code>delaymargin</code></a> and <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/api/#RobustAndOptimalControl.diskmargin"><code>RobustAndOptimalControl.diskmargin</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L474-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}" href="#ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{&lt;:Discrete}, Integer}"><code>ControlSystemsBase.markovparam</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">markovparam(sys, n)</code></pre><p>Compute the <code>n</code>th markov parameter of discrete-time state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.poles-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.poles-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.poles</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">poles(sys)</code></pre><p>Compute the poles of system <code>sys</code>.</p><p>Note: Poles with multiplicity <code>n &gt; 1</code> may suffer numerical inaccuracies on the order <code>eps(numeric_type(sys))^(1/n)</code>, i.e., a double pole in a system with <code>Float64</code> coefficients may be computed with an error of about <code>√(eps(Float64)) ≈ 1.5e-8</code>.</p><p>To compute the poles of a system with non-BLAS floats, such as <code>BigFloat</code>, install and load the package <code>GenericSchur.jl</code> before calling <code>poles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}" href="#ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystemsBase.relative_gain_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(A::AbstractMatrix; tol = 1.0e-15)</code></pre><p>Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L430-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}" href="#ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystemsBase.relative_gain_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(G, w::AbstractVector)
relative_gain_array(G, w::Number)</code></pre><p>Calculate the relative gain array of <code>G</code> at frequencies <code>w</code>.  G(iω) .* pinv(tranpose(G(iω)))</p><p>The RGA can be used to find input-output pairings for MIMO control using individually tuned loops. Pair the inputs and outputs such that the RGA(ωc) at the crossover frequency becomes as close to diagonal as possible. Avoid pairings such that RGA(0) contains negative diagonal elements. </p><ul><li>The sum of the absolute values of the entries in the RGA is a good measure of the &quot;true condition number&quot; of G, the best condition number that can be achieved by input/output scaling of <code>G</code>, -Glad, Ljung.</li><li>The RGA is invariant to input/output scaling of <code>G</code>.</li><li>If the RGA contains large entries, the system may be sensitive to model errors, -Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;:<ul><li>Uncertainty in the input channels (diagonal input uncertainty). Plants with</li></ul>large RGA-elements around the crossover frequency are fundamentally   difficult to control because of sensitivity to input uncertainty (e.g. caused   by uncertain or neglected actuator dynamics). In particular, decouplers or   other inverse-based controllers should not be used for plants with large RGAeleme<ul><li>Element uncertainty. Large RGA-elements imply sensitivity to element-by-element uncertainty.</li></ul>However, this kind of uncertainty may not occur in practice due to physical couplings   between the transfer function elements. Therefore, diagonal input uncertainty   (which is always present) is usually of more concern for plants with large RGA elements.</li></ul><p>The relative gain array is computed using the The unit-consistent (UC) generalized inverse Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L397-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.tzeros-Union{Tuple{TransferFunction{&lt;:ControlSystemsBase.TimeEvolution, ControlSystemsBase.SisoRational{T}}}, Tuple{T}} where T" href="#ControlSystemsBase.tzeros-Union{Tuple{TransferFunction{&lt;:ControlSystemsBase.TimeEvolution, ControlSystemsBase.SisoRational{T}}}, Tuple{T}} where T"><code>ControlSystemsBase.tzeros</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tzeros(sys)
tzeros(sys::AbstractStateSpace; extra=Val(false))</code></pre><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p><p>If <code>sys</code> is a state-space system the function has additional keyword arguments, see <a href="https://andreasvarga.github.io/MatrixPencils.jl/dev/sklfapps.html#MatrixPencils.spzeros"><code>?ControlSystemsBase.MatrixPencils.spzeros</code></a> for more details. If <code>extra = Val(true)</code>, the function returns <code>z, iz, KRInfo</code> where <code>z</code> are the transmission zeros, information on the multiplicities of infinite zeros in <code>iz</code> and information on the Kronecker-structure in the KRInfo object. The number of infinite zeros is the sum of the components of iz.</p><p>To compute zeros of a system with non-BLAS floats, such as <code>BigFloat</code>, install and load the package <code>GenericSchur.jl</code> before calling <code>tzeros</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L243-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.zpkdata-Tuple{LTISystem}" href="#ControlSystemsBase.zpkdata-Tuple{LTISystem}"><code>ControlSystemsBase.zpkdata</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">z, p, k = zpkdata(sys)</code></pre><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><ul><li><code>z</code> : Matrix{Vector{ComplexF64}}, (ny × nu)</li><li><code>p</code> : Matrix{Vector{ComplexF64}}, (ny × nu)</li><li><code>k</code> : Matrix{Float64}, (ny × nu)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/analysis.jl#L168-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}" href="#ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">are(::Continuous, A, B, Q, R)</code></pre><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>In an LQR problem, <code>Q</code> is associated with the state penalty <span>$x&#39;Qx$</span> while <code>R</code> is associated with the control penalty <span>$u&#39;Ru$</span>. See <a href="../synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>lqr</code></a> for more details.</p><p>Uses <code>MatrixEquations.arec</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.arec</code>, note that they define the input arguments in a different order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}" href="#ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}"><code>ControlSystemsBase.are</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">are(::Discrete, A, B, Q, R; kwargs...)</code></pre><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where Q&gt;=0 and R&gt;0</p><p>In an LQR problem, <code>Q</code> is associated with the state penalty <span>$x&#39;Qx$</span> while <code>R</code> is associated with the control penalty <span>$u&#39;Ru$</span>. See <a href="../synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>lqr</code></a> for more details.</p><p>Uses <code>MatrixEquations.ared</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.ared</code>, note that they define the input arguments in a different order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.balance" href="#ControlSystemsBase.balance"><code>ControlSystemsBase.balance</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">S, P, B = balance(A[, perm=true])</code></pre><p>Compute a similarity transform <code>T = S*P</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L531-L537">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.balreal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>sysr, G, T = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>diagm(G)</code>. <code>T</code> is the similarity transform between the old state <code>x</code> and the new state <code>z</code> such that <code>z = Tx</code>.</p><p>See also <a href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>gram</code></a>, <a href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>baltrunc</code></a>.</p><p>Reference: Varga A., Balancing-free square-root algorithm for computing singular perturbation approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L568-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.baltrunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysr, G, T = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, n = nothing, residual = false)</code></pre><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>diagm(G)</code>, and truncating it to order <code>n</code>. If <code>n</code> is not provided, it&#39;s chosen such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed.</p><p><code>T</code> is the projection matrix between the old state <code>x</code> and the newstate <code>z</code> such that <code>z = Tx</code>. <code>T</code> will in general be a non-square matrix.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder.</p><p>For more advanced model reduction, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Model-reduction">RobustAndOptimalControl.jl - Model Reduction</a>.</p><p><strong>Extended help</strong></p><p>Note: Gramian computations are sensitive to input-output scaling. For the result of a numerical balancing, gramian computation or truncation of MIMO systems to be meaningful, the inputs and outputs of the system must thus be scaled in a meaningful way. A common (but not the only) approach is:</p><ul><li>The outputs are scaled such that the maximum allowed control error, the maximum expected reference variation, or the maximum expected variation, is unity.</li><li>The input variables are scaled to have magnitude one. This is done by dividing each variable by its maximum expected or allowed change, i.e., <span>$u_{scaled} = u / u_{max}$</span></li></ul><p>Without such scaling, the result of balancing will depend on the units used to measure the input and output signals, e.g., a change of unit for one output from meter to millimeter will make this output 1000x more important.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L609-L630">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T" href="#ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemsBase.controllability</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">controllability(A, B; atol, rtol)
controllability(sys; atol, rtol)</code></pre><p>Check for controllability of the pair <code>(A, B)</code> or <code>sys</code> using the PHB test.</p><p>The return value contains the field <code>iscontrollable</code> which is <code>true</code> if the rank condition is met at all eigenvalues of <code>A</code>, and <code>false</code> otherwise. The returned structure also contains the rank and smallest singular value at each individual eigenvalue of <code>A</code> in the fields <code>ranks</code> and <code>sigma_min</code>.</p><p>Technically, this function checks for controllability from the origin, also called reachability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L171-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}" href="#ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystemsBase.covar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">P = covar(sys, W)</code></pre><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of the output <code>y</code> of a <code>StateSpace</code> model <code>sys</code> driven by white Gaussian noise <code>w</code> with covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> (δ is the Dirac delta).</p><p>Remark: If <code>sys</code> is unstable then the resulting covariance is a matrix of <code>Inf</code>s. Entries corresponding to direct feedthrough (D<em>W</em>D&#39; .!= 0) will equal <code>Inf</code> for continuous-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L220-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}" href="#ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}"><code>ControlSystemsBase.ctrb</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ctrb(A, B)
ctrb(sys)</code></pre><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite or to call the function <a href="#ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>controllability</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L144-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.gram</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gram(sys, opt; kwargs...)</code></pre><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p><p>See also <a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a> For keyword arguments, see <a href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a>.</p><p><strong>Extended help</strong></p><p>Note: Gramian computations are sensitive to input-output scaling. For the result of a numerical balancing, gramian computation or truncation of MIMO systems to be meaningful, the inputs and outputs of the system must thus be scaled in a meaningful way. A common (but not the only) approach is:</p><ul><li>The outputs are scaled such that the maximum allowed control error, the maximum expected reference variation, or the maximum expected variation, is unity.</li><li>The input variables are scaled to have magnitude one. This is done by dividing each variable by its maximum expected or allowed change, i.e., <span>$u_{scaled} = u / u_{max}$</span></li></ul><p>Without such scaling, the result of balancing will depend on the units used to measure the input and output signals, e.g., a change of unit for one output from meter to millimeter will make this output 1000x more important.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L100-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystemsBase.grampd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">U = grampd(sys, opt; kwargs...)</code></pre><p>Return a Cholesky factor <code>U</code> of the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian <code>G = U*U&#39;</code>. If <code>opt</code> is <code>:o</code>, computes the observability grammian <code>G = U&#39;U</code>.</p><p>Obtain a <code>Cholesky</code> object by <code>Cholesky(U)</code> for observability grammian</p><p>Uses <code>MatrixEquations.plyapc/plyapd</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.plyapc/plyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L75-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}" href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystemsBase.hinfnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = hinfnorm(sys; tol=1e-6)</code></pre><p>Compute the H∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain Ninf is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code>  if <code>G</code> is stable (σ_max = largest singular value)       :=        <code>Inf&#39;           if</code>G` is unstable</p><p><code>tol</code> is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>linfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L296-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, R1, R2[, R12])
sysi = innovation_form(sys; sysw=I, syse=I, R1=I, R2=I)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w ~ R1
y  = Cx + Du + e ~ R2</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>If <code>sysw</code> (<code>syse</code>) is given, the covariance resulting in filtering noise with <code>R1</code> (<code>R2</code>) through <code>sysw</code> (<code>syse</code>) is used as covariance.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L773-L792">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.innovation_form</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, K)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + Kv
y  = Cx + Du + v</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L804-L820">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.linfnorm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ninf, ω_peak = linfnorm(sys; tol=1e-6)</code></pre><p>Compute the L∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain <code>Ninf</code> is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code> (σ_max denotes the largest singular value)</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L324-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.observability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T" href="#ControlSystemsBase.observability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>ControlSystemsBase.observability</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">observability(A, C; atol, rtol)</code></pre><p>Check for observability of the pair <code>(A, C)</code> or <code>sys</code> using the PHB test.</p><p>The return value contains the field <code>isobservable</code> which is <code>true</code> if the rank condition is met at all eigenvalues of <code>A</code>, and <code>false</code> otherwise. The returned structure also contains the rank and smallest singular value at each individual eigenvalue of <code>A</code> in the fields <code>ranks</code> and <code>sigma_min</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L197-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}" href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystemsBase.observer_controller</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">cont = observer_controller(sys, L::AbstractMatrix, K::AbstractMatrix; direct=false)</code></pre><p><strong>If <code>direct = false</code></strong></p><p>Return the observer_controller <code>cont</code> that is given by <code>ss(A - B*L - K*C + K*D*L, K, L, 0)</code> such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-KC</code> and <code>A-BL</code>.</p><p>This controller does not have a direct term, and corresponds to state feedback operating on state estimated by <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a>. Use this form if the computed control signal is applied at the next sampling instant, or with an otherwise large delay in relation to the measurement fed into the controller.</p><p>Ref: &quot;Computer-Controlled Systems&quot; Eq 4.37</p><p><strong>If <code>direct = true</code></strong></p><p>Return the observer controller <code>cont</code> that is given by <code>ss((I-KC)(A-BL), (I-KC)(A-BL)K, L, LK)</code> such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-BL</code> and <code>A-BL-KC</code>. This controller has a direct term, and corresponds to state feedback operating on state estimated by <a href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>observer_filter</code></a>. Use this form if the computed control signal is applied immediately after receiveing a measurement. This version typically has better performance than the one without a direct term.</p><div class="admonition is-info" id="Note-b8d5bd6bf6fb74ef"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b8d5bd6bf6fb74ef" title="Permalink"></a></header><div class="admonition-body"><p>To use this formulation, the observer gain <code>K</code> should have been designed for the pair <code>(A, CA)</code> rather than <code>(A, C)</code>. To do this, pass <code>direct = true</code> when calling <a href="../synthesis/#ControlSystemsBase.place"><code>place</code></a> or <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p></div></div><p>Ref: Ref: &quot;Computer-Controlled Systems&quot; pp 140 and &quot;Computer-Controlled Systems&quot; pp 162 prob 4.7</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: Model of system</li><li><code>L</code>: State-feedback gain <code>u = -Lx</code></li><li><code>K</code>: Observer gain</li></ul><p>See also <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a> and <a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>innovation_form</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L876-L906">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}" href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>ControlSystemsBase.observer_filter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">observer_filter(sys, K; output_state = false)</code></pre><p>Return the observer filter </p><p class="math-container">\[\begin{aligned}
x̂(k|k) &amp;= (I - KC)Ax̂(k-1|k-1) + (I - KC)Bu(k-1) + Ky(k) \\
\end{aligned}\]</p><p>with the input equation <code>[(I - KC)B K] * [u(k-1); y(k)]</code>.</p><p>Note the time indices in the equations, the filter assumes that the user passes the <em>current</em> <span>$y(k)$</span>, but the <em>past</em> <span>$u(k-1)$</span>, that is, this filter is used to estimate the state <em>before</em> the current control input has been applied. This causes a state-feedback controller acting on the estimate produced by this observer to have a direct term.</p><p>This is similar to <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a>, but in contrast to the predictor, the filter output depends on the current measurement, whereas the predictor output only depend on past measurements.</p><p>The observer filter is equivalent to the <a href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>observer_predictor</code></a> for continuous-time systems.</p><div class="admonition is-info" id="Note-b8d5bd6bf6fb74ef"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b8d5bd6bf6fb74ef" title="Permalink"></a></header><div class="admonition-body"><p>To use this formulation, the observer gain <code>K</code> should have been designed for the pair <code>(A, CA)</code> rather than <code>(A, C)</code>. To do this, pass <code>direct = true</code> when calling <a href="../synthesis/#ControlSystemsBase.place"><code>place</code></a> or <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p></div></div><p>Ref: &quot;Computer-Controlled Systems&quot; Eq 4.32</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L920-L941">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}" href="#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}"><code>ControlSystemsBase.observer_predictor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">observer_predictor(sys::AbstractStateSpace, K; h::Int = 1, output_state = false)
observer_predictor(sys::AbstractStateSpace, R1, R2[, R12]; output_state = false)</code></pre><p>If <code>sys</code> is continuous, return the observer predictor system</p><p class="math-container">\[\begin{aligned}
x̂&#39; &amp;= (A - KC)x̂ + (B-KD)u + Ky \\
ŷ  &amp;= Cx + Du
\end{aligned}\]</p><p>with the input equation <code>[B-KD K] * [u; y]</code></p><p>If <code>sys</code> is discrete, the prediction horizon <code>h</code> may be specified, in which case measurements up to and including time <code>t-h</code> and inputs up to and including time <code>t</code> are used to predict <code>y(t)</code>.</p><p>If covariance matrices <code>R1, R2</code> are given, the kalman gain <code>K</code> is calculated using <a href="../synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>kalman</code></a>.</p><p>If <code>output_state</code> is true, the output is the state estimate <code>x̂</code> instead of the output estimate <code>ŷ</code>.</p><p>See also <a href="#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST&lt;:AbstractStateSpace"><code>innovation_form</code></a>, <a href="#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a> and <a href="#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>observer_filter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L825-L845">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.obsv" href="#ControlSystemsBase.obsv"><code>ControlSystemsBase.obsv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">obsv(A, C, n=size(A,1))
obsv(sys, n=sys.nx)</code></pre><p>Compute the observability matrix with <code>n</code> rows for the system described by <code>(A, C)</code> or <code>sys</code>. Providing the optional <code>n &gt; sys.nx</code> returns an extended observability matrix.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite or to call the function <a href="#ControlSystemsBase.observability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>observability</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L118-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.plyap-Tuple{AbstractStateSpace, Vararg{Any}}" href="#ControlSystemsBase.plyap-Tuple{AbstractStateSpace, Vararg{Any}}"><code>ControlSystemsBase.plyap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Xc = plyap(sys::AbstractStateSpace, Ql; kwargs...)</code></pre><p>Lyapunov solver that takes the <code>L</code> Cholesky factor of <code>Q</code> and returns a triangular matrix <code>Xc</code> such that <code>Xc*Xc&#39; = X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystemsBase.similarity_transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syst = similarity_transform(sys, T; unitary=false)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on <code>sys</code> such that</p><pre><code class="nohighlight hljs">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre><p>If <code>unitary=true</code>, <code>T</code> is assumed unitary and the matrix adjoint is used instead of the inverse. See also <a href="#ControlSystemsBase.balance_statespace"><code>balance_statespace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L695-L707">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.stab_unstab-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.stab_unstab-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.stab_unstab</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">stab, unstab, sep = stab_unstab(sys; kwargs...)</code></pre><p>Decompose <code>sys</code> into <code>sys = stab + unstab</code> where <code>stab</code> contains all stable poles and <code>unstab</code> contains unstable poles. </p><p><code>0 ≤ sep ≤ 1</code> is the estimated separation between the stable and unstable spectra.</p><p>The docstring of <code>MatrixPencils.ssblkdiag</code>, reproduced below, provides more information on the keyword arguments: Base.Docs.DocStr(svec(&quot;    ssblkdiag(A, B, C; smarg, disc = false, stable<em>unstable = false, withQ = true, withZ = true) -&gt; (At, Bt, Ct, Q, Z, blkdims, sep)\n\nReduce the regular matrix pencil <code>A - λI</code> to an equivalent block diagonal triangular form <code>At - λI = Q*(A - λI)*Z</code> \nusing the transformation matrices <code>Q</code> and <code>Z</code>, where <code>Q = inv(Z)</code>, such that the transformed matrix <code>At</code> have \nseparated stable and unstable eigenvalues with respect to a stability domain <code>Cs</code> defined by the \nstability margin parameter <code>smarg</code> and the stability type parameter <code>disc</code>. \nIf <code>disc = false</code>, <code>Cs</code> is the set of complex numbers with real parts less than <code>smarg</code>, \nwhile if <code>disc = true</code>, <code>Cs</code> is the set of complex numbers with moduli less than <code>smarg</code> (i.e., the interior of a disc \nof radius <code>smarg</code> centered in the origin). If <code>smarg = missing</code>, the default value used is <code>smarg = 0</code>, if  <code>disc = false</code>,\nand <code>smarg = 1</code>, if <code>disc = true</code>.\nThe matrix <code>At</code> results in the following block diagonal form\n \n        At = | A1  0  |\n             | 0   A2 |\n \nwhere the <code>n1 x n1</code> matrix <code>A1</code> and the <code>n2 x n2</code> matrix <code>A2</code> are in Schur form. \nThe matrix <code>A1</code> has unstable eigenvalues and <code>A2</code> has stable eigenvalues if `stable</em>unstable = false<code>,\nwhile</code>A1<code>has stable eigenvalues and</code>A2<code>has unstable eigenvalues if</code>stable_unstable = true<code>.\nThe dimensions of the diagonal blocks are returned in</code>blkdims = (n1, n2)<code>.   \nIf</code>withQ = true<code>,</code>Q<code>contains the left transformation matrix. If</code>withQ = false<code>,</code>Q<code>is set to</code>nothing<code>.   \nIf</code>withZ = true<code>,</code>Z<code>contains the right transformation matrix. If</code>withZ = false<code>,</code>Z<code>is set to</code>nothing<code>.   \n</code>Bt = Q<em>B<code>, unless</code>B = missing<code>, in which case</code>Bt = missing<code>is returned, and</code>Ct = C</em>Z<code>, \nunless</code>C = missing<code>, in which case</code>Ct = missing<code>is returned .              \nAn estimation of the separation of the spectra of the two underlying diagonal blocks is returned in</code>sep<code>, \nwhere</code>0 ≤ sep ≤ 1<code>. A value</code>sep ≈ 0<code>indicates that</code>A1<code>and</code>A2` have some almost equal eigenvalues. \n&quot;), nothing, Dict{Symbol, Any}(:typesig =&gt; Union{Tuple{T}, Tuple{AbstractMatrix{T}, Union{Missing, AbstractMatrix{T}}, Union{Missing, AbstractMatrix{T}}}} where T&lt;:Union{Float32, Float64, ComplexF64, ComplexF32}, :module =&gt; MatrixPencils, :linenumber =&gt; 657, :binding =&gt; MatrixPencils.ssblkdiag, :path =&gt; &quot;/home/runner/.julia/packages/MatrixPencils/QkyRw/src/gsep.jl&quot;))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L674-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}" href="#ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}"><code>ControlSystemsBase.time_scale</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">time_scale(sys::AbstractStateSpace{Continuous}, a; balanced = false)
time_scale(G::TransferFunction{Continuous},     a; balanced = true)</code></pre><p>Rescale the time axis (change time unit) of <code>sys</code>.</p><p>For systems where the dominant time constants are very far from 1, e.g., in electronics, rescaling the time axis may be beneficial for numerical performance, in particular for continuous-time simulations.</p><p>Scaling of time for a function <span>$f(t)$</span> with Laplace transform <span>$F(s)$</span> can be stated as</p><p class="math-container">\[f(at) \leftrightarrow \dfrac{1}{a} F\big(\dfrac{s}{a}\big)\]</p><p>The keyword argument <code>balanced</code> indicates whether or not to apply a balanced scaling on the <code>B</code> and <code>C</code> matrices. For statespace systems, this defaults to false since it changes the state representation, only <code>B</code> will be scaled. For transfer functions, it defaults to true.</p><p><strong>Example:</strong></p><p>The following example show how a system with a time constant on the order of one micro-second is rescaled such that the time constant becomes 1, i.e., the time unit is changed from seconds to micro-seconds. </p><pre><code class="language-julia hljs">Gs  = tf(1, [1e-6, 1])     # micro-second time scale modeled in seconds
Gms = time_scale(Gs, 1e-6) # Change to micro-second time scale
Gms == tf(1, [1, 1])       # Gms now has micro-seconds as time unit</code></pre><p>The next example illustrates how the time axis of a time-domain simulation changes by time scaling </p><pre><code class="language-julia hljs">t = 0:0.1:50 # original time axis
a = 10       # Scaling factor
sys1 = ssrand(1,1,5)
res1 = step(sys1, t)      # Perform original simulation
sys2 = time_scale(sys, a) # Scale time
res2 = step(sys2, t ./ a) # Simulate on scaled time axis, note the `1/a`
isapprox(res1.y, res2.y, rtol=1e-3, atol=1e-3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L722-L757">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}" href="#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}"><code>LinearAlgebra.lyap</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lyap(A, Q; kwargs...)</code></pre><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p><p>Uses <code>MatrixEquations.lyapc / MatrixEquations.lyapd</code>. For keyword arguments, see the docstring of <code>ControlSystemsBase.MatrixEquations.lyapc / ControlSystemsBase.MatrixEquations.lyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(sys, p=2; tol=1e-6)</code></pre><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the H∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the L∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>hinfnorm</code> instead. See <a href="#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a> for further documentation.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a <code>StateSpace</code> model if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/matrix_comps.jl#L268-L283">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.balance_statespace" href="#ControlSystemsBase.balance_statespace"><code>ControlSystemsBase.balance_statespace</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A, B, C, T = balance_statespace{S}(A::Matrix{S}, B::Matrix{S}, C::Matrix{S}, perm::Bool=false)
sys, T = balance_statespace(sys::StateSpace, perm::Bool=false)</code></pre><p>Computes a balancing transformation <code>T</code> that attempts to scale the system so that the row and column norms of [T<em>A/T T</em>B; C/T 0] are approximately equal. If <code>perm=true</code>, the states in <code>A</code> are allowed to be reordered.</p><p>The inverse of <code>sysb, T = balance_statespace(sys)</code> is given by <code>similarity_transform(sysb, T)</code></p><p>This is not the same as finding a balanced realization with equal and diagonal observability and reachability gramians, see <a href="#ControlSystemsBase.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>balreal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/552af58ad7c00696db2cbb83bb7cf7e610a17b9b/lib/ControlSystemsBase/src/types/conversion.jl#L150-L161">source</a></section></article><h2 id="Videos"><a class="docs-heading-anchor" href="#Videos">Videos</a><a id="Videos-1"></a><a class="docs-heading-anchor-permalink" href="#Videos" title="Permalink"></a></h2><p>Basic usage of robustness analysis with JuliaControl</p><iframe style="height: 315px; width: 560px" src="https://www.youtube.com/embed/zTW4mlWNumo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../constructors/">« Constructors</a><a class="docs-footer-nextpage" href="../synthesis/">Synthesis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Friday 9 May 2025 13:21">Friday 9 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
