<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Time and Frequency response · ControlSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li class="is-active"><a class="tocitem" href>Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Time and Frequency response</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Time and Frequency response</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/timefreqresponse.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystems.Simulator"><code>ControlSystems.Simulator</code></a></li><li><a href="#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F"><code>ControlSystems.Simulator</code></a></li><li><a href="#ControlSystems.TransferFunction-Tuple{Any}"><code>ControlSystems.TransferFunction</code></a></li><li><a href="#Base.step-Tuple{AbstractStateSpace, AbstractVector}"><code>Base.step</code></a></li><li><a href="#CommonSolve.solve"><code>CommonSolve.solve</code></a></li><li><a href="#ControlSystems.bode-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bode</code></a></li><li><a href="#ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}"><code>ControlSystems.evalfr</code></a></li><li><a href="#ControlSystems.freqresp-Union{Tuple{W}, Tuple{LTISystem, AbstractVector{W}}} where W&lt;:Real"><code>ControlSystems.freqresp</code></a></li><li><a href="#ControlSystems.freqresp!-Union{Tuple{T}, Tuple{Array{T, 3}, LTISystem, AbstractVector{&lt;:Real}}} where T"><code>ControlSystems.freqresp!</code></a></li><li><a href="#ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}"><code>ControlSystems.impulse</code></a></li><li><a href="#ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>ControlSystems.lsim</code></a></li><li><a href="#ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquist</code></a></li><li><a href="#ControlSystems.sigma-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigma</code></a></li></ul><h1 id="Time-and-Frequency-response"><a class="docs-heading-anchor" href="#Time-and-Frequency-response">Time and Frequency response</a><a id="Time-and-Frequency-response-1"></a><a class="docs-heading-anchor-permalink" href="#Time-and-Frequency-response" title="Permalink"></a></h1><p>Any <code>TransferFunction</code> can be evaluated at a point using <code>F(s)</code>, <code>F(omega, true)</code>, <code>F(z, false)</code></p><ul><li><code>F(s)</code> evaluates the continuous-time transfer function <code>F</code> at <code>s</code>.</li><li><code>F(omega,true)</code> evaluates the discrete-time transfer function <code>F</code> at <code>exp(i*Ts*omega)</code></li><li><code>F(z,false)</code> evaluates the discrete-time transfer function <code>F</code> at <code>z</code></li></ul><article class="docstring"><header><a class="docstring-binding" id="Base.step-Tuple{AbstractStateSpace, AbstractVector}" href="#Base.step-Tuple{AbstractStateSpace, AbstractVector}"><code>Base.step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y, t, x = step(sys[, tfinal])
y, t, x = step(sys[, t])</code></pre><p>Calculate the step response of system <code>sys</code>. If the final time <code>tfinal</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations. The return value is a structure of type <code>SimResult</code> that can be plotted or destructured as <code>y, t, x = result</code>.</p><p><code>y</code> has size <code>(ny, length(t), nu)</code>, <code>x</code> has size <code>(nx, length(t), nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/timeresp.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}" href="#ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}"><code>ControlSystems.impulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y, t, x = impulse(sys[, tfinal])
y, t, x = impulse(sys[, t])</code></pre><p>Calculate the impulse response of system <code>sys</code>. If the final time <code>tfinal</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations. The return value is a structure of type <code>SimResult</code> that can be plotted or destructured as <code>y, t, x = result</code>.</p><p><code>y</code> has size <code>(ny, length(t), nu)</code>, <code>x</code> has size <code>(nx, length(t), nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/timeresp.jl#L38-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}" href="#ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>ControlSystems.lsim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">result = lsim(sys, u[, t]; x0, method])
result = lsim(sys, u::Function, t; x0, method)</code></pre><p>Calculate the time response of system <code>sys</code> to input <code>u</code>. If <code>x0</code> is ommitted, a zero vector is used.</p><p>The result structure contains the fields <code>y, t, x, u</code> and can be destructured automatically by iteration, e.g.,</p><pre><code class="language-julia hljs">y, t, x, u = result</code></pre><p><code>result::SimResult</code> can also be plotted directly:</p><pre><code class="language-julia hljs">plot(result, plotu=true, plotx=false)</code></pre><p><code>y</code>, <code>x</code>, <code>u</code> have time in the second dimension. Initial state <code>x0</code> defaults to zero.</p><p>Continuous time systems are simulated using an ODE solver if <code>u</code> is a function. If <code>u</code> is an array, the system is discretized (with <code>method=:zoh</code> by default) before simulation. For a lower level inteface, see <code>?Simulator</code> and <code>?solve</code></p><p><code>u</code> can be a function or a matrix/vector of precalculated control signals. If <code>u</code> is a function, then <code>u(x,i)</code> (<code>u(x,t)</code>) is called to calculate the control signal every iteration (time instance used by solver). This can be used to provide a control law such as state feedback <code>u(x,t) = -L*x</code> calculated by <code>lqr</code>. To simulate a unit step, use <code>(x,i)-&gt; 1</code>, for a ramp, use <code>(x,i)-&gt; i*Ts</code>, for a step at <code>t=5</code>, use (x,i)-&gt; (i*Ts &gt;= 5) etc.</p><p>Usage example:</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots

A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/timeresp.jl#L77-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bode-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.bode-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mag, phase, w = bode(sys[, w])</code></pre><p>Compute the magnitude and phase parts of the frequency response of system <code>sys</code> at frequencies <code>w</code>. See also <a href="../plotting/#ControlSystems.bodeplot"><code>bodeplot</code></a></p><p><code>mag</code> and <code>phase</code> has size <code>(length(w), ny, nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L264-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}" href="#ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}"><code>ControlSystems.evalfr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evalfr(sys, x)</code></pre><p>Evaluate the transfer function of the LTI system sys at the complex number s=x (continuous-time) or z=x (discrete-time).</p><p>For many values of <code>x</code>, use <code>freqresp</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqresp!-Union{Tuple{T}, Tuple{Array{T, 3}, LTISystem, AbstractVector{&lt;:Real}}} where T" href="#ControlSystems.freqresp!-Union{Tuple{T}, Tuple{Array{T, 3}, LTISystem, AbstractVector{&lt;:Real}}} where T"><code>ControlSystems.freqresp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freqresp!(R::Array{T, 3}, sys::LTISystem, w_vec::AbstractVector{&lt;:Real})</code></pre><p>In-place version of <a href="#ControlSystems.freqresp-Union{Tuple{W}, Tuple{LTISystem, AbstractVector{W}}} where W&lt;:Real"><code>freqresp</code></a> that takes a pre-allocated array <code>R</code> of size (ny, nu, nw)`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqresp-Union{Tuple{W}, Tuple{LTISystem, AbstractVector{W}}} where W&lt;:Real" href="#ControlSystems.freqresp-Union{Tuple{W}, Tuple{LTISystem, AbstractVector{W}}} where W&lt;:Real"><code>ControlSystems.freqresp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sys_fr = freqresp(sys, w)</code></pre><p>Evaluate the frequency response of a linear system</p><p><code>w -&gt; C*((iw*im*I - A)^-1)*B + D</code></p><p>of system <code>sys</code> over the frequency vector <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">re, im, w = nyquist(sys[, w])</code></pre><p>Compute the real and imaginary parts of the frequency response of system <code>sys</code> at frequencies <code>w</code>. See also <a href="../plotting/#ControlSystems.nyquistplot"><code>nyquistplot</code></a></p><p><code>re</code> and <code>im</code> has size <code>(length(w), ny, nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L277-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigma-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.sigma-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sv, w = sigma(sys[, w])</code></pre><p>Compute the singular values <code>sv</code> of the frequency response of system <code>sys</code> at frequencies <code>w</code>. See also <a href="../plotting/#ControlSystems.sigmaplot"><code>sigmaplot</code></a></p><p><code>sv</code> has size <code>(length(w), max(ny, nu))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L290-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.TransferFunction-Tuple{Any}" href="#ControlSystems.TransferFunction-Tuple{Any}"><code>ControlSystems.TransferFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>F(s)</code>, <code>F(omega, true)</code>, <code>F(z, false)</code></p><p>Notation for frequency response evaluation.</p><ul><li>F(s) evaluates the continuous-time transfer function F at s.</li><li>F(omega,true) evaluates the discrete-time transfer function F at exp(im<em>Ts</em>omega)</li><li>F(z,false) evaluates the discrete-time transfer function F at z</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/freqresp.jl#L235-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sol = solve(s::AbstractSimulator, x0, tspan,  args...; kwargs...)</code></pre><p>Simulate the system represented by <code>s</code> from initial state <code>x0</code> over time span <code>tspan = (t0,tf)</code>. <code>args</code> and <code>kwargs</code> are sent to the <code>solve</code> function from <code>OrdinaryDiffEq</code>, e.g., <code>solve(s, x0, tspan,  Tsit5(), reltol=1e-5)</code> solves the problem with solver <a href="http://docs.juliadiffeq.org/stable/solvers/ode_solve.html"><code>Tsit5()</code></a> and relative tolerance 1e-5.</p><p>See also <code>Simulator</code> <code>lsim</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/simulators.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.Simulator" href="#ControlSystems.Simulator"><code>ControlSystems.Simulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulator</code></pre><p><strong>Fields:</strong></p><pre><code class="nohighlight hljs">P::StateSpace
f = (x,p,t) -&gt; x
y = (x,t)   -&gt; y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/simulators.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F" href="#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F"><code>ControlSystems.Simulator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulator(P::StateSpace, u = (x,t) -&gt; 0)</code></pre><p>Used to simulate continuous-time systems. See function <code>?solve</code> for additional info.</p><p><strong>Usage:</strong></p><pre><code class="nohighlight hljs">using OrdinaryDiffEq, Plots
dt             = 0.1
tfinal         = 20
t              = 0:dt:tfinal
P              = ss(tf(1,[2,1])^2)
K              = 5
reference(x,t) = [1.]
s              = Simulator(P, reference)
x0             = [0.,0]
tspan          = (0.0,tfinal)
sol            = solve(s, x0, tspan, Tsit5())
plot(t, s.y(sol, t)[:], lab=&quot;Open loop step response&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/d3d051d0f3b53974ae8db1965da97b7f709d312d/src/simulators.jl#L19-L38">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../synthesis/">« Synthesis</a><a class="docs-footer-nextpage" href="../plotting/">Plotting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.14 on <span class="colophon-date" title="Friday 11 March 2022 12:17">Friday 11 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
