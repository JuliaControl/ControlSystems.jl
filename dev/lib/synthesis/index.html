<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis · ControlSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">ControlSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li class="is-active"><a class="tocitem" href>Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Synthesis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Synthesis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/synthesis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystems.LQG"><code>ControlSystems.LQG</code></a></li><li><a href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace,N} where N}"><code>ControlSystems.append</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.bodev</code></a></li><li><a href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a></li><li><a href="#ControlSystems.c2d_poly2poly-Tuple{Any,Any}"><code>ControlSystems.c2d_poly2poly</code></a></li><li><a href="#ControlSystems.c2d_roots2poly-Tuple{Any,Any}"><code>ControlSystems.c2d_roots2poly</code></a></li><li><a href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a></li><li><a href="#ControlSystems.dab-Tuple{Any,Any,Any}"><code>ControlSystems.dab</code></a></li><li><a href="#ControlSystems.dkalman-NTuple{4,Any}"><code>ControlSystems.dkalman</code></a></li><li><a href="#ControlSystems.dlqr-NTuple{4,Any}"><code>ControlSystems.dlqr</code></a></li><li><a href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback-Tuple{AbstractStateSpace,AbstractStateSpace}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback-Tuple{Union{DelayLtiSystem, StateSpace}}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback2dof-Tuple{TransferFunction,Any,Any,Any}"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.freqrespv-Tuple{LTISystem,AbstractArray{var&quot;#s167&quot;,1} where var&quot;#s167&quot;&lt;:Real}"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.kalman-NTuple{4,Any}"><code>ControlSystems.kalman</code></a></li><li><a href="#ControlSystems.laglink-Tuple{Any,Any}"><code>ControlSystems.laglink</code></a></li><li><a href="#ControlSystems.leadlink-Tuple{Any,Any,Any}"><code>ControlSystems.leadlink</code></a></li><li><a href="#ControlSystems.leadlinkat-Tuple{Any,Any,Any}"><code>ControlSystems.leadlinkat</code></a></li><li><a href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a></li><li><a href="#ControlSystems.lft"><code>ControlSystems.lft</code></a></li><li><a href="#ControlSystems.loopshapingPI-Tuple{Any,Any}"><code>ControlSystems.loopshapingPI</code></a></li><li><a href="#ControlSystems.lqr-NTuple{4,Any}"><code>ControlSystems.lqr</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.parallel-Tuple{LTISystem,LTISystem}"><code>ControlSystems.parallel</code></a></li><li><a href="#ControlSystems.pid-Tuple{}"><code>ControlSystems.pid</code></a></li><li><a href="#ControlSystems.pidplots-Tuple{LTISystem,Vararg{Any,N} where N}"><code>ControlSystems.pidplots</code></a></li><li><a href="#ControlSystems.place-Tuple{Any,Any,Any}"><code>ControlSystems.place</code></a></li><li><a href="#ControlSystems.rlocus"><code>ControlSystems.rlocus</code></a></li><li><a href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a></li><li><a href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a></li><li><a href="#ControlSystems.series-Tuple{LTISystem,LTISystem}"><code>ControlSystems.series</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.sminreal-Tuple{StateSpace}"><code>ControlSystems.sminreal</code></a></li><li><a href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a></li><li><a href="#ControlSystems.starprod-Tuple{Any,Any,Int64,Int64}"><code>ControlSystems.starprod</code></a></li><li><a href="#ControlSystems.zpconv-NTuple{4,Any}"><code>ControlSystems.zpconv</code></a></li></ul><h1 id="Synthesis"><a class="docs-heading-anchor" href="#Synthesis">Synthesis</a><a id="Synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dkalman-NTuple{4,Any}" href="#ControlSystems.dkalman-NTuple{4,Any}"><code>ControlSystems.dkalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dkalman(A, C, R1, R2)
dkalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain for discrete time systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/synthesis.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dlqr-NTuple{4,Any}" href="#ControlSystems.dlqr-NTuple{4,Any}"><code>ControlSystems.dlqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dlqr(A, B, Q, R)
dlqr(sys, Q, R)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u[k] = -K*x[k]</code> that minimizes the cost function:</p><p>J = sum(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the discrte time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>See also <code>lqg</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
h = 0.1
A = [1 h; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0, h)
Q = I
R = I
L = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:h:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x, lab=[&quot;Position&quot;  &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/synthesis.jl#L69-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.kalman-NTuple{4,Any}" href="#ControlSystems.kalman-NTuple{4,Any}"><code>ControlSystems.kalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kalman(A, C, R1, R2)
kalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain</p><p>See also <code>LQG</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/synthesis.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lqr-NTuple{4,Any}" href="#ControlSystems.lqr-NTuple{4,Any}"><code>ControlSystems.lqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lqr(A, B, Q, R)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = -K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the continuous time model <code>dx = Ax + Bu</code>.</p><p><code>lqr(sys, Q, R)</code></p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>See also <code>LQG</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/synthesis.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.place-Tuple{Any,Any,Any}" href="#ControlSystems.place-Tuple{Any,Any,Any}"><code>ControlSystems.place</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">place(A, B, p)
place(sys::StateSpace, p)</code></pre><p>Calculate gain matrix <code>K</code> such that the poles of <code>(A-BK)</code> in are in <code>p</code>.</p><p>Uses Ackermann&#39;s formula.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/synthesis.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d" href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sysd, x0map = c2d(sys::StateSpace, Ts, method=:zoh)
sysd = c2d(sys::TransferFunction, Ts, method=:zoh)</code></pre><p>Convert the continuous system <code>sys</code> into a discrete system with sample time <code>Ts</code>, using the provided method. Currently only <code>:zoh</code>, <code>:foh</code> and <code>:fwdeuler</code> are provided. Note that the forward-Euler method generally requires the sample time to be very small in relation to the time-constants of the system.</p><p>Returns the discrete system <code>sysd</code>, and for StateSpace systems a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_poly2poly-Tuple{Any,Any}" href="#ControlSystems.c2d_poly2poly-Tuple{Any,Any}"><code>ControlSystems.c2d_poly2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">c2d_poly2poly(ro,h)</code></pre><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_roots2poly-Tuple{Any,Any}" href="#ControlSystems.c2d_roots2poly-Tuple{Any,Any}"><code>ControlSystems.c2d_roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">c2d_roots2poly(ro,h)</code></pre><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L199-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.d2c" href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">d2c(sys::AbstractStateSpace{&lt;:Discrete}, method::Symbol = :zoh)</code></pre><p>Convert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using <code>method</code>. Available methods are `:zoh, :fwdeuler´.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dab-Tuple{Any,Any,Any}" href="#ControlSystems.dab-Tuple{Any,Any,Any}"><code>ControlSystems.dab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">X,Y = dab(A,B,C)</code></pre><p>DAB   Solves the Diophantine-Aryabhatta-Bezout identity</p><p>AX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstc-Tuple" href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See ?rstd for the discerte case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L100-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstd-Tuple" href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)
R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)
R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></pre><p>rstd  Polynomial synthesis in discrete time.</p><p>Polynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)</p><p>Inputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]</p><p>Outputs: R,S,T  : Polynomials in controller</p><p>See function <code>dab</code> how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L105-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpconv-NTuple{4,Any}" href="#ControlSystems.zpconv-NTuple{4,Any}"><code>ControlSystems.zpconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zpc(a,r,b,s)</code></pre><p>form conv(a,r) + conv(b,s) where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/discrete.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.LQG" href="#ControlSystems.LQG"><code>ControlSystems.LQG</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">G = LQG(A,B,C,D, Q1, Q2, R1, R2; qQ=0, qR=0, integrator=false)
G = LQG(sys, args...; kwargs...)</code></pre><p>Return an LQG object that describes the closed control loop around the process <code>sys=ss(A,B,C,D)</code> where the controller is of LQG-type. The controller is specified by weight matrices <code>Q1,Q2</code> that penalizes state deviations and control signal variance respectively, and covariance matrices <code>R1,R2</code> which specify state drift and measurement covariance respectively. This constructor calls <a href="#ControlSystems.lqr-NTuple{4,Any}"><code>lqr</code></a> and <a href="#ControlSystems.kalman-NTuple{4,Any}"><code>kalman</code></a> and forms the closed-loop system.</p><p>If <code>integrator=true</code>, the resulting controller will have intregral action. This is achieved by adding a model of a constant disturbance on the inputs to the system described by <code>A,B,C,D</code>.</p><p><code>qQ</code> and <code>qR</code> can be set to incorporate loop transfer recovery, i.e.,</p><pre><code class="language-julia">L = lqr(A, B, Q1+qQ*C&#39;C, Q2)
K = kalman(A, C, R1+qR*B*B&#39;, R2)</code></pre><p><strong>Fields</strong></p><p>When the LQG-object is populated by the lqg-function, the following fields have been made available</p><ul><li><code>L</code> is the feedback matrix, such that <code>A-BL</code> is stable. Note that the length of the state vector (and the width of L) is increased by the number of inputs if the option <code>integrator=true</code>.</li><li><code>K</code> is the kalman gain such that <code>A-KC</code> is stable</li><li><code>sysc</code> is a dynamical system describing the controller <code>u=L*inv(A-BL-KC+KDL)Ky</code></li></ul><p><strong>Functions</strong></p><p>Several other properties of the object are accessible with the indexing function <code>getindex()</code> and are called with the syntax <code>G[:function]</code>. The available functions are (some have many alternative names, separated with / )</p><p>-<code>G[:cl] / G[:closedloop]</code> is the closed-loop system, including observer, from reference to output, precompensated to have static gain 1 (<code>u = −Lx + lᵣr</code>). -<code>G[:S] / G[:Sin]</code> Input sensitivity function -<code>G[:T] / G[:Tin]</code> Input complementary sensitivity function -<code>G[:Sout]</code> Output sensitivity function -<code>G[:Tout]</code> Output complementary sensitivity function -<code>G[:CS]</code> The transfer function from measurement noise to control signal -<code>G[:DS]</code> The transfer function from input load disturbance to output -<code>G[:lt] / G[:looptransfer] / G[:loopgain]  =  PC</code> -<code>G[:rd] / G[:returndifference]  =  I + PC</code> -<code>G[:sr] / G[:stabilityrobustness]  =  I + inv(PC)</code> -<code>G[:sysc] / G[:controller]</code> Returns the controller as a StateSpace-system</p><p>It is also possible to access all fileds using the <code>G[:symbol]</code> syntax, the fields are <code>P ,Q1,Q2,R1,R2,qQ,qR,sysc,L,K,integrator</code></p><p><strong>Example</strong></p><pre><code class="language-julia">s = tf(&quot;s&quot;)
P = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]
sys = ss(P)
eye(n) = Matrix{Float64}(I,n,n) # For convinience

qQ = 1
qR = 1
Q1 = 10eye(4)
Q2 = 1eye(2)
R1 = 1eye(6)
R2 = 1eye(2)

G = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR, integrator=true)

Gcl = G[:cl]
T = G[:T]
S = G[:S]
sigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))
stepplot(Gcl)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/types/lqg.jl#L4-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.laglink-Tuple{Any,Any}" href="#ControlSystems.laglink-Tuple{Any,Any}"><code>ControlSystems.laglink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">laglink(a, M; h=0)</code></pre><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlink-Tuple{Any,Any,Any}" href="#ControlSystems.leadlink-Tuple{Any,Any,Any}"><code>ControlSystems.leadlink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">leadlink(b, N, K; h=0)</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L166-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkat-Tuple{Any,Any,Any}" href="#ControlSystems.leadlinkat-Tuple{Any,Any,Any}"><code>ControlSystems.leadlinkat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">leadlinkat(ω, N, K; h=0)</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L186-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkcurve" href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>leadlinkcurve(start=1)</p><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link) If an input argument <code>s</code> is given, the curve is plotted from <code>s</code> to 10, else from 1 to 10.</p><p>See also <code>Leadlink, leadlinkat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L202-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.loopshapingPI-Tuple{Any,Any}" href="#ControlSystems.loopshapingPI-Tuple{Any,Any}"><code>ControlSystems.loopshapingPI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kp,ki,C = loopshapingPI(P,ωp; ϕl,rl, phasemargin, doplot = false)</code></pre><p>Selects the parameters of a PI-controller such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>If <code>phasemargin</code> is supplied, <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><p>Set <code>doplot = true</code> to plot the <code>gangoffourplot</code> and <code>nyquistplot</code> of the system.</p><p>See also <code>pidplots</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L255-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pid-Tuple{}" href="#ControlSystems.pid-Tuple{}"><code>ControlSystems.pid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">C = pid(; kp=0, ki=0; kd=0, time=false, series=false)</code></pre><p>Calculates and returns a PID controller on transfer function form.</p><ul><li><code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants</li><li><code>series</code> indicates  whether or not the series form or parallel form (default) is desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pidplots-Tuple{LTISystem,Vararg{Any,N} where N}" href="#ControlSystems.pidplots-Tuple{LTISystem,Vararg{Any,N} where N}"><code>ControlSystems.pidplots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pidplots(P, args...; kps=0, kis=0, kds=0, time=false, series=false, ω=0)</code></pre><p>Plots interesting figures related to closing the loop around process <code>P</code> with a PID controller Send in a bunch of PID-parameters in any of the vectors kp, ki, kd. The vectors must be the same length.</p><p>-<code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants -<code>series</code> indicates  whether or not the series form or parallel form (default) is desired</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps</p><p>One can also supply a frequency vector ω to be used in Bode and Nyquist plots</p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rlocus" href="#ControlSystems.rlocus"><code>ControlSystems.rlocus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rlocusplot(P::LTISystem, K)</code></pre><p>Computes and plots the root locus of the SISO LTISystem P with a negative feedback loop and feedback gains <code>K</code>, if <code>K</code> is not provided, range(1e-6,stop=500,length=10000) is used. If <code>OrdinaryDiffEq.jl</code> is installed and loaded by the user (<code>using OrdinaryDiffEq</code>), <code>rlocusplot</code> will use an adaptive step-size algorithm to select values of <code>K</code>. A scalar <code>Kmax</code> can then be given as second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.stabregionPID" href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fig, kp, ki = stabregionPID(P, [ω]; kd=0, doplot = true)</code></pre><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s</p><p>The curve is found by analyzing P(s)*C(s) = -1 ⟹ |PC| = |P| |C| = 1 arg(P) + arg(C) = -π</p><p>If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions</p><p>See also <code>stabregionPID</code>, <code>loopshapingPI</code>, <code>pidplots</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/pid_design.jl#L218-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sminreal-Tuple{StateSpace}" href="#ControlSystems.sminreal-Tuple{StateSpace}"><code>ControlSystems.sminreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/simplification.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.append-Tuple{Vararg{AbstractStateSpace,N} where N}" href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace,N} where N}"><code>ControlSystems.append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{AbstractStateSpace,AbstractStateSpace}" href="#ControlSystems.feedback-Tuple{AbstractStateSpace,AbstractStateSpace}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feedback(s1::AbstractStateSpace, s2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><code>U1</code>, <code>Y1</code>, <code>U2</code>, <code>Y2</code> contain the indices of the signals that should be connected. <code>W1</code>, <code>Z1</code>, <code>W2</code>, <code>Z2</code> contain the signal indices of <code>s1</code> and <code>s2</code> that should be kept.</p><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder [w1; w2] and [z1; z2] in the resulting statespace model.</p><p>Negative feedback is the default. Specify <code>pos_feedback=true</code> for positive feedback.</p><p>See Zhou etc. for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L215-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{TransferFunction}" href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feedback(L)
feedback(P1,P2)</code></pre><p>Returns <code>L/(1+L)</code> or <code>P1/(1+P1*P2)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L155-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{Union{DelayLtiSystem, StateSpace}}" href="#ControlSystems.feedback-Tuple{Union{DelayLtiSystem, StateSpace}}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feedback(sys)
feedback(sys1,sys2)</code></pre><p>Forms the negative feedback interconnection</p><pre><code class="language-julia">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L187-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback2dof-Tuple{TransferFunction,Any,Any,Any}" href="#ControlSystems.feedback2dof-Tuple{TransferFunction,Any,Any,Any}"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denomenator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L307-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lft" href="#ControlSystems.lft"><code>ControlSystems.lft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lft(G, Δ, type=:l)</code></pre><p>Lower and upper linear fractional transformation between systems <code>G</code> and <code>Δ</code>.</p><p>Specify <code>:l</code> lor lower LFT, and <code>:u</code> for upper LFT.</p><p><code>G</code> must have more inputs and outputs than <code>Δ</code> has outputs and inputs.</p><p>For details, see Chapter 9.1 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L322-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.parallel-Tuple{LTISystem,LTISystem}" href="#ControlSystems.parallel-Tuple{LTISystem,LTISystem}"><code>ControlSystems.parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.series-Tuple{LTISystem,LTISystem}" href="#ControlSystems.series-Tuple{LTISystem,LTISystem}"><code>ControlSystems.series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.starprod-Tuple{Any,Any,Int64,Int64}" href="#ControlSystems.starprod-Tuple{Any,Any,Int64,Int64}"><code>ControlSystems.starprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">starprod(sys1, sys2, dimu, dimy)</code></pre><p>Compute the Redheffer star product.</p><p><code>length(U1) = length(Y2) = dimu</code> and <code>length(Y1) = length(U2) = dimy</code></p><p>For details, see Chapter 9.3 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/connections.jl#L351-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem,AbstractArray{T,1} where T}" href="#ControlSystems.bodev-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem, w::AbstractVector; )</code> </p><p>For use with SISO systems where it acts the same as <code>bode</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem}" href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem; )</code> </p><p>For use with SISO systems where it acts the same as <code>bode</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Tuple{LTISystem,AbstractArray{var&quot;#s167&quot;,1} where var&quot;#s167&quot;&lt;:Real}" href="#ControlSystems.freqrespv-Tuple{LTISystem,AbstractArray{var&quot;#s167&quot;,1} where var&quot;#s167&quot;&lt;:Real}"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(sys::LTISystem, w_vec::AbstractVector{&lt;:Real}; )</code> </p><p>For use with SISO systems where it acts the same as <code>freqresp</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem,AbstractArray{T,1} where T}" href="#ControlSystems.nyquistv-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem, w::AbstractVector; )</code> </p><p>For use with SISO systems where it acts the same as <code>nyquist</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem}" href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem; )</code> </p><p>For use with SISO systems where it acts the same as <code>nyquist</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem,AbstractArray{T,1} where T}" href="#ControlSystems.sigmav-Tuple{LTISystem,AbstractArray{T,1} where T}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem, w::AbstractVector; )</code> </p><p>For use with SISO systems where it acts the same as <code>sigma</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem}" href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem; )</code> </p><p>For use with SISO systems where it acts the same as <code>sigma</code>  but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/90f500d96ea22c84048c962d7a7e07cc17151098/src/utilities.jl#L190-L195">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analysis/">« Analysis</a><a class="docs-footer-nextpage" href="../timefreqresponse/">Time and Frequency response »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 17 January 2021 16:10">Sunday 17 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
