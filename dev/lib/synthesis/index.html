<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis · ControlSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/analysis/">Analysis</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../../examples/automatic_differentiation/">Automatic differentiation</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li class="is-active"><a class="tocitem" href>Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Synthesis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Synthesis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/synthesis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>ControlSystemsBase.G_CS</code></a></li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>ControlSystemsBase.G_PS</code></a></li><li><a href="#ControlSystemsBase.add_input"><code>ControlSystemsBase.add_input</code></a></li><li><a href="#ControlSystemsBase.add_output"><code>ControlSystemsBase.add_output</code></a></li><li><a href="#ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystemsBase.append</code></a></li><li><a href="#ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystemsBase.array2mimo</code></a></li><li><a href="#ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.bodev</code></a></li><li><a href="#ControlSystemsBase.bodev-Tuple{LTISystem}"><code>ControlSystemsBase.bodev</code></a></li><li><a href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a></li><li><a href="#ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_poly2poly</code></a></li><li><a href="#ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_roots2poly</code></a></li><li><a href="#ControlSystemsBase.c2d_x0map"><code>ControlSystemsBase.c2d_x0map</code></a></li><li><a href="#ControlSystemsBase.comp_sensitivity-Tuple"><code>ControlSystemsBase.comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a></li><li><a href="#ControlSystemsBase.dab-Tuple{Any, Any, Any}"><code>ControlSystemsBase.dab</code></a></li><li><a href="#ControlSystemsBase.extended_gangoffour"><code>ControlSystemsBase.extended_gangoffour</code></a></li><li><a href="#ControlSystemsBase.feedback-Tuple{TransferFunction}"><code>ControlSystemsBase.feedback</code></a></li><li><a href="#ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystemsBase.feedback</code></a></li><li><a href="#ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystemsBase.feedback2dof</code></a></li><li><a href="#ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystemsBase.feedback2dof</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#386#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#386#W&quot;}}} where var&quot;#386#W&quot;&lt;:Real"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_sensitivity</code></a></li><li><a href="#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.kalman</code></a></li><li><a href="#ControlSystemsBase.laglink-Tuple{Any, Any}"><code>ControlSystemsBase.laglink</code></a></li><li><a href="#ControlSystemsBase.leadlink"><code>ControlSystemsBase.leadlink</code></a></li><li><a href="#ControlSystemsBase.leadlinkat"><code>ControlSystemsBase.leadlinkat</code></a></li><li><a href="#ControlSystemsBase.leadlinkcurve"><code>ControlSystemsBase.leadlinkcurve</code></a></li><li><a href="#ControlSystemsBase.lft"><code>ControlSystemsBase.lft</code></a></li><li><a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPI</code></a></li><li><a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPID</code></a></li><li><a href="#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.lqr</code></a></li><li><a href="#ControlSystemsBase.nyquistv-Tuple{LTISystem}"><code>ControlSystemsBase.nyquistv</code></a></li><li><a href="#ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.nyquistv</code></a></li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_sensitivity</code></a></li><li><a href="#ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.parallel</code></a></li><li><a href="#ControlSystemsBase.pid"><code>ControlSystemsBase.pid</code></a></li><li><a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystemsBase.pidplots</code></a></li><li><a href="#ControlSystemsBase.place"><code>ControlSystemsBase.place</code></a></li><li><a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>ControlSystemsBase.placePI</code></a></li><li><a href="#ControlSystemsBase.rstc-Tuple"><code>ControlSystemsBase.rstc</code></a></li><li><a href="#ControlSystemsBase.rstd-Tuple"><code>ControlSystemsBase.rstd</code></a></li><li><a href="#ControlSystemsBase.sensitivity-Tuple"><code>ControlSystemsBase.sensitivity</code></a></li><li><a href="#ControlSystemsBase.series-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.series</code></a></li><li><a href="#ControlSystemsBase.sigmav-Tuple{LTISystem}"><code>ControlSystemsBase.sigmav</code></a></li><li><a href="#ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.sigmav</code></a></li><li><a href="#ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.sminreal</code></a></li><li><a href="#ControlSystemsBase.stabregionPID"><code>ControlSystemsBase.stabregionPID</code></a></li><li><a href="#ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystemsBase.starprod</code></a></li><li><a href="#ControlSystemsBase.zpconv-NTuple{4, Any}"><code>ControlSystemsBase.zpconv</code></a></li></ul><h1 id="Synthesis"><a class="docs-heading-anchor" href="#Synthesis">Synthesis</a><a id="Synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis" title="Permalink"></a></h1><p>For <span>$H_\infty$</span> and <span>$H_2$</span> synthesis as well as more advanced LQG design, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#H_\\\\infty-and-H_2-design">RobustAndOptimalControl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.kalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kalman(Continuous, A, C, R1, R2)
kalman(Discrete, A, C, R1, R2)
kalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec/ared</code> for more help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/synthesis.jl#L74-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.lqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lqr(sys, Q, R)
lqr(Continuous, A, B, Q, R, args...; kwargs...)
lqr(Discrete, A, B, Q, R, args...; kwargs...)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = -K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf) for the continuous-time model <code>dx = Ax + Bu</code>. J = sum(x&#39;Qx + u&#39;Ru, 0, inf) for the discrete-time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec / ared</code> for more help.</p><p>To obtain also the solution to the Riccati equation and the eigenvalues of the closed-loop system as well, call <code>ControlSystemsBase.MatrixEquations.arec / ared</code> instead (note the different order of the arguments to these functions).</p><p><strong>Examples</strong></p><p>Continuous time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
A = [0 1; 0 0]
B = [0; 1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R) # lqr(Continuous,A,B,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre><p>Discrete time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
Ts = 0.1
A = [1 Ts; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A, B, C, 0, Ts)
Q = I
R = I
L = lqr(Discrete, A,B,Q,R) # lqr(sys,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:Ts:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot;  &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/synthesis.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.place" href="#ControlSystemsBase.place"><code>ControlSystemsBase.place</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">place(A, B, p, opt=:c)
place(sys::StateSpace, p, opt=:c)</code></pre><p>Calculate the gain matrix <code>K</code> such that <code>A - BK</code> has eigenvalues <code>p</code>.</p><pre><code class="nohighlight hljs">place(A, C, p, opt=:o)
place(sys::StateSpace, p, opt=:o)</code></pre><p>Calculate the observer gain matrix <code>L</code> such that <code>A - LC</code> has eigenvalues <code>p</code>.</p><p>Uses Ackermann&#39;s formula.</p><p><strong>Currently handles only SISO systems</strong>, but a trick is possible to make it work for MIMO systems: The code below introduces a random projection matrix <code>P</code> that projects the input space to one dimension, and then shifts the application of <code>P</code> from <code>B</code> to <code>K</code>. </p><pre><code class="language-julia hljs">nx = 5
nu = 2
A = randn(nx,nx)
B = randn(nx,nu)
P = randn(nu,1)
K = place(A,B*P,zeros(nx))
K2 = P*K
eigvals(A-B*K2)</code></pre><p>Please note that this function can be numerically sensitive, solving the placement problem in extended precision might be beneficial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/synthesis.jl#L96-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.c2d" href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd = c2d(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)
Gd = c2d(G::TransferFunction{&lt;:Continuous}, Ts, method=:zoh)</code></pre><p>Convert the continuous-time system <code>sys</code> into a discrete-time system with sample time <code>Ts</code>, using the specified <code>method</code> (:<code>zoh</code>, <code>:foh</code>, <code>:fwdeuler</code> or <code>:tustin</code>). Note that the forward-Euler method generally requires the sample time to be very small relative to the time constants of the system.</p><p><code>method = :tustin</code> performs a bilinear transform with prewarp frequency <code>w_prewarp</code>.</p><ul><li><code>w_prewarp</code>: Frequency (rad/s) for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul><p>See also <code>c2d_x0map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L5-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}" href="#ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_poly2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_poly2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L251-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}" href="#ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_roots2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L242-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.c2d_x0map" href="#ControlSystemsBase.c2d_x0map"><code>ControlSystemsBase.c2d_x0map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd, x0map = c2d_x0map(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)</code></pre><p>Returns the discretization <code>sysd</code> of the system <code>sys</code> and a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p><p>See <code>c2d</code> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L23-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.d2c" href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d2c(sys::AbstractStateSpace{&lt;:Discrete}, method::Symbol = :zoh; w_prewarp=0)</code></pre><p>Convert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using <code>method</code>. Available methods are `:zoh, :fwdeuler´.</p><ul><li><code>w_prewarp</code>: Frequency for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.dab-Tuple{Any, Any, Any}" href="#ControlSystemsBase.dab-Tuple{Any, Any, Any}"><code>ControlSystemsBase.dab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y = dab(A,B,C)</code></pre><p>Solves the Diophantine-Aryabhatta-Bezout identity</p><p><span>$AX + BY = C$</span>, where <span>$A, B, C, X$</span> and <span>$Y$</span> are polynomials and <span>$deg Y = deg A - 1$</span>.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.rstc-Tuple" href="#ControlSystemsBase.rstc-Tuple"><code>ControlSystemsBase.rstc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <code>?rstd</code> for the discrete case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.rstd-Tuple" href="#ControlSystemsBase.rstd-Tuple"><code>ControlSystemsBase.rstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></pre><p>Polynomial synthesis in discrete time.</p><p>Polynomial synthesis according to CCS ch 10 to design a controller <span>$R(q) u(k) = T(q) r(k) - S(q) y(k)$</span></p><p>Inputs:</p><ul><li><code>BPLUS</code>  : Part of open loop numerator</li><li><code>BMINUS</code> : Part of open loop numerator</li><li><code>A</code>      : Open loop denominator</li><li><code>BM1</code>    : Additional zeros</li><li><code>AM</code>     : Closed loop denominator</li><li><code>AO</code>     : Observer polynomial</li><li><code>AR</code>     : Pre-specified factor of R,</li></ul><p>e.g integral part [1, -1]^k</p><ul><li><code>AS</code>     : Pre-specified factor of S,</li></ul><p>e.g notch filter [1, 0, w^2]</p><p>Outputs: <code>R,S,T</code>  : Polynomials in controller</p><p>See function <code>dab</code> how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L148-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.zpconv-NTuple{4, Any}" href="#ControlSystemsBase.zpconv-NTuple{4, Any}"><code>ControlSystemsBase.zpconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zpc(a,r,b,s)</code></pre><p>form <code>conv(a,r) + conv(b,s)</code> where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/discrete.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.laglink-Tuple{Any, Any}" href="#ControlSystemsBase.laglink-Tuple{Any, Any}"><code>ControlSystemsBase.laglink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laglink(a, M; [Ts])</code></pre><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p><p class="math-container">\[\dfrac{s + a}{s + a/M} = M \dfrac{1 + s/a}{1 + sM/a}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.leadlink" href="#ControlSystemsBase.leadlink"><code>ControlSystemsBase.leadlink</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leadlink(b, N, K=1; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p class="math-container">\[KN \dfrac{s + b}{s + bN} = K \dfrac{1 + s/b}{1 + s/(bN)}\]</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L184-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.leadlinkat" href="#ControlSystemsBase.leadlinkat"><code>ControlSystemsBase.leadlinkat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leadlinkat(ω, N, K=1; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L209-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.leadlinkcurve" href="#ControlSystemsBase.leadlinkcurve"><code>ControlSystemsBase.leadlinkcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leadlinkcurve(start=1)</code></pre><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link) If an input argument <code>start</code> is given, the curve is plotted from <code>start</code> to 10, else from 1 to 10.</p><p>See also <code>leadlink, leadlinkat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L227-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.loopshapingPI-Tuple{Any, Any}" href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C, kp, ki, fig, CF = loopshapingPI(P, ωp; ϕl, rl, phasemargin, form=:standard, doplot=false, Tf, F)</code></pre><p>Selects the parameters of a PI-controller (on parallel form) such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>The parameters can be returned as one of several common representations  chosen by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s) + T_ds)$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))(τ_d s + 1)$</span></li><li><code>:parallel</code> - <span>$K_p + K_i/s + K_d s$</span></li></ul><p>If <code>phasemargin</code> is supplied (in degrees), <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><ul><li><code>Tf</code>: An optional time constant for second-order measurement noise filter on the form <code>tf(1, [Tf^2, 2*Tf/sqrt(2), 1])</code> to make the controller strictly proper.</li><li><code>F</code>: A pre-designed filter to use instead of the default second-order filter that is used if <code>Tf</code> is given.</li><li><code>doplot</code> plot the <code>gangoffourplot</code> and <code>nyquistplot</code> of the system.</li></ul><p>See also <a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a>, <a href="#ControlSystemsBase.stabregionPID"><code>stabregionPID</code></a> and <a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>placePI</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L296-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.loopshapingPID-Tuple{Any, Any}" href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.3, ϕt=75, form=:standard, doplot=false, lb=-10, ub=10, Tf = 1/1000ω, F = nothing)</code></pre><p>Selects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function <span>$L = PC$</span> at the frequency <code>ω</code> is tangent to the circle where the magnitude of <span>$T = PC / (1+PC)$</span> equals <code>Mt</code>. <code>ϕt</code> denotes the positive angle in degrees between the real axis and the tangent point.</p><p>The default values for <code>Mt</code> and <code>ϕt</code> are chosen to give a good design for processes with inertia, and may need tuning for simpler processes.</p><p>The gain of the resulting controller is generally increasing with increasing <code>ω</code> and <code>Mt</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>P</code>: A SISO plant.</li><li><code>ω</code>: The specification frequency.</li><li><code>Mt</code>: The magnitude of the complementary sensitivity function at the specification frequency, <span>$|T(iω)|$</span>.</li><li><code>ϕt</code>: The positive angle in degrees between the real axis and the tangent point.</li><li><code>doplot</code>: If true, gang of four and Nyquist plots will be returned in <code>fig</code>.</li><li><code>lb</code>: log10 of lower bound for <code>kd</code>.</li><li><code>ub</code>: log10 of upper bound for <code>kd</code>.</li><li><code>Tf</code>: Time constant for second-order measurement noise filter on the form <code>tf(1, [Tf^2, 2*Tf/sqrt(2), 1])</code> to make the controller strictly proper. A practical controller typically sets this time constant slower than the default, e.g., <code>Tf = 1/100ω</code> or <code>Tf = 1/10ω</code></li><li><code>F</code>: A pre-designed filter to use instead of the default second-order filter.</li></ul><p>The parameters can be returned as one of several common representations  chosen by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s) + T_ds)$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))(τ_d s + 1)$</span></li><li><code>:parallel</code> - <span>$K_p + K_i/s + K_d s$</span></li></ul><p>See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a>, <a href="#ControlSystemsBase.stabregionPID"><code>stabregionPID</code></a> and <a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>placePI</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">P  = tf(1, [1,0,0]) # A double integrator
Mt = 1.3  # Maximum magnitude of complementary sensitivity
ω  = 1    # Frequency at which the specification holds
C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt = 75, doplot=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L398-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.pid" href="#ControlSystemsBase.pid"><code>ControlSystemsBase.pid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">C = pid(param_p, param_i, [param_d]; form=:standard, state_space=false, [Tf], [Ts])</code></pre><p>Calculates and returns a PID controller. </p><p>The <code>form</code> can be chosen as one of the following</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>If <code>state_space</code> is set to <code>true</code>, either <code>kd</code> has to be zero  or a positive <code>Tf</code> has to be provided for creating a filter on  the input to allow for a state space realization.  The filter used is <code>1 / (1 + s*Tf + (s*Tf)^2/2)</code>, where <code>Tf</code> can typically  be chosen as <code>Ti/N</code> for a PI controller and <code>Td/N</code> for a PID controller, and <code>N</code> is commonly in the range 2 to 20.  The state space will be returned on controllable canonical form.</p><p>For a discrete controller a positive <code>Ts</code> can be supplied. In this case, the continuous-time controller is discretized using the Tustin method.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">C1 = pid(3.3, 1, 2)                             # Kd≠0 works without filter in tf form
C2 = pid(3.3, 1, 2; Tf=0.3, state_space=true)   # In statespace a filter is needed
C3 = pid(2., 3, 0; Ts=0.4, state_space=true)    # Discrete</code></pre><p>The functions <code>pid_tf</code> and <code>pid_ss</code> are also exported. They take the same parameters and is what is actually called in <code>pid</code> based on the <code>state_space</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}" href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystemsBase.pidplots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pidplots(P, args...; params_p, params_i, params_d=0, form=:standard, ω=0, grid=false, kwargs...)</code></pre><p>Plots interesting figures related to closing the loop around process <code>P</code> with a PID controller supplied in <code>params</code> on one of the following forms:</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>The sent in values can be arrays to evaluate multiple different controllers, and if <code>grid=true</code> it will be a grid search  over all possible combinations of the values.</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps and should be supplied as additional arguments to the function.</p><p>One can also supply a frequency vector <code>ω</code> to be used in Bode and Nyquist plots.</p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L98-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T" href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>ControlSystemsBase.placePI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C, kp, ki = placePI(P, ω₀, ζ; form=:standard)</code></pre><p>Selects the parameters of a PI-controller such that the poles of  closed loop between <code>P</code> and <code>C</code> are placed to match the poles of  <code>s^2 + 2ζω₀s + ω₀^2</code>.</p><p>The parameters can be returned as one of several common representations  chose by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s))$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))$</span> (equivalent to above for PI controllers)</li><li><code>:parallel</code> - <span>$K_p + K_i/s$</span></li></ul><p><code>C</code> is the returned transfer function of the controller and <code>params</code>  is a named tuple containing the parameters. The parameters can be accessed as <code>params.Kp</code> or <code>params[&quot;Kp&quot;]</code> from the named tuple, or they can be unpacked using <code>Kp, Ti, Td = values(params)</code>.</p><p>See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L358-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.stabregionPID" href="#ControlSystemsBase.stabregionPID"><code>ControlSystemsBase.stabregionPID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kp, ki, fig = stabregionPID(P, [ω]; kd=0, doplot=false, form=:standard)</code></pre><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The provided derivative gain is expected on parallel form, i.e., the form kp + ki/s + kd s, but the result can be transformed to any form given by the <code>form</code> keyword. The curve is found by analyzing</p><p class="math-container">\[P(s)C(s) = -1 ⟹ \\
|PC| = |P| |C| = 1 \\
arg(P) + arg(C) = -π\]</p><p>If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a>, <a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/pid_design.jl#L248-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.sminreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p><p>Systems with numerical noise in the coefficients, e.g., noise on the order of <code>eps</code> require truncation to zero to be affected by structural simplification, e.g.,</p><pre><code class="language-julia hljs">trunc_zero!(A) = A[abs.(A) .&lt; 10eps(maximum(abs, A))] .= 0
trunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)
sminreal(sys)</code></pre><p>In contrast to <a href="#ControlSystemsBase.minreal"><code>minreal</code></a>, which performs pole-zero cancellation using linear-algebra operations, has an 𝑂(nₓ^3) complexity and is subject to numerical tolerances, <code>sminreal</code> is computationally very cheap and numerically exact (operates on integers). However, the ability of <code>sminreal</code> to reduce the order of the model is much less powerful.</p><p>See also <a href="#ControlSystemsBase.minreal"><code>minreal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/simplification.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.add_input" href="#ControlSystemsBase.add_input"><code>ControlSystemsBase.add_input</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input(sys::AbstractStateSpace, B2::AbstractArray, D2 = 0)</code></pre><p>Add inputs to <code>sys</code> by forming</p><p class="math-container">\[x&#39; = Ax + [B \; B_2]u
y  = Cx + [D \; D_2]u\]</p><p>If <code>B2</code> is an integer it will be interpreted as an index and an input matrix containing a single 1 at the specified index will be used.</p><p>Example: The following example forms an innovation model that takes innovations as inputs</p><pre><code class="language-julia hljs">G   = ssrand(2,2,3, Ts=1)
K   = kalman(G, I(G.nx), I(G.ny))
sys = add_input(G, K)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L141-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.add_output" href="#ControlSystemsBase.add_output"><code>ControlSystemsBase.add_output</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_output(sys::AbstractStateSpace, C2::AbstractArray, D2 = 0)</code></pre><p>Add outputs to <code>sys</code> by forming</p><p class="math-container">\[x&#39; = Ax + Bu
y  = [C; C_2]x + [D; D_2]u\]</p><p>If <code>C2</code> is an integer it will be interpreted as an index and an output matrix containing a single 1 at the specified index will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L173-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}" href="#ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystemsBase.append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}" href="#ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystemsBase.array2mimo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array2mimo(M::AbstractArray{&lt;:LTISystem})</code></pre><p>Take an array of <code>LTISystem</code>s and create a single MIMO system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}" href="#ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystemsBase.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><em>Basic use</em> <code>feedback(sys1, sys2)</code> forms the (negative) feedback interconnection</p><pre><code class="language-julia hljs">           ┌──────────────┐
◄──────────┤     sys1     │◄──── Σ ◄──────
    │      │              │      │
    │      └──────────────┘      -1
    │                            |
    │      ┌──────────────┐      │
    └─────►│     sys2     ├──────┘
           │              │
           └──────────────┘</code></pre><p>If no second system <code>sys2</code> is given, negative identity feedback (<code>sys2 = 1</code>) is assumed.</p><p><em>Advanced use</em> <code>feedback</code> also supports more flexible use according to the figure below</p><pre><code class="language-julia hljs">              ┌──────────────┐
      z1◄─────┤     sys1     │◄──────w1
 ┌─── y1◄─────┤              │◄──────u1 ◄─┐
 │            └──────────────┘            │
 │                                        α
 │            ┌──────────────┐            │
 └──► u2─────►│     sys2     ├───────►y2──┘
      w2─────►│              ├───────►z2
              └──────────────┘</code></pre><p><code>U1</code>, <code>W1</code> specifies the indices of the input signals of <code>sys1</code> corresponding to <code>u1</code> and <code>w1</code> <code>Y1</code>, <code>Z1</code> specifies the indices of the output signals of <code>sys1</code> corresponding to <code>y1</code> and <code>z1</code> <code>U2</code>, <code>W2</code>, <code>Y2</code>, <code>Z2</code> specifies the corresponding signals of <code>sys2</code> </p><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.</p><p>Negative feedback (α = -1) is the default. Specify <code>pos_feedback=true</code> for positive feedback (α = 1).</p><p>See also <code>lft</code>, <code>starprod</code>, <code>sensitivity</code>, <code>input_sensitivity</code>, <code>output_sensitivity</code>, <code>comp_sensitivity</code>, <code>input_comp_sensitivity</code>, <code>output_comp_sensitivity</code>, <code>G_PS</code>, <code>G_CS</code>.</p><p>The manual section <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/#From-block-diagrams-to-code">From block diagrams to code</a> contains higher-level instructions on how to use this function.</p><p>See Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L269-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.feedback-Tuple{TransferFunction}" href="#ControlSystemsBase.feedback-Tuple{TransferFunction}"><code>ControlSystemsBase.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys)
feedback(sys1, sys2)</code></pre><p>For a general LTI-system, <code>feedback</code> forms the negative feedback interconnection</p><pre><code class="language-julia hljs">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L212-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}" href="#ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystemsBase.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denomenator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L423-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE" href="#ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystemsBase.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)</code></pre><p>Return the transfer function <code>P(F+C)/(1+PC)</code> which is the closed-loop system with process <code>P</code>, controller <code>C</code> and feedforward filter <code>F</code> from reference to control signal (by-passing <code>C</code>).</p><pre><code class="nohighlight hljs">         +-------+
         |       |
   +-----&gt;   F   +----+
   |     |       |    |
   |     +-------+    |
   |     +-------+    |    +-------+
r  |  -  |       |    |    |       |    y
+--+-----&gt;   C   +----+----&gt;   P   +---+--&gt;
      |  |       |         |       |   |
      |  +-------+         +-------+   |
      |                                |
      +--------------------------------+</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L437-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.lft" href="#ControlSystemsBase.lft"><code>ControlSystemsBase.lft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lft(G, Δ, type=:l)</code></pre><p>Lower and upper linear fractional transformation between systems <code>G</code> and <code>Δ</code>.</p><p>Specify <code>:l</code> lor lower LFT, and <code>:u</code> for upper LFT.</p><p><code>G</code> must have more inputs and outputs than <code>Δ</code> has outputs and inputs.</p><p>For details, see Chapter 9.1 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L469-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.series-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.series-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}" href="#ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystemsBase.starprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">starprod(sys1, sys2, dimu, dimy)</code></pre><p>Compute the Redheffer star product.</p><p><code>length(U1) = length(Y2) = dimu</code> and <code>length(Y1) = length(U2) = dimy</code></p><p>For details, see Chapter 9.3 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/connections.jl#L497-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.G_CS-Tuple{Any, Any}" href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>ControlSystemsBase.G_CS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_CS(P, C)</code></pre><p>The closed-loop transfer function from (-) measurement noise or (+) reference to control signal. Technically, the transfer function is given by <code>(1 + CP)⁻¹C</code> so <code>SC</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.G_PS-Tuple{Any, Any}" href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>ControlSystemsBase.G_PS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_PS(P, C)</code></pre><p>The closed-loop transfer function from load disturbance to plant output. Technically, the transfer function is given by <code>(1 + PC)⁻¹P</code> so <code>SP</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.comp_sensitivity-Tuple" href="#ControlSystemsBase.comp_sensitivity-Tuple"><code>ControlSystemsBase.comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.extended_gangoffour" href="#ControlSystemsBase.extended_gangoffour"><code>ControlSystemsBase.extended_gangoffour</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extended_gangoffour(P, C, pos=true)</code></pre><p>Returns a single statespace system that maps </p><ul><li><code>w1</code> reference or measurement noise</li><li><code>w2</code> load disturbance</li></ul><p>to</p><ul><li><code>z1</code> control error</li><li><code>z2</code> control input</li></ul><pre><code class="nohighlight hljs">      z1          z2
      ▲  ┌─────┐  ▲      ┌─────┐
      │  │     │  │      │     │
w1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐
    │    │     │      │  │     │ │
    │    └─────┘      │  └─────┘ │
    │                 w2         │
    └────────────────────────────┘</code></pre><p>The returned system has the transfer-function matrix</p><p class="math-container">\[\begin{bmatrix}
I \\ C
\end{bmatrix} (I + PC)^{-1} \begin{bmatrix}
I &amp; P
\end{bmatrix}\]</p><p>or in code</p><pre><code class="language-julia hljs"># For SISO P
S  = G[1, 1]
PS = G[1, 2]
CS = G[2, 1]
T  = G[2, 2]

# For MIMO P
S  = G[1:P.ny,     1:P.nu]
PS = G[1:P.ny,     P.ny+1:end]
CS = G[P.ny+1:end, 1:P.ny]
T  = G[P.ny+1:end, P.ny+1:end] # Input complimentary sensitivity function</code></pre><p>The gang of four can be plotted like so</p><pre><code class="language-julia hljs">Gcl = extended_gangoffour(G, C) # Form closed-loop system
bodeplot(Gcl, lab=[&quot;S&quot; &quot;CS&quot; &quot;PS&quot; &quot;T&quot;], plotphase=false) |&gt; display # Plot gang of four</code></pre><p>Note, the last input of Gcl is the negative of the <code>PS</code> and <code>T</code> transfer functions from <code>gangoffour2</code>. To get a transfer matrix with the same sign as <a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> and <a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a>, call <code>extended_gangoffour(P, C, pos=false)</code>. See <a href="lib/@ref"><code>glover_mcfarlane</code></a> from RobustAndOptimalControl.jl for an extended example. See also <a href="lib/@ref"><code>ncfmargin</code></a> and <a href="lib/@ref"><code>feedback_control</code></a> from RobustAndOptimalControl.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L113-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(P,C)</code></pre><p>Transfer function from load disturbance to control signal.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case controller output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.input_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(P, C)</code></pre><p>Transfer function from load disturbance to total plant input.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(P,C)</code></pre><p>Transfer function from measurement noise / reference to plant output.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case plant output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.output_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(P, C)</code></pre><p>Transfer function from measurement noise / reference to control error.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.sensitivity-Tuple" href="#ControlSystemsBase.sensitivity-Tuple"><code>ControlSystemsBase.sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></p><p>The output <a href="https://en.wikipedia.org/wiki/Sensitivity_(control_systems)">sensitivity function</a> <span>$S_o = (I + PC)^{-1}$</span> is the transfer function from a reference input to control error, while the input sensitivity function <span>$S_i = (I + CP)^{-1}$</span> is the transfer function from a disturbance at the plant input to the total plant input. For SISO systems, input and output sensitivity functions are equal. In general, we want to minimize the sensitivity function to improve robustness and performance, but pracitcal constraints always cause the sensitivity function to tend to 1 for high frequencies. A robust design minimizes the peak of the sensitivity function, <span>$M_S$</span>. The peak magnitude of <span>$S$</span> is the inverse of the distance between the open-loop Nyquist curve and the critical point -1. Upper bounding the sensitivity peak <span>$M_S$</span> gives lower-bounds on phase and gain margins according to</p><p class="math-container">\[ϕ_m ≥ 2\text{sin}^{-1}(\frac{1}{2M_S}), g_m ≥ \frac{M_S}{M_S-1}\]</p><p>Generally, bounding <span>$M_S$</span> is a better objective than looking at gain and phase margins due to the possibility of combined gain and pahse variations, which may lead to poor robustness despite large gain and pahse margins.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/sensitivity_functions.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem, w::AbstractVector; $(Expr(:kw, :unwrap, true)))</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.bodev-Tuple{LTISystem}" href="#ControlSystemsBase.bodev-Tuple{LTISystem}"><code>ControlSystemsBase.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(G::AbstractMatrix, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(G::Number, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#386#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#386#W&quot;}}} where var&quot;#386#W&quot;&lt;:Real" href="#ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#386#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#386#W&quot;}}} where var&quot;#386#W&quot;&lt;:Real"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(sys::LTISystem, w_vec::AbstractVector{W}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.nyquistv-Tuple{LTISystem}" href="#ControlSystemsBase.nyquistv-Tuple{LTISystem}"><code>ControlSystemsBase.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystemsBase.sigmav-Tuple{LTISystem}" href="#ControlSystemsBase.sigmav-Tuple{LTISystem}"><code>ControlSystemsBase.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/a82bf193bfe29f805c6eb8a305b5feaf1d097cd7/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analysis/">« Analysis</a><a class="docs-footer-nextpage" href="../timefreqresponse/">Time and Frequency response »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 26 May 2023 13:31">Friday 26 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
