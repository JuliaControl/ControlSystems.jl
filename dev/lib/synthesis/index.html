<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis · ControlSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li class="is-active"><a class="tocitem" href>Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Synthesis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Synthesis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/synthesis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>ControlSystems.G_CS</code></a></li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>ControlSystems.G_PS</code></a></li><li><a href="#ControlSystems.add_input"><code>ControlSystems.add_input</code></a></li><li><a href="#ControlSystems.add_output"><code>ControlSystems.add_output</code></a></li><li><a href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystems.append</code></a></li><li><a href="#ControlSystems.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystems.array2mimo</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bodev</code></a></li><li><a href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a></li><li><a href="#ControlSystems.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_poly2poly</code></a></li><li><a href="#ControlSystems.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_roots2poly</code></a></li><li><a href="#ControlSystems.c2d_x0map"><code>ControlSystems.c2d_x0map</code></a></li><li><a href="#ControlSystems.comp_sensitivity-Tuple"><code>ControlSystems.comp_sensitivity</code></a></li><li><a href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a></li><li><a href="#ControlSystems.dab-Tuple{Any, Any, Any}"><code>ControlSystems.dab</code></a></li><li><a href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.freqrespv-Union{Tuple{var&quot;#314#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#314#W&quot;}}} where var&quot;#314#W&quot;&lt;:Real"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystems.input_comp_sensitivity</code></a></li><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>ControlSystems.input_sensitivity</code></a></li><li><a href="#ControlSystems.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.kalman</code></a></li><li><a href="#ControlSystems.laglink-Tuple{Any, Any}"><code>ControlSystems.laglink</code></a></li><li><a href="#ControlSystems.leadlink-Tuple{Any, Any, Any}"><code>ControlSystems.leadlink</code></a></li><li><a href="#ControlSystems.leadlinkat-Tuple{Any, Any, Any}"><code>ControlSystems.leadlinkat</code></a></li><li><a href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a></li><li><a href="#ControlSystems.lft"><code>ControlSystems.lft</code></a></li><li><a href="#ControlSystems.loopshapingPI-Tuple{Any, Any}"><code>ControlSystems.loopshapingPI</code></a></li><li><a href="#ControlSystems.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.lqr</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystems.output_comp_sensitivity</code></a></li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>ControlSystems.output_sensitivity</code></a></li><li><a href="#ControlSystems.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystems.parallel</code></a></li><li><a href="#ControlSystems.pid"><code>ControlSystems.pid</code></a></li><li><a href="#ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystems.pidplots</code></a></li><li><a href="#ControlSystems.place"><code>ControlSystems.place</code></a></li><li><a href="#ControlSystems.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystems.SisoRational{T}}, Any, Any}} where T"><code>ControlSystems.placePI</code></a></li><li><a href="#ControlSystems.rlocusplot"><code>ControlSystems.rlocusplot</code></a></li><li><a href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a></li><li><a href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a></li><li><a href="#ControlSystems.sensitivity-Tuple"><code>ControlSystems.sensitivity</code></a></li><li><a href="#ControlSystems.series-Tuple{LTISystem, LTISystem}"><code>ControlSystems.series</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystems.sminreal</code></a></li><li><a href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a></li><li><a href="#ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystems.starprod</code></a></li><li><a href="#ControlSystems.zpconv-NTuple{4, Any}"><code>ControlSystems.zpconv</code></a></li></ul><h1 id="Synthesis"><a class="docs-heading-anchor" href="#Synthesis">Synthesis</a><a id="Synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis" title="Permalink"></a></h1><p>For <span>$H_\infty$</span> and <span>$H_2$</span> synthesis as well as more advanced LQG design, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#H_\\\\infty-and-H_2-design">RobustAndOptimalControl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.kalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kalman(Continuous, A, C, R1, R2)
kalman(Discrete, A, C, R1, R2)
kalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec/ared</code> for more help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/synthesis.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.lqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lqr(sys, Q, R)
lqr(Continuous, A, B, Q, R, args...; kwargs...)
lqr(Discrete, A, B, Q, R, args...; kwargs...)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = -K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf) for the continuous-time model <code>dx = Ax + Bu</code>. J = sum(x&#39;Qx + u&#39;Ru, 0, inf) for the discrete-time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec / ared</code> for more help.</p><p><strong>Examples</strong></p><p>Continuous time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
A = [0 1; 0 0]
B = [0; 1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R) # lqr(Continuous,A,B,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre><p>Discrete time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
Ts = 0.1
A = [1 Ts; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A, B, C, 0, Ts)
Q = I
R = I
L = lqr(Discrete, A,B,Q,R) # lqr(sys,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:Ts:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot;  &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/synthesis.jl#L1-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.place" href="#ControlSystems.place"><code>ControlSystems.place</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">place(A, B, p, opt=:c)
place(sys::StateSpace, p, opt=:c)</code></pre><p>Calculate the gain matrix <code>K</code> such that <code>A - BK</code> has eigenvalues <code>p</code>.</p><pre><code class="nohighlight hljs">place(A, C, p, opt=:o)
place(sys::StateSpace, p, opt=:o)</code></pre><p>Calculate the observer gain matrix <code>L</code> such that <code>A - LC</code> has eigenvalues <code>p</code>.</p><p>Uses Ackermann&#39;s formula. Currently handles only SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/synthesis.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d" href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd = c2d(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)
Gd = c2d(G::TransferFunction{&lt;:Continuous}, Ts, method=:zoh)</code></pre><p>Convert the continuous-time system <code>sys</code> into a discrete-time system with sample time <code>Ts</code>, using the specified <code>method</code> (:<code>zoh</code>, <code>:foh</code>, <code>:fwdeuler</code> or <code>:tustin</code>). Note that the forward-Euler method generally requires the sample time to be very small relative to the time constants of the system.</p><p><code>method = :tustin</code> performs a bilinear transform with prewarp frequency <code>w_prewarp</code>.</p><ul><li><code>w_prewarp</code>: Frequency (rad/s) for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul><p>See also <code>c2d_x0map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_poly2poly-Tuple{Any, Any}" href="#ControlSystems.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_poly2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_poly2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_roots2poly-Tuple{Any, Any}" href="#ControlSystems.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_roots2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L237-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_x0map" href="#ControlSystems.c2d_x0map"><code>ControlSystems.c2d_x0map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd, x0map = c2d_x0map(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)</code></pre><p>Returns the discretization <code>sysd</code> of the system <code>sys</code> and a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p><p>See <code>c2d</code> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.d2c" href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d2c(sys::AbstractStateSpace{&lt;:Discrete}, method::Symbol = :zoh; w_prewarp=0)</code></pre><p>Convert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using <code>method</code>. Available methods are `:zoh, :fwdeuler´.</p><ul><li><code>w_prewarp</code>: Frequency for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dab-Tuple{Any, Any, Any}" href="#ControlSystems.dab-Tuple{Any, Any, Any}"><code>ControlSystems.dab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y = dab(A,B,C)</code></pre><p>Solves the Diophantine-Aryabhatta-Bezout identity</p><p><span>$AX + BY = C$</span>, where <span>$A, B, C, X$</span> and <span>$Y$</span> are polynomials and <span>$deg Y = deg A - 1$</span>.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L175-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstc-Tuple" href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <code>?rstd</code> for the discrete case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L137-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstd-Tuple" href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></pre><p>Polynomial synthesis in discrete time.</p><p>Polynomial synthesis according to CCS ch 10 to design a controller <span>$R(q) u(k) = T(q) r(k) - S(q) y(k)$</span></p><p>Inputs:</p><ul><li><code>BPLUS</code>  : Part of open loop numerator</li><li><code>BMINUS</code> : Part of open loop numerator</li><li><code>A</code>      : Open loop denominator</li><li><code>BM1</code>    : Additional zeros</li><li><code>AM</code>     : Closed loop denominator</li><li><code>AO</code>     : Observer polynomial</li><li><code>AR</code>     : Pre-specified factor of R,</li></ul><p>e.g integral part [1, -1]^k</p><ul><li><code>AS</code>     : Pre-specified factor of S,</li></ul><p>e.g notch filter [1, 0, w^2]</p><p>Outputs: <code>R,S,T</code>  : Polynomials in controller</p><p>See function <code>dab</code> how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L142-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpconv-NTuple{4, Any}" href="#ControlSystems.zpconv-NTuple{4, Any}"><code>ControlSystems.zpconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zpc(a,r,b,s)</code></pre><p>form <code>conv(a,r) + conv(b,s)</code> where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/discrete.jl#L268-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.laglink-Tuple{Any, Any}" href="#ControlSystems.laglink-Tuple{Any, Any}"><code>ControlSystems.laglink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laglink(a, M; [Ts])</code></pre><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L226-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlink-Tuple{Any, Any, Any}" href="#ControlSystems.leadlink-Tuple{Any, Any, Any}"><code>ControlSystems.leadlink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leadlink(b, N, K; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L241-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkat-Tuple{Any, Any, Any}" href="#ControlSystems.leadlinkat-Tuple{Any, Any, Any}"><code>ControlSystems.leadlinkat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leadlinkat(ω, N, K; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L262-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkcurve" href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">leadlinkcurve(start=1)</code></pre><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link) If an input argument <code>s</code> is given, the curve is plotted from <code>s</code> to 10, else from 1 to 10.</p><p>See also <code>leadlink, leadlinkat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L280-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.loopshapingPI-Tuple{Any, Any}" href="#ControlSystems.loopshapingPI-Tuple{Any, Any}"><code>ControlSystems.loopshapingPI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C, kp, ki, fig = loopshapingPI(P, ωp; ϕl, rl, phasemargin, form=:standard, doplot=false)</code></pre><p>Selects the parameters of a PI-controller (on parallel form) such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>The parameters can be returned as one of several common representations  chosen by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>If <code>phasemargin</code> is supplied (in degrees), <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><p>Set <code>doplot = true</code> to plot the <code>gangoffourplot</code> and <code>nyquistplot</code> of the system.</p><p>See also <a href="#ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a>, <a href="#ControlSystems.stabregionPID"><code>stabregionPID</code></a> and <a href="#ControlSystems.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystems.SisoRational{T}}, Any, Any}} where T"><code>placePI</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L347-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pid" href="#ControlSystems.pid"><code>ControlSystems.pid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">C = pid(param_p, param_i, [param_d]; form=:standard, state_space=false, [Tf], [Ts])</code></pre><p>Calculates and returns a PID controller. </p><p>The <code>form</code> can be chosen as one of the following</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>If <code>state_space</code> is set to <code>true</code>, either <code>kd</code> has to be zero  or a positive <code>Tf</code> has to be provided for creating a filter on  the input to allow for a state space realization.  The filter used is <code>1 / (1 + s*Tf + (s*Tf)^2/2)</code>, where <code>Tf</code> can typically  be chosen as <code>Ti/N</code> for a PI controller and <code>Td/N</code> for a PID controller, and <code>N</code> is commonly in the range 2 to 20.  The state space will be returned on controllable canonical form.</p><p>For a discrete controller a positive <code>Ts</code> can be supplied.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">C1 = pid(3.3, 1, 2)                             # Kd≠0 works without filter in tf form
C2 = pid(3.3, 1, 2; Tf=0.3, state_space=true)   # In statespace a filter is needed
C3 = pid(2., 3, 0; Ts=0.4, state_space=true)    # Discrete</code></pre><p>The functions <code>pid_tf</code> and <code>pid_ss</code> are also exported. They take the same parameters and is what is actually called in <code>pid</code> based on the <code>state_space</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}" href="#ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystems.pidplots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pidplots(P, args...; params_p, params_i, params_d=0, form=:standard, ω=0, grid=false, kwargs...)</code></pre><p>Plots interesting figures related to closing the loop around process <code>P</code> with a PID controller supplied in <code>params</code> on one of the following forms:</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>The sent in values can be arrays to evaluate multiple different controllers, and if <code>grid=true</code> it will be a grid search  over all possible combinations of the values.</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps and should be supplied as additional arguments to the function.</p><p>One can also supply a frequency vector <code>ω</code> to be used in Bode and Nyquist plots.</p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L80-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystems.SisoRational{T}}, Any, Any}} where T" href="#ControlSystems.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystems.SisoRational{T}}, Any, Any}} where T"><code>ControlSystems.placePI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C, p, i = placePI(P, ω₀, ζ; form=:standard)</code></pre><p>Selects the parameters of a PI-controller such that the poles of  closed loop between <code>P</code> and <code>C</code> are placed to match the poles of  <code>s^2 + 2ζω₀s + ω₀^2</code>.</p><p>The parameters can be returned as one of several common representations  chose by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s))</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))</code> (equivalent to above for PI controllers)</li><li><code>:parallel</code> - <code>Kp + Ki/s</code></li></ul><p><code>C</code> is the returned transfer function of the controller and <code>params</code>  is a named tuple containing the parameters. The parameters can be accessed as <code>params.Kp</code> or <code>params[&quot;Kp&quot;]</code> from the named tuple, or they can be unpacked using <code>Kp, Ti, Td = values(params)</code>.</p><p>See also <a href="#ControlSystems.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L396-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rlocusplot" href="#ControlSystems.rlocusplot"><code>ControlSystems.rlocusplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rlocusplot(P::LTISystem, K)</code></pre><p>Computes and plots the root locus of the SISO LTISystem P with a negative feedback loop and feedback gains <code>K</code>, if <code>K</code> is not provided, range(1e-6,stop=500,length=10000) is used. If <code>OrdinaryDiffEq.jl</code> is installed and loaded by the user (<code>using OrdinaryDiffEq</code>), <code>rlocusplot</code> will use an adaptive step-size algorithm to select values of <code>K</code>. A scalar <code>Kmax</code> can then be given as second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L179-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.stabregionPID" href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kp, ki, fig = stabregionPID(P, [ω]; kd=0, doplot=false, form=:standard)</code></pre><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The provided derivative gain is expected on parallel form, i.e., the form kp + ki/s + kd s, but the result can be transformed to any form given by the <code>form</code> keyword. The curve is found by analyzing P(s)*C(s) = -1 ⟹ |PC| = |P| |C| = 1 arg(P) + arg(C) = -π If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions See also <code>stabregionPID</code>, <code>loopshapingPI</code>, <code>pidplots</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/pid_design.jl#L301-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sminreal-Tuple{AbstractStateSpace}" href="#ControlSystems.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystems.sminreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p><p>Systems with numerical noise in the coefficients, e.g., noise on the order of <code>eps</code> require truncation to zero to be affected by structural simplification, e.g.,</p><pre><code class="language-julia hljs">trunc_zero!(A) = A[abs.(A) .&lt; 10eps(maximum(abs, A))] .= 0
trunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)
sminreal(sys)</code></pre><p>See also <a href="#ControlSystems.minreal"><code>minreal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/simplification.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.add_input" href="#ControlSystems.add_input"><code>ControlSystems.add_input</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_input(sys::AbstractStateSpace, B2::AbstractArray, D2 = 0)</code></pre><p>Add inputs to <code>sys</code> by forming</p><p class="math-container">\[x&#39; = Ax + [B B2]u
y  = Cx + [D D2]u\]</p><p>If <code>B2</code> is an integer it will be interpreted as an index and an input matrix containing a single 1 at the specified index will be used.</p><p>Example: The following example forms an innovation model that takes innovations as inputs</p><pre><code class="language-julia hljs">G   = ssrand(2,2,3, Ts=1)
K   = kalman(G, I(G.nx), I(G.ny))
sys = add_input(G, K)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L141-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.add_output" href="#ControlSystems.add_output"><code>ControlSystems.add_output</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_output(sys::AbstractStateSpace, C2::AbstractArray, D2 = 0)</code></pre><p>Add outputs to <code>sys</code> by forming</p><p class="math-container">\[x&#39; = Ax + Bu
y  = [C; C2]x + [D; D2]u\]</p><p>If <code>C2</code> is an integer it will be interpreted as an index and an output matrix containing a single 1 at the specified index will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L173-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}" href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystems.append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}" href="#ControlSystems.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystems.array2mimo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array2mimo(M::AbstractArray{&lt;:LTISystem})</code></pre><p>Take an array of <code>LTISystem</code>s and create a single MIMO system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}" href="#ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><em>Basic use</em> <code>feedback(sys1, sys2)</code> forms the feedback interconnection</p><pre><code class="language-julia hljs">           ┌──────────────┐
◄──────────┤     sys1     │◄──── Σ ◄──────
    │      │              │      │
    │      └──────────────┘      -1
    │                            |
    │      ┌──────────────┐      │
    └─────►│     sys2     ├──────┘
           │              │
           └──────────────┘</code></pre><p><em>Advanced use</em> <code>feedback</code> also supports more flexible use according to the figure below</p><pre><code class="language-julia hljs">              ┌──────────────┐
      z1◄─────┤     sys1     │◄──────w1
 ┌─── y1◄─────┤              │◄──────u1 ◄─┐
 │            └──────────────┘            │
 │                                        α
 │            ┌──────────────┐            │
 └──► u2─────►│     sys2     ├───────►y2──┘
      w2─────►│              ├───────►z2
              └──────────────┘</code></pre><p><code>U1</code>, <code>W1</code> specifies the indices of the input signals of <code>sys1</code> corresponding to <code>u1</code> and <code>w1</code> <code>Y1</code>, <code>Z1</code> specifies the indices of the output signals of <code>sys1</code> corresponding to <code>y1</code> and <code>z1</code> <code>U2</code>, <code>W2</code>, <code>Y2</code>, <code>Z2</code> specifies the corresponding signals of <code>sys2</code> </p><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.</p><p>Negative feedback (α = -1) is the default. Specify <code>pos_feedback=true</code> for positive feedback (α = 1).</p><p>See also <code>lft</code>, <code>starprod</code>, <code>sensitivity</code>, <code>input_sensitivity</code>, <code>output_sensitivity</code>, <code>comp_sensitivity</code>, <code>input_comp_sensitivity</code>, <code>output_comp_sensitivity</code>, <code>G_PS</code>, <code>G_CS</code>.</p><p>See Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L268-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{TransferFunction}" href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys)
feedback(sys1, sys2)</code></pre><p>For a general LTI-system, <code>feedback</code> forms the negative feedback interconnection</p><pre><code class="language-julia hljs">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L212-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}" href="#ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denomenator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L388-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE" href="#ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)</code></pre><p>Return the transfer function <code>P(F+C)/(1+PC)</code> which is the closed-loop system with process <code>P</code>, controller <code>C</code> and feedforward filter <code>F</code> from reference to control signal (by-passing <code>C</code>).</p><pre><code class="nohighlight hljs">         +-------+
         |       |
   +-----&gt;   F   +----+
   |     |       |    |
   |     +-------+    |
   |     +-------+    |    +-------+
r  |  -  |       |    |    |       |    y
+--+-----&gt;   C   +----+----&gt;   P   +---+--&gt;
      |  |       |         |       |   |
      |  +-------+         +-------+   |
      |                                |
      +--------------------------------+</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L402-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lft" href="#ControlSystems.lft"><code>ControlSystems.lft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lft(G, Δ, type=:l)</code></pre><p>Lower and upper linear fractional transformation between systems <code>G</code> and <code>Δ</code>.</p><p>Specify <code>:l</code> lor lower LFT, and <code>:u</code> for upper LFT.</p><p><code>G</code> must have more inputs and outputs than <code>Δ</code> has outputs and inputs.</p><p>For details, see Chapter 9.1 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L434-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.parallel-Tuple{LTISystem, LTISystem}" href="#ControlSystems.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystems.parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.series-Tuple{LTISystem, LTISystem}" href="#ControlSystems.series-Tuple{LTISystem, LTISystem}"><code>ControlSystems.series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}" href="#ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystems.starprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">starprod(sys1, sys2, dimu, dimy)</code></pre><p>Compute the Redheffer star product.</p><p><code>length(U1) = length(Y2) = dimu</code> and <code>length(Y1) = length(U2) = dimy</code></p><p>For details, see Chapter 9.3 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/connections.jl#L462-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.G_CS-Tuple{Any, Any}" href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>ControlSystems.G_CS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_CS(P, C)</code></pre><p>The closed-loop transfer function from (-) measurement noise or (+) reference to control signal. Technically, the transfer function is given by <code>(1 + CP)⁻¹C</code> so <code>SC</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.G_PS-Tuple{Any, Any}" href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>ControlSystems.G_PS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">G_PS(P, C)</code></pre><p>The closed-loop transfer function from load disturbance to plant output. Technically, the transfer function is given by <code>(1 + PC)⁻¹P</code> so <code>SP</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.comp_sensitivity-Tuple" href="#ControlSystems.comp_sensitivity-Tuple"><code>ControlSystems.comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.input_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystems.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(P,C)</code></pre><p>Transfer function from load disturbance to control signal.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case controller output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L82-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.input_sensitivity-Tuple{Any, Any}" href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>ControlSystems.input_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(P, C)</code></pre><p>Transfer function from load disturbance to total plant input.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.output_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystems.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(P,C)</code></pre><p>Transfer function from measurement noise / reference to plant output.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case plant output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.output_sensitivity-Tuple{Any, Any}" href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>ControlSystems.output_sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(P, C)</code></pre><p>Transfer function from measurement noise / reference to control error.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L69-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sensitivity-Tuple" href="#ControlSystems.sensitivity-Tuple"><code>ControlSystems.sensitivity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See <a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystems.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystems.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystems.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystems.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystems.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystems.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/sensitivity_functions.jl#L23-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem, w::AbstractVector; $(Expr(:kw, :unwrap, true)))</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem}" href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}" href="#ControlSystems.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(G::AbstractMatrix, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}" href="#ControlSystems.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(G::Number, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Union{Tuple{var&quot;#314#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#314#W&quot;}}} where var&quot;#314#W&quot;&lt;:Real" href="#ControlSystems.freqrespv-Union{Tuple{var&quot;#314#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#314#W&quot;}}} where var&quot;#314#W&quot;&lt;:Real"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(sys::LTISystem, w_vec::AbstractVector{W}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem}" href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem}" href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/7d6d0d5a2c08c3d0fb35cf2833aa60b662977222/src/utilities.jl#L186-L191">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analysis/">« Analysis</a><a class="docs-footer-nextpage" href="../timefreqresponse/">Time and Frequency response »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.20 on <span class="colophon-date" title="Monday 11 July 2022 14:44">Monday 11 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
