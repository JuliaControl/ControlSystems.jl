<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Constructors Â· ControlSystems.jl</title><meta name="title" content="Constructors Â· ControlSystems.jl"/><meta property="og:title" content="Constructors Â· ControlSystems.jl"/><meta property="twitter:title" content="Constructors Â· ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/analysis/">Analysis</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../../examples/automatic_differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../../examples/tuning_from_data/">Tune a controller using experimental data</a></li><li><a class="tocitem" href="../../examples/zoh/">Analysis of sampled-data (continuous/discrete) systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li class="is-active"><a class="tocitem" href>Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../synthesis/">Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Constructors</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Constructors</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/constructors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystemsBase.append"><code>ControlSystemsBase.append</code></a></li><li><a href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a></li><li><a href="#ControlSystemsBase.delay"><code>ControlSystemsBase.delay</code></a></li><li><a href="#ControlSystemsBase.feedback"><code>ControlSystemsBase.feedback</code></a></li><li><a href="#ControlSystemsBase.feedback2dof"><code>ControlSystemsBase.feedback2dof</code></a></li><li><a href="#ControlSystemsBase.minreal"><code>ControlSystemsBase.minreal</code></a></li><li><a href="#ControlSystemsBase.pade"><code>ControlSystemsBase.pade</code></a></li><li><a href="#ControlSystemsBase.parallel"><code>ControlSystemsBase.parallel</code></a></li><li><a href="#ControlSystemsBase.series"><code>ControlSystemsBase.series</code></a></li><li><a href="#ControlSystemsBase.seriesform"><code>ControlSystemsBase.seriesform</code></a></li><li><a href="#ControlSystemsBase.sminreal"><code>ControlSystemsBase.sminreal</code></a></li><li><a href="#ControlSystemsBase.ss"><code>ControlSystemsBase.ss</code></a></li><li><a href="#ControlSystemsBase.ssdata"><code>ControlSystemsBase.ssdata</code></a></li><li><a href="#ControlSystemsBase.tf"><code>ControlSystemsBase.tf</code></a></li><li><a href="#ControlSystemsBase.thiran"><code>ControlSystemsBase.thiran</code></a></li><li><a href="#ControlSystemsBase.zpk"><code>ControlSystemsBase.zpk</code></a></li></ul><p>See also <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Connecting-systems-together">Connecting named systems together</a>.</p><h1 id="Constructing-systems"><a class="docs-heading-anchor" href="#Constructing-systems">Constructing systems</a><a id="Constructing-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-systems" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.append" href="#ControlSystemsBase.append"><code>ControlSystemsBase.append</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d" href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysd = c2d(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)
Gd = c2d(G::TransferFunction{&lt;:Continuous}, Ts, method=:zoh)</code></pre><p>Convert the continuous-time system <code>sys</code> into a discrete-time system with sample time <code>Ts</code>, using the specified <code>method</code> (:<code>zoh</code>, <code>:foh</code>, <code>:fwdeuler</code> or <code>:tustin</code>).</p><p><code>method = :tustin</code> performs a bilinear transform with prewarp frequency <code>w_prewarp</code>.</p><ul><li><code>w_prewarp</code>: Frequency (rad/s) for pre-warping when using the Tustin method, has no effect for other methods.</li></ul><p>See also <code>c2d_x0map</code></p><p><strong>Extended help</strong></p><p>ZoH sampling is exact for linear systems with piece-wise constant inputs (step invariant), i.e., the solution obtained using <a href="../timefreqresponse/#ControlSystemsBase.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>lsim</code></a> is not approximative (modulu machine precision). ZoH sampling is commonly used to discretize continuous-time plant models that are to be controlled using a discrete-time controller.</p><p>FoH sampling is exact for linear systems with piece-wise linear inputs (ramp invariant), this is a good choice for simulation of systems with smooth continuous inputs.</p><p>To approximate the behavior of a continuous-time system well in the frequency domain, the <code>:tustin</code> (trapezoidal / bilinear) method may be most appropriate. In this case, the pre-warping argument can be used to ensure that the frequency response of the discrete-time system matches the continuous-time system at a given frequency. The tustin transformation alters the meaning of the state components, while ZoH and FoH preserve the meaning of the state components. The Tustin method is commonly used to discretize a continuous-time controller.</p><p>The forward-Euler method generally requires the sample time to be very small relative to the time constants of the system, and its use is generally discouraged.</p><p>Classical rules-of-thumb for selecting the sample time for control design dictate that <code>Ts</code> should be chosen as <span>$0.2 â‰¤ Ï‰gcâ‹…Ts â‰¤ 0.6$</span> where <span>$Ï‰gc$</span> is the gain-crossover frequency (rad/s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/discrete.jl#L5-L31">source</a></section><section><div><pre><code class="language-julia hljs">Qd     = c2d(sys::StateSpace{Continuous}, Qc::Matrix, Ts;             opt=:o)
Qd, Rd = c2d(sys::StateSpace{Continuous}, Qc::Matrix, Rc::Matrix, Ts; opt=:o)
Qd     = c2d(sys::StateSpace{Discrete},   Qc::Matrix;                 opt=:o)
Qd, Rd = c2d(sys::StateSpace{Discrete},   Qc::Matrix, Rc::Matrix;     opt=:o)</code></pre><p>Sample a continuous-time covariance or LQR cost matrix to fit the provided discrete-time system.</p><p>If <code>opt = :o</code> (default), the matrix is assumed to be a covariance matrix. The measurement covariance <code>R</code> may also be provided. If <code>opt = :c</code>, the matrix is instead assumed to be a cost matrix for an LQR problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Measurement covariance (here called <code>Rc</code>) is usually estimated in discrete time, and is in this case not dependent on the sample rate. Discretization of the measurement covariance only makes sense when a continuous-time controller has been designed and the closest corresponding discrete-time controller is desired.</p></div></div><p>The method used comes from theorem 5 in the reference below.</p><p>Ref: &quot;Discrete-time Solutions to the Continuous-time Differential Lyapunov Equation With Applications to Kalman Filtering&quot;,  Patrik Axelsson and Fredrik Gustafsson</p><p>On singular covariance matrices: The traditional double integrator with covariance matrix <code>Q = diagm([0,ÏƒÂ²])</code> can not be sampled with this method. Instead, the input matrix (&quot;Cholesky factor&quot;) of <code>Q</code> must be manually kept track of, e.g., the noise of variance <code>ÏƒÂ²</code> enters like <code>N = [0, 1]</code> which is sampled using ZoH and becomes <code>Nd = [1/2 Ts^2; Ts]</code> which results in the covariance matrix <code>ÏƒÂ² * Nd * Nd&#39;</code>. </p><p><strong>Example:</strong></p><p>The following example designs a continuous-time LQR controller for a resonant system. This is simulated with OrdinaryDiffEq to allow the ODE integrator to also integrate the continuous-time LQR cost (the cost is added as an additional state variable). We then discretize both the system and the cost matrices and simulate the same thing. The discretization of an LQR contorller in this way is sometimes refered to as <code>lqrd</code>.</p><pre><code class="language-julia hljs">using ControlSystemsBase, LinearAlgebra, OrdinaryDiffEq, Test
sysc = DemoSystems.resonant()
x0 = ones(sysc.nx)
Qc = [1 0.01; 0.01 2] # Continuous-time cost matrix for the state
Rc = I(1)             # Continuous-time cost matrix for the input

L = lqr(sysc, Qc, Rc)
dynamics = function (xc, p, t)
    x = xc[1:sysc.nx]
    u = -L*x
    dx = sysc.A*x + sysc.B*u
    dc = dot(x, Qc, x) + dot(u, Rc, u)
    return [dx; dc]
end
prob = ODEProblem(dynamics, [x0; 0], (0.0, 10.0))
sol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)
cc = sol.u[end][end] # Continuous-time cost

# Discrete-time version
Ts = 0.01 
sysd = c2d(sysc, Ts)
Qd, Rd = c2d(sysd, Qc, Rc, opt=:c)
Ld = lqr(sysd, Qd, Rd)
sold = lsim(sysd, (x, t) -&gt; -Ld*x, 0:Ts:10, x0 = x0)
function cost(x, u, Q, R)
    dot(x, Q, x) + dot(u, R, u)
end
cd = cost(sold.x, sold.u, Qd, Rd) # Discrete-time cost
@test cc â‰ˆ cd rtol=0.01           # These should be similar</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/discrete.jl#L166-L221">source</a></section><section><div><pre><code class="language-julia hljs">c2d(G::DelayLtiSystem, Ts, method=:zoh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/delay_systems.jl#L55-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback" href="#ControlSystemsBase.feedback"><code>ControlSystemsBase.feedback</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback(sys)
feedback(sys1, sys2)</code></pre><p>For a general LTI-system, <code>feedback</code> forms the negative feedback interconnection</p><pre><code class="language-julia hljs">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L228-L239">source</a></section><section><div><pre><code class="language-julia hljs">feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><em>Basic use</em> <code>feedback(sys1, sys2)</code> forms the (negative) feedback interconnection</p><pre><code class="language-julia hljs">           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤     sys1     â”‚â—„â”€â”€â”€â”€ Î£ â—„â”€â”€â”€â”€â”€â”€
    â”‚      â”‚              â”‚      â”‚
    â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      -1
    â”‚                            |
    â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
    â””â”€â”€â”€â”€â”€â–ºâ”‚     sys2     â”œâ”€â”€â”€â”€â”€â”€â”˜
           â”‚              â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><p>If no second system <code>sys2</code> is given, negative identity feedback (<code>sys2 = 1</code>) is assumed. The returned closed-loop system will have a state vector comprised of the state of <code>sys1</code> followed by the state of <code>sys2</code>.</p><p><em>Advanced use</em> <code>feedback</code> also supports more flexible use according to the figure below</p><pre><code class="language-julia hljs">              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      z1â—„â”€â”€â”€â”€â”€â”¤     sys1     â”‚â—„â”€â”€â”€â”€â”€â”€w1
 â”Œâ”€â”€â”€ y1â—„â”€â”€â”€â”€â”€â”¤              â”‚â—„â”€â”€â”€â”€â”€â”€u1 â—„â”€â”
 â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
 â”‚                                        Î±
 â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
 â””â”€â”€â–º u2â”€â”€â”€â”€â”€â–ºâ”‚     sys2     â”œâ”€â”€â”€â”€â”€â”€â”€â–ºy2â”€â”€â”˜
      w2â”€â”€â”€â”€â”€â–ºâ”‚              â”œâ”€â”€â”€â”€â”€â”€â”€â–ºz2
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre><ul><li><code>U1</code>, <code>W1</code> specify the indices of the input signals of <code>sys1</code> corresponding to <code>u1</code> and <code>w1</code>. <code>W1</code> contains the indices of the inputs of <code>sys1</code> that are included among the inputs to the returned system, i.e., external inputs.</li><li><code>Y1</code>, <code>Z1</code> specify the indices of the output signals of <code>sys1</code> corresponding to <code>y1</code> and <code>z1</code>. <code>Z1 contains the indices of the outputs of</code>sys1` that are included among the outputs of the returned system, i.e., external outputs.</li><li><code>U2</code>, <code>W2</code>, <code>Y2</code>, <code>Z2</code> specify the corresponding signals of <code>sys2</code>. <code>W2 contains the indices of the inputs of</code>sys2<code>that are included among the inputs to the returned system, i.e., external inputs.</code>Z2<code>contains the indices of the outputs of</code>sys2` that are included among the outputs of the returned system, i.e., external outputs.</li></ul><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.</p><p>Negative feedback (Î± = -1) is the default. Specify <code>pos_feedback=true</code> for positive feedback (Î± = 1).</p><p>See also <code>lft</code>, <code>starprod</code>, <code>sensitivity</code>, <code>input_sensitivity</code>, <code>output_sensitivity</code>, <code>comp_sensitivity</code>, <code>input_comp_sensitivity</code>, <code>output_comp_sensitivity</code>, <code>G_PS</code>, <code>G_CS</code>.</p><p>The manual section <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/#From-block-diagrams-to-code">From block diagrams to code</a> contains higher-level instructions on how to use this function. See also <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Connecting-systems-together">RobustAndOptimalControl.jl: Connections using named signals</a> for a higher-level interface.</p><p>See Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L285-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback2dof" href="#ControlSystemsBase.feedback2dof"><code>ControlSystemsBase.feedback2dof</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denominator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L448-L454">source</a></section><section><div><pre><code class="language-julia hljs">feedback2dof(P, C, F)</code></pre><p>Return the transfer function <code>P(F+C)/(1+PC)</code> which is the closed-loop system with process <code>P</code>, controller <code>C</code> and feedforward filter <code>F</code> from reference to control signal (by-passing <code>C</code>).</p><pre><code class="nohighlight hljs">         +-------+
         |       |
   +-----&gt;   F   +----+
   |     |       |    |
   |     +-------+    |
   |     +-------+    |    +-------+
r  |  -  |       |    |    |       |    y
+--+-----&gt;   C   +----+----&gt;   P   +---+--&gt;
      |  |       |         |       |   |
      |  +-------+         +-------+   |
      |                                |
      +--------------------------------+</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L462-L482">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.minreal" href="#ControlSystemsBase.minreal"><code>ControlSystemsBase.minreal</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minreal(tf::TransferFunction, eps=sqrt(eps()))</code></pre><p>Create a minimal representation of each transfer function in <code>tf</code> by cancelling poles and zeros will promote system to an appropriate numeric type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/TransferFunction.jl#L77-L82">source</a></section><section><div><pre><code class="language-julia hljs">minreal(sys::StateSpace; fast=false, kwargs...)</code></pre><p>Minimal realisation algorithm from P. Van Dooreen, The generalized eigenstructure problem in linear system theory, IEEE Transactions on Automatic Control</p><p>For information about the options, see <code>?ControlSystemsBase.MatrixPencils.lsminreal</code></p><p>See also <a href="#ControlSystemsBase.sminreal"><code>sminreal</code></a>, which is both numerically exact and substantially faster than <code>minreal</code>, but with a much more limited potential in removing non-minimal dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/StateSpace.jl#L594-L602">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.parallel" href="#ControlSystemsBase.parallel"><code>ControlSystemsBase.parallel</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.series" href="#ControlSystemsBase.series"><code>ControlSystemsBase.series</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.sminreal" href="#ControlSystemsBase.sminreal"><code>ControlSystemsBase.sminreal</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p><p>Systems with numerical noise in the coefficients, e.g., noise on the order of <code>eps</code> require truncation to zero to be affected by structural simplification, e.g.,</p><pre><code class="language-julia hljs">trunc_zero!(A) = A[abs.(A) .&lt; 10eps(maximum(abs, A))] .= 0
trunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)
sminreal(sys)</code></pre><p>In contrast to <a href="#ControlSystemsBase.minreal"><code>minreal</code></a>, which performs pole-zero cancellation using linear-algebra operations, has an ğ‘‚(nâ‚“^3) complexity and is subject to numerical tolerances, <code>sminreal</code> is computationally very cheap and numerically exact (operates on integers). However, the ability of <code>sminreal</code> to reduce the order of the model is much less powerful.</p><p>See also <a href="#ControlSystemsBase.minreal"><code>minreal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/simplification.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.ss" href="#ControlSystemsBase.ss"><code>ControlSystemsBase.ss</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sys = ss(A, B, C, D)      # Continuous
sys = ss(A, B, C, D, Ts)  # Discrete</code></pre><p>Create a state-space model <code>sys::StateSpace{TE, T}</code> with matrix element type <code>T</code> and TE is <code>Continuous</code> or <code>&lt;:Discrete</code>.</p><p>This is a continuous-time model if <code>Ts</code> is omitted. Otherwise, this is a discrete-time model with sampling period <code>Ts</code>.</p><p><code>D</code> may be specified as <code>0</code> in which case a zero matrix of appropriate size is constructed automatically.  <code>sys = ss(D [, Ts])</code> specifies a static gain matrix <code>D</code>.</p><p>To associate names with states, inputs and outputs, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Named-systems"><code>named_ss</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/StateSpace.jl#L128-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.tf" href="#ControlSystemsBase.tf"><code>ControlSystemsBase.tf</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sys = tf(num, den[, Ts])
sys = tf(gain[, Ts])</code></pre><p>Create as a fraction of polynomials:</p><ul><li><code>sys::TransferFunction{SisoRational{T,TR}} = numerator/denominator</code></li></ul><p>where T is the type of the coefficients in the polynomial.</p><ul><li><code>num</code>: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems</li></ul><p>or an array of vectors to create MIMO system.</p><ul><li><code>den</code>: the coefficients of the denominator polynomial. Either vector to create SISO systems</li></ul><p>or an array of vectors to create MIMO system.</p><ul><li><code>Ts</code>: Sample time if discrete time system.</li></ul><p>The polynomial coefficients are ordered starting from the highest order term. </p><p>Other uses:</p><ul><li><code>tf(sys)</code>: Convert <code>sys</code> to <code>tf</code> form.</li><li><code>tf(&quot;s&quot;)</code>, <code>tf(&quot;z&quot;)</code>: Create the continuous-time transfer function <code>s</code>, or the discrete-time transfer function <code>z</code>.</li><li><code>numpoly(sys)</code>, <code>denpoly(sys)</code>: Get the numerator and denominator polynomials of <code>sys</code> as a matrix of vectors, where the outer matrix is of size <code>n_output Ã— n_inputs</code>.</li></ul><p>See also: <a href="#ControlSystemsBase.zpk"><code>zpk</code></a>, <a href="#ControlSystemsBase.ss"><code>ss</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/tf.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.zpk" href="#ControlSystemsBase.zpk"><code>ControlSystemsBase.zpk</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zpk(gain[, Ts])
zpk(num, den, k[, Ts])
zpk(sys)</code></pre><p>Create transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.</p><ul><li><code>sys::TransferFunction{SisoZpk{T,TR}} = k*numerator/denominator</code></li></ul><p>where <code>T</code> is the type of <code>k</code> and <code>TR</code> the type of the zeros/poles, usually Float64 and Complex{Float64}.</p><ul><li><code>num</code>: the roots of the numerator polynomial. Either scalar or vector to create SISO systems</li></ul><p>or an array of vectors to create MIMO system.</p><ul><li><code>den</code>: the roots of the denominator polynomial. Either vector to create SISO systems</li></ul><p>or an array of vectors to create MIMO system.</p><ul><li><code>k</code>: The gain of the system. Obs, this is not the same as <code>dcgain</code>.</li><li><code>Ts</code>: Sample time if discrete time system.</li></ul><p>Other uses:</p><ul><li><code>zpk(sys)</code>: Convert <code>sys</code> to <code>zpk</code> form.</li><li><code>zpk(&quot;s&quot;)</code>: Create the transferfunction <code>s</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/zpk.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.delay" href="#ControlSystemsBase.delay"><code>ControlSystemsBase.delay</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">delay(tau)
delay(tau, Ts)
delay(T::Type{&lt;:Number}, tau)
delay(T::Type{&lt;:Number}, tau, Ts)</code></pre><p>Create a pure time delay of length <code>Ï„</code> of type <code>T</code>.</p><p>The type <code>T</code> defaults to <code>promote_type(Float64, typeof(tau))</code>.</p><p>If <code>Ts</code> is given, the delay is discretized with sampling time <code>Ts</code> and a discrete-time StateSpace object is returned.</p><p><strong>Example:</strong></p><p>Create a LTI system with an input delay of <code>L</code></p><pre><code class="language-julia hljs">L = 1
tf(1, [1, 1])*delay(L)
s = tf(&quot;s&quot;)
tf(1, [1, 1])*exp(-s*L) # Equivalent to the version above</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/DelayLtiSystem.jl#L125-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.pade" href="#ControlSystemsBase.pade"><code>ControlSystemsBase.pade</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pade(Ï„::Real, N::Int)</code></pre><p>Compute the <code>N</code>th order PadÃ© approximation of a time-delay of length <code>Ï„</code>.</p><p>See also <a href="#ControlSystemsBase.thiran"><code>thiran</code></a> for discretization of delays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/delay_systems.jl#L128-L134">source</a></section><section><div><pre><code class="language-julia hljs">pade(G::DelayLtiSystem, N)</code></pre><p>Approximate all time-delays in <code>G</code> by PadÃ© approximations of degree <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/delay_systems.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.thiran" href="#ControlSystemsBase.thiran"><code>ControlSystemsBase.thiran</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">thiran(Ï„::Real, Ts)</code></pre><p>Discretize a potentially fractional delay <span>$Ï„$</span> as a Thiran all-pass filter with sample time <code>Ts</code>. </p><p>The Thiran all-pass filter gives an a maximally flat group delay.</p><p>If <span>$Ï„$</span> is an integer multiple of <span>$Ts$</span>, the Thiran all-pass filter reduces to <span>$z^{-Ï„/Ts}$</span>.</p><p>Ref: T. I. Laakso, V. Valimaki, M. Karjalainen and U. K. Laine, &quot;Splitting the unit delay [FIR/all pass filters design],&quot; in IEEE Signal Processing Magazine, vol. 13, no. 1, 1996.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/delay_systems.jl#L156-L166">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.ssdata" href="#ControlSystemsBase.ssdata"><code>ControlSystemsBase.ssdata</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">A, B, C, D = ssdata(sys)</code></pre><p>Outputs the statespace matrices of sys. The matrices are not copies: no new memory is allocated, but modifying the matrices in-place will change the behavior of sys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/types/StateSpace.jl#L214-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.seriesform" href="#ControlSystemsBase.seriesform"><code>ControlSystemsBase.seriesform</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Gs, k = seriesform(G::TransferFunction{Discrete})</code></pre><p>Convert a transfer function <code>G</code> to a vector of second-order transfer functions and a scalar gain <code>k</code>, the product of which equals <code>G</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function requires the user to load the package DSP.jl.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/e20b8ce5302e3b38a900093524c65b94c59a3c70/lib/ControlSystemsBase/src/ControlSystemsBase.jl#L221-L228">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/zoh/">Â« Analysis of sampled-data (continuous/discrete) systems</a><a class="docs-footer-nextpage" href="../analysis/">Analysis Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 30 January 2025 12:04">Thursday 30 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
