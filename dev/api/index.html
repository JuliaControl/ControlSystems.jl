<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ControlSystems.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ControlSystems.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Guide</span><ul><li><a class="tocitem" href="../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../man/creating_systems/">Creating Systems</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/example/">Design</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../lib/constructors/">Constructors</a></li><li><a class="tocitem" href="../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../lib/synthesis/">Synthesis</a></li><li><a class="tocitem" href="../lib/timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../lib/plotting/">Plotting</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Exported-functions-and-types"><a class="docs-heading-anchor" href="#Exported-functions-and-types">Exported functions and types</a><a id="Exported-functions-and-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions-and-types" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#ControlSystems.DelayLtiSystem-Union{Tuple{StateSpace}, Tuple{S}, Tuple{T}, Tuple{StateSpace, AbstractVector{S}}} where {T&lt;:Number, S&lt;:Real}"><code>ControlSystems.DelayLtiSystem</code></a></li><li><a href="#ControlSystems.DelayLtiSystem"><code>ControlSystems.DelayLtiSystem</code></a></li><li><a href="#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F"><code>ControlSystems.Simulator</code></a></li><li><a href="#ControlSystems.Simulator"><code>ControlSystems.Simulator</code></a></li><li><a href="#ControlSystems.TransferFunction-Tuple{Any}"><code>ControlSystems.TransferFunction</code></a></li><li><a href="#Base.step-Tuple{AbstractStateSpace, AbstractVector}"><code>Base.step</code></a></li><li><a href="#CommonSolve.solve"><code>CommonSolve.solve</code></a></li><li><a href="../lib/constructors/#ControlSystems.append"><code>ControlSystems.append</code></a></li><li><a href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystems.append</code></a></li><li><a href="#ControlSystems.balance"><code>ControlSystems.balance</code></a></li><li><a href="#ControlSystems.balance_statespace"><code>ControlSystems.balance_statespace</code></a></li><li><a href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a></li><li><a href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a></li><li><a href="#ControlSystems.bode-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bode</code></a></li><li><a href="#ControlSystems.bodeplot"><code>ControlSystems.bodeplot</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bodev</code></a></li><li><a href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a></li><li><a href="../lib/constructors/#ControlSystems.c2d"><code>ControlSystems.c2d</code></a></li><li><a href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a></li><li><a href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a></li><li><a href="#ControlSystems.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_poly2poly</code></a></li><li><a href="#ControlSystems.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_roots2poly</code></a></li><li><a href="#ControlSystems.c2d_x0map"><code>ControlSystems.c2d_x0map</code></a></li><li><a href="#ControlSystems.care-NTuple{4, Any}"><code>ControlSystems.care</code></a></li><li><a href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a></li><li><a href="#ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}"><code>ControlSystems.ctrb</code></a></li><li><a href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a></li><li><a href="#ControlSystems.dab-Tuple{Any, Any, Any}"><code>ControlSystems.dab</code></a></li><li><a href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a></li><li><a href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a></li><li><a href="#ControlSystems.dare-NTuple{4, Any}"><code>ControlSystems.dare</code></a></li><li><a href="#ControlSystems.dcgain"><code>ControlSystems.dcgain</code></a></li><li><a href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a></li><li><a href="#ControlSystems.diagonalize-Tuple{AbstractStateSpace}"><code>ControlSystems.diagonalize</code></a></li><li><a href="#ControlSystems.dkalman-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.dkalman</code></a></li><li><a href="#ControlSystems.dlqr-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.dlqr</code></a></li><li><a href="#ControlSystems.dlyap-Tuple{AbstractMatrix, Any}"><code>ControlSystems.dlyap</code></a></li><li><a href="#ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}"><code>ControlSystems.evalfr</code></a></li><li><a href="../lib/constructors/#ControlSystems.feedback"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a></li><li><a href="#ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystems.feedback</code></a></li><li><a href="../lib/constructors/#ControlSystems.feedback2dof"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystems.feedback2dof</code></a></li><li><a href="#ControlSystems.freqresp-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqresp</code></a></li><li><a href="#ControlSystems.freqrespv-Union{Tuple{var&quot;#266#W&quot;}, Tuple{AbstractStateSpace, AbstractVector{var&quot;#266#W&quot;}}} where var&quot;#266#W&quot;&lt;:Real"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.freqrespv-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a></li><li><a href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a></li><li><a href="#ControlSystems.gangoffourplot-Tuple{Union{LTISystem, Vector}, Vector, Vararg{Any}}"><code>ControlSystems.gangoffourplot</code></a></li><li><a href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a></li><li><a href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a></li><li><a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.grampd</code></a></li><li><a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystems.hinfnorm</code></a></li><li><a href="#ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}"><code>ControlSystems.impulse</code></a></li><li><a href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a></li><li><a href="#ControlSystems.iscontinuous-Tuple{LTISystem}"><code>ControlSystems.iscontinuous</code></a></li><li><a href="#ControlSystems.isdiscrete-Tuple{LTISystem}"><code>ControlSystems.isdiscrete</code></a></li><li><a href="#ControlSystems.isproper-Tuple{TransferFunction}"><code>ControlSystems.isproper</code></a></li><li><a href="#ControlSystems.isstable-Tuple{LTISystem}"><code>ControlSystems.isstable</code></a></li><li><a href="#ControlSystems.kalman-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.kalman</code></a></li><li><a href="#ControlSystems.laglink-Tuple{Any, Any}"><code>ControlSystems.laglink</code></a></li><li><a href="#ControlSystems.leadlink-Tuple{Any, Any, Any}"><code>ControlSystems.leadlink</code></a></li><li><a href="#ControlSystems.leadlinkat-Tuple{Any, Any, Any}"><code>ControlSystems.leadlinkat</code></a></li><li><a href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a></li><li><a href="#ControlSystems.lft"><code>ControlSystems.lft</code></a></li><li><a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a></li><li><a href="#ControlSystems.loopshapingPI-Tuple{Any, Any}"><code>ControlSystems.loopshapingPI</code></a></li><li><a href="#ControlSystems.lqr-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.lqr</code></a></li><li><a href="#ControlSystems.lsim-Union{Tuple{S}, Tuple{T}, Tuple{DelayLtiSystem{T, S}, Any, AbstractArray{&lt;:Real}}} where {T, S}"><code>ControlSystems.lsim</code></a></li><li><a href="#ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>ControlSystems.lsim</code></a></li><li><a href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.margin</code></a></li><li><a href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a></li><li><a href="#ControlSystems.minreal"><code>ControlSystems.minreal</code></a></li><li><a href="../lib/constructors/#ControlSystems.minreal"><code>ControlSystems.minreal</code></a></li><li><a href="#ControlSystems.minreal-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractStateSpace"><code>ControlSystems.minreal</code></a></li><li><a href="#ControlSystems.nicholsplot"><code>ControlSystems.nicholsplot</code></a></li><li><a href="#ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquist</code></a></li><li><a href="#ControlSystems.nyquistplot"><code>ControlSystems.nyquistplot</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a></li><li><a href="#ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystems.observer_controller</code></a></li><li><a href="#ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.observer_predictor</code></a></li><li><a href="#ControlSystems.obsv"><code>ControlSystems.obsv</code></a></li><li><a href="#ControlSystems.pade-Tuple{Real, Int64}"><code>ControlSystems.pade</code></a></li><li><a href="#ControlSystems.pade-Tuple{DelayLtiSystem, Any}"><code>ControlSystems.pade</code></a></li><li><a href="#ControlSystems.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystems.parallel</code></a></li><li><a href="../lib/constructors/#ControlSystems.parallel"><code>ControlSystems.parallel</code></a></li><li><a href="#ControlSystems.pid-Tuple{}"><code>ControlSystems.pid</code></a></li><li><a href="#ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystems.pidplots</code></a></li><li><a href="#ControlSystems.place"><code>ControlSystems.place</code></a></li><li><a href="#ControlSystems.placePI-Tuple{Any, Any, Any}"><code>ControlSystems.placePI</code></a></li><li><a href="#ControlSystems.poles-Tuple{AbstractStateSpace}"><code>ControlSystems.poles</code></a></li><li><a href="#ControlSystems.prescale-Tuple{AbstractStateSpace}"><code>ControlSystems.prescale</code></a></li><li><a href="#ControlSystems.pzmap"><code>ControlSystems.pzmap</code></a></li><li><a href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a></li><li><a href="#ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystems.relative_gain_array</code></a></li><li><a href="#ControlSystems.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystems.relative_gain_array</code></a></li><li><a href="#ControlSystems.rgaplot"><code>ControlSystems.rgaplot</code></a></li><li><a href="#ControlSystems.rlocusplot"><code>ControlSystems.rlocusplot</code></a></li><li><a href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a></li><li><a href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a></li><li><a href="../lib/constructors/#ControlSystems.series"><code>ControlSystems.series</code></a></li><li><a href="#ControlSystems.series-Tuple{LTISystem, LTISystem}"><code>ControlSystems.series</code></a></li><li><a href="#ControlSystems.setPlotScale-Tuple{AbstractString}"><code>ControlSystems.setPlotScale</code></a></li><li><a href="#ControlSystems.sigma-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigma</code></a></li><li><a href="#ControlSystems.sigmaplot"><code>ControlSystems.sigmaplot</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a></li><li><a href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a></li><li><a href="../lib/constructors/#ControlSystems.sminreal"><code>ControlSystems.sminreal</code></a></li><li><a href="#ControlSystems.sminreal-Tuple{StateSpace}"><code>ControlSystems.sminreal</code></a></li><li><a href="../lib/constructors/#ControlSystems.ss"><code>ControlSystems.ss</code></a></li><li><a href="#ControlSystems.ss-Tuple"><code>ControlSystems.ss</code></a></li><li><a href="#ControlSystems.ssdata-Tuple{AbstractStateSpace}"><code>ControlSystems.ssdata</code></a></li><li><a href="#ControlSystems.ssrand-Tuple{Type, Int64, Int64, Int64}"><code>ControlSystems.ssrand</code></a></li><li><a href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a></li><li><a href="#ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystems.starprod</code></a></li><li><a href="../lib/constructors/#ControlSystems.tf"><code>ControlSystems.tf</code></a></li><li><a href="#ControlSystems.tf-Union{Tuple{T2}, Tuple{T1}, Tuple{TE}, Tuple{AbstractVecOrMat{&lt;:AbstractVector{T1}}, AbstractVecOrMat{&lt;:AbstractVector{T2}}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T1&lt;:Number, T2&lt;:Number}"><code>ControlSystems.tf</code></a></li><li><a href="#ControlSystems.tzeros-Tuple{TransferFunction}"><code>ControlSystems.tzeros</code></a></li><li><a href="#ControlSystems.zpconv-NTuple{4, Any}"><code>ControlSystems.zpconv</code></a></li><li><a href="../lib/constructors/#ControlSystems.zpk"><code>ControlSystems.zpk</code></a></li><li><a href="#ControlSystems.zpk-Union{Tuple{TP}, Tuple{TZ}, Tuple{T0}, Tuple{TE}, Tuple{VecOrMat{&lt;:AbstractVector{TZ}}, VecOrMat{&lt;:AbstractVector{TP}}, VecOrMat{T0}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T0&lt;:Number, TZ&lt;:Number, TP&lt;:Number}"><code>ControlSystems.zpk</code></a></li><li><a href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a></li><li><a href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li></ul><h2 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.DelayLtiSystem" href="#ControlSystems.DelayLtiSystem"><code>ControlSystems.DelayLtiSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct DelayLtiSystem{T, S &lt;: Real} &lt;: LTISystem</code></pre><p>Represents an LTISystem with internal time-delay. See <code>?delay</code> for a convenience constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/DelayLtiSystem.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.DelayLtiSystem-Union{Tuple{StateSpace}, Tuple{S}, Tuple{T}, Tuple{StateSpace, AbstractVector{S}}} where {T&lt;:Number, S&lt;:Real}" href="#ControlSystems.DelayLtiSystem-Union{Tuple{StateSpace}, Tuple{S}, Tuple{T}, Tuple{StateSpace, AbstractVector{S}}} where {T&lt;:Number, S&lt;:Real}"><code>ControlSystems.DelayLtiSystem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DelayLtiSystem{T, S}(sys::StateSpace, Tau::AbstractVector{S}=Float64[]) where {T &lt;: Number, S &lt;: Real}</code></pre><p>Create a delayed system by speciying both the system and time-delay vector. NOTE: if you want to create a system with simple input or output delays, use the Function <code>delay(τ)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/DelayLtiSystem.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.Simulator" href="#ControlSystems.Simulator"><code>ControlSystems.Simulator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Simulator</code></pre><p><strong>Fields:</strong></p><pre><code class="nohighlight hljs">P::StateSpace
f = (x,p,t) -&gt; x
y = (x,t)   -&gt; y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/simulators.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F" href="#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F"><code>ControlSystems.Simulator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Simulator(P::StateSpace, u = (x,t) -&gt; 0)</code></pre><p>Used to simulate continuous-time systems. See function <code>?solve</code> for additional info.</p><p><strong>Usage:</strong></p><pre><code class="nohighlight hljs">using OrdinaryDiffEq, Plots
dt             = 0.1
tfinal         = 20
t              = 0:dt:tfinal
P              = ss(tf(1,[2,1])^2)
K              = 5
reference(x,t) = [1.]
s              = Simulator(P, reference)
x0             = [0.,0]
tspan          = (0.0,tfinal)
sol            = solve(s, x0, tspan, Tsit5())
plot(t, s.y(sol, t)[:], lab=&quot;Open loop step response&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/simulators.jl#L19-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.TransferFunction-Tuple{Any}" href="#ControlSystems.TransferFunction-Tuple{Any}"><code>ControlSystems.TransferFunction</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>F(s)</code>, <code>F(omega, true)</code>, <code>F(z, false)</code></p><p>Notation for frequency response evaluation.</p><ul><li>F(s) evaluates the continuous-time transfer function F at s.</li><li>F(omega,true) evaluates the discrete-time transfer function F at exp(im<em>Ts</em>omega)</li><li>F(z,false) evaluates the discrete-time transfer function F at z</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L124-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.step-Tuple{AbstractStateSpace, AbstractVector}" href="#Base.step-Tuple{AbstractStateSpace, AbstractVector}"><code>Base.step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y, t, x = step(sys[, tfinal])
y, t, x = step(sys[, t])</code></pre><p>Calculate the step response of system <code>sys</code>. If the final time <code>tfinal</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations.</p><p><code>y</code> has size <code>(ny, length(t), nu)</code>, <code>x</code> has size <code>(nx, length(t), nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/timeresp.jl#L5-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve" href="#CommonSolve.solve"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sol = solve(s::AbstractSimulator, x0, tspan,  args...; kwargs...)</code></pre><p>Simulate the system represented by <code>s</code> from initial state <code>x0</code> over time span <code>tspan = (t0,tf)</code>. <code>args</code> and <code>kwargs</code> are sent to the <code>solve</code> function from <code>OrdinaryDiffEq</code>, e.g., <code>solve(s, x0, tspan,  Tsit5(), reltol=1e-5)</code> solves the problem with solver <a href="http://docs.juliadiffeq.org/stable/solvers/ode_solve.html"><code>Tsit5()</code></a> and relative tolerance 1e-5.</p><p>See also <code>Simulator</code> <code>lsim</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/simulators.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}" href="#ControlSystems.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystems.append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balance" href="#ControlSystems.balance"><code>ControlSystems.balance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">S, P, B = balance(A[, perm=true])</code></pre><p>Compute a similarity transform <code>T = S*P</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L443-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balance_statespace" href="#ControlSystems.balance_statespace"><code>ControlSystems.balance_statespace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">A, B, C, T = balance_statespace{S}(A::Matrix{S}, B::Matrix{S}, C::Matrix{S}, perm::Bool=false)
sys, T = balance_statespace(sys::StateSpace, perm::Bool=false)</code></pre><p>Computes a balancing transformation <code>T</code> that attempts to scale the system so that the row and column norms of [T<em>A/T T</em>B; C/T 0] are approximately equal. If <code>perm=true</code>, the states in <code>A</code> are allowed to be reordered.</p><p>The inverse of <code>sysb, T = balance_statespace(sys)</code> is given by <code>similarity_transform(sysb, T)</code></p><p>This is not the same as finding a balanced realization with equal and diagonal observability and reachability gramians, see <a href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>balreal</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/conversion.jl#L158-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.balreal-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.balreal</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sysr, G, T = balreal(sys::StateSpace)</code></p><p>Calculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>. <code>T</code> is the similarity transform between the old state <code>x</code> and the new state <code>z</code> such that <code>Tz = x</code>.</p><p>See also <code>gram</code>, <code>baltrunc</code></p><p>Reference: Varga A., Balancing-free square-root algorithm for computing singular perturbation approximations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L480-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace" href="#ControlSystems.baltrunc-Tuple{ST} where ST&lt;:AbstractStateSpace"><code>ControlSystems.baltrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysr, G, T = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, n = nothing, residual = false)</code></pre><p>Reduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal <code>G</code>, and truncating it to order <code>n</code>. If <code>n</code> is not provided, it&#39;s chosen such that all states corresponding to singular values less than <code>atol</code> and less that <code>rtol σmax</code> are removed.</p><p><code>T</code> is the similarity transform between the old state <code>x</code> and the newstate <code>z</code> such that <code>Tz = x</code>.</p><p>If <code>residual = true</code>, matched static gain is achieved through &quot;residualization&quot;, i.e., setting</p><p class="math-container">\[0 = A_{21}x_{1} + A_{22}x_{2} + B_{2}u\]</p><p>where indices 1/2 correspond to the remaining/truncated states respectively.</p><p>See also <code>gram</code>, <code>balreal</code></p><p>Glad, Ljung, Reglerteori: Flervariabla och Olinjära metoder</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L521-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bode-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.bode-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bode</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>mag, phase, w = bode(sys[, w])</code></p><p>Compute the magnitude and phase parts of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>mag</code> and <code>phase</code> has size <code>(length(w), ny, nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodeplot" href="#ControlSystems.bodeplot"><code>ControlSystems.bodeplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig = bodeplot(sys, args...)
bodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, kwargs...)</code></pre><p>Create a Bode plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided. To change the Magnitude scale see <code>setPlotScale(str)</code></p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to RecipesBase.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.bodev-Tuple{LTISystem}" href="#ControlSystems.bodev-Tuple{LTISystem}"><code>ControlSystems.bodev</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>bodev(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d" href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd = c2d(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)
Gd = c2d(G::TransferFunction{&lt;:Continuous}, Ts, method=:zoh)</code></pre><p>Convert the continuous-time system <code>sys</code> into a discrete-time system with sample time <code>Ts</code>, using the specified <code>method</code> (:<code>zoh</code>, <code>:foh</code>, <code>:fwdeuler</code> or <code>:tustin</code>). Note that the forward-Euler method generally requires the sample time to be very small relative to the time constants of the system.</p><p><code>method = :tustin</code> performs a bilinear transform with prewarp frequency <code>w_prewarp</code>.</p><ul><li><code>w_prewarp</code>: Frequency (rad/s) for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul><p>See also <code>c2d_x0map</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d" href="#ControlSystems.c2d"><code>ControlSystems.c2d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">c2d(G::DelayLtiSystem, Ts, method=:zoh)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/delay_systems.jl#L55-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_poly2poly-Tuple{Any, Any}" href="#ControlSystems.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_poly2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_poly2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_roots2poly-Tuple{Any, Any}" href="#ControlSystems.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystems.c2d_roots2poly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">c2d_roots2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.c2d_x0map" href="#ControlSystems.c2d_x0map"><code>ControlSystems.c2d_x0map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysd, x0map = c2d_x0map(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)</code></pre><p>Returns the discretization <code>sysd</code> of the system <code>sys</code> and a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p><p>See <code>c2d</code> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.care-NTuple{4, Any}" href="#ControlSystems.care-NTuple{4, Any}"><code>ControlSystems.care</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>care(A, B, Q, R)</code></p><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>Uses <code>MatrixEquations.arec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.covar-Tuple{AbstractStateSpace, Any}" href="#ControlSystems.covar-Tuple{AbstractStateSpace, Any}"><code>ControlSystems.covar</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>P = covar(sys, W)</code></p><p>Calculate the stationary covariance <code>P = E[y(t)y(t)&#39;]</code> of the output <code>y</code> of a <code>StateSpace</code> model <code>sys</code> driven by white Gaussian noise <code>w</code> with covariance <code>E[w(t)w(τ)]=W*δ(t-τ)</code> (δ is the Dirac delta).</p><p>Remark: If <code>sys</code> is unstable then the resulting covariance is a matrix of <code>Inf</code>s. Entries corresponding to direct feedthrough (D<em>W</em>D&#39; .!= 0) will equal <code>Inf</code> for continuous-time systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L132-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}" href="#ControlSystems.ctrb-Tuple{AbstractMatrix, AbstractMatrix}"><code>ControlSystems.ctrb</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ctrb(A, B)</code> or <code>ctrb(sys)</code></p><p>Compute the controllability matrix for the system described by <code>(A, B)</code> or <code>sys</code>.</p><p>Note that checking for controllability by computing the rank from <code>ctrb</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :c)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.d2c" href="#ControlSystems.d2c"><code>ControlSystems.d2c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">d2c(sys::AbstractStateSpace{&lt;:Discrete}, method::Symbol = :zoh; w_prewarp=0)</code></pre><p>Convert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using <code>method</code>. Available methods are `:zoh, :fwdeuler´.</p><ul><li><code>w_prewarp</code>: Frequency for pre-warping when usingthe Tustin method, has no effect for other methods.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dab-Tuple{Any, Any, Any}" href="#ControlSystems.dab-Tuple{Any, Any, Any}"><code>ControlSystems.dab</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X,Y = dab(A,B,C)</code></pre><p>DAB   Solves the Diophantine-Aryabhatta-Bezout identity</p><p>AX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L174-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.damp-Tuple{LTISystem}" href="#ControlSystems.damp-Tuple{LTISystem}"><code>ControlSystems.damp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wn, zeta, ps = damp(sys)</code></pre><p>Compute the natural frequencies, <code>Wn</code>, and damping ratios, <code>zeta</code>, of the poles, <code>ps</code>, of <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dampreport-Tuple{IO, LTISystem}" href="#ControlSystems.dampreport-Tuple{IO, LTISystem}"><code>ControlSystems.dampreport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dampreport(sys)</code></pre><p>Display a report of the poles, damping ratio, natural frequency, and time constant of the system <code>sys</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dare-NTuple{4, Any}" href="#ControlSystems.dare-NTuple{4, Any}"><code>ControlSystems.dare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dare(A, B, Q, R; kwargs...)</code></pre><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where Q&gt;=0 and R&gt;0</p><p>Uses <code>MatrixEquations.ared</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.ared</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dcgain" href="#ControlSystems.dcgain"><code>ControlSystems.dcgain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dcgain(sys, ϵ=0)</code></pre><p>Compute the dcgain of system <code>sys</code>.</p><p>equal to G(0) for continuous-time systems and G(1) for discrete-time systems.</p><p><code>ϵ</code> can be provided to evaluate the dcgain with a small perturbation into the stability region of the complex plane.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.delaymargin-Tuple{LTISystem}" href="#ControlSystems.delaymargin-Tuple{LTISystem}"><code>ControlSystems.delaymargin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dₘ = delaymargin(G::LTISystem)</code></pre><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L531-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.diagonalize-Tuple{AbstractStateSpace}" href="#ControlSystems.diagonalize-Tuple{AbstractStateSpace}"><code>ControlSystems.diagonalize</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>dsys = diagonalize(s::StateSpace, digits=12)</code> Diagonalizes the system such that the A-matrix is diagonal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/StateSpace.jl#L441-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dkalman-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.dkalman-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.dkalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dkalman(A, C, R1, R2)
dkalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain for discrete time systems</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.ared</code> for more help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/synthesis.jl#L117-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dlqr-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.dlqr-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.dlqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dlqr(A, B, Q, R, args...; kwargs...)
dlqr(sys, Q, R, args...; kwargs...)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u[k] = -K*x[k]</code> that minimizes the cost function:</p><p>J = sum(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the discrte time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>See also <code>lqg</code></p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.ared</code> for more help.</p><p>Usage example:</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
Ts = 0.1
A = [1 Ts; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0, Ts)
Q = I
R = I
L = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:Ts:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot;  &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/synthesis.jl#L72-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.dlyap-Tuple{AbstractMatrix, Any}" href="#ControlSystems.dlyap-Tuple{AbstractMatrix, Any}"><code>ControlSystems.dlyap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dlyap(A, Q; kwargs...)</code></pre><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p><p>Uses <code>MatrixEquations.lyapd</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.lyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L28-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}" href="#ControlSystems.evalfr-Tuple{AbstractStateSpace, Number}"><code>ControlSystems.evalfr</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>evalfr(sys, x)</code> Evaluate the transfer function of the LTI system sys at the complex number s=x (continuous-time) or z=x (discrete-time).</p><p>For many values of <code>x</code>, use <code>freqresp</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}" href="#ControlSystems.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><em>Basic use</em> <code>feedback(sys1, sys2)</code> forms the feedback interconnection</p><pre><code class="language-julia hljs">           ┌──────────────┐
◄──────────┤     sys1     │◄──── Σ ◄──────
    │      │              │      │
    │      └──────────────┘      -1
    │                            |
    │      ┌──────────────┐      │
    └─────►│     sys2     ├──────┘
           │              │
           └──────────────┘</code></pre><p><em>Advanced use</em> <code>feedback</code> also supports more flexible use according to the figure below</p><pre><code class="language-julia hljs">              ┌──────────────┐
      z1◄─────┤     sys1     │◄──────w1
 ┌─── y1◄─────┤              │◄──────u1 ◄─┐
 │            └──────────────┘            │
 │                                        α
 │            ┌──────────────┐            │
 └──► u2─────►│     sys2     ├───────►y2──┘
      w2─────►│              ├───────►z2
              └──────────────┘</code></pre><p><code>U1</code>, <code>W1</code> specifies the indices of the input signals of <code>sys1</code> corresponding to <code>u1</code> and <code>w1</code> <code>Y1</code>, <code>Z1</code> specifies the indices of the output signals of <code>sys1</code> corresponding to <code>y1</code> and <code>z1</code> <code>U2</code>, <code>W2</code>, <code>Y2</code>, <code>Z2</code> specifies the corresponding signals of <code>sys2</code> </p><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.</p><p>Negative feedback (α = -1) is the default. Specify <code>pos_feedback=true</code> for positive feedback (α = 1).</p><p>See also <code>lft</code>, <code>starprod</code>.</p><p>See Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L210-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback-Tuple{TransferFunction}" href="#ControlSystems.feedback-Tuple{TransferFunction}"><code>ControlSystems.feedback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback(sys)
feedback(sys1, sys2)</code></pre><p>For a general LTI-system, <code>feedback</code> forms the negative feedback interconnection</p><pre><code class="language-julia hljs">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L154-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}" href="#ControlSystems.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denomenator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L330-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE" href="#ControlSystems.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystems.feedback2dof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)</code></pre><p>Return the transfer function <code>P(F+C)/(1+PC)</code> which is the closed-loop system with process <code>P</code>, controller <code>C</code> and feedforward filter <code>F</code> from reference to control signal (by-passing <code>C</code>).</p><pre><code class="nohighlight hljs">         +-------+
         |       |
   +-----&gt;   F   +----+
   |     |       |    |
   |     +-------+    |
   |     +-------+    |    +-------+
r  |  -  |       |    |    |       |    y
+--+-----&gt;   C   +----+----&gt;   P   +---+--&gt;
      |  |       |         |       |   |
      |  +-------+         +-------+   |
      |                                |
      +--------------------------------+</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L344-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqresp-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystems.freqresp-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqresp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sys_fr = freqresp(sys, w)</code></pre><p>Evaluate the frequency response of a linear system</p><p><code>w -&gt; C*((iw*im -A)^-1)*B + D</code></p><p>of system <code>sys</code> over the frequency vector <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L11-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystems.freqrespv-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(sys::LTISystem, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.freqrespv-Union{Tuple{var&quot;#266#W&quot;}, Tuple{AbstractStateSpace, AbstractVector{var&quot;#266#W&quot;}}} where var&quot;#266#W&quot;&lt;:Real" href="#ControlSystems.freqrespv-Union{Tuple{var&quot;#266#W&quot;}, Tuple{AbstractStateSpace, AbstractVector{var&quot;#266#W&quot;}}} where var&quot;#266#W&quot;&lt;:Real"><code>ControlSystems.freqrespv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>freqrespv(sys::AbstractStateSpace, w_vec::AbstractVector{W}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}" href="#ControlSystems.gangoffour-Tuple{LTISystem, LTISystem}"><code>ControlSystems.gangoffour</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T = gangoffour(P, C; minimal=true)
gangoffour(P::AbstractVector, C::AbstractVector; minimal=true)</code></pre><p>Given a transfer function describing the plant <code>P</code> and a transfer function describing the controller <code>C</code>, computes the four transfer functions in the Gang-of-Four.</p><ul><li><code>S = 1/(1+PC)</code> Sensitivity function</li><li><code>PS = P/(1+PC)</code> Load disturbance to measurement signal</li><li><code>CS = C/(1+PC)</code> Measurement noise to control signal</li><li><code>T = PC/(1+PC)</code> Complementary sensitivity function</li></ul><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L559-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangoffourplot-Tuple{Union{LTISystem, Vector}, Vector, Vararg{Any}}" href="#ControlSystems.gangoffourplot-Tuple{Union{LTISystem, Vector}, Vector, Vararg{Any}}"><code>ControlSystems.gangoffourplot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fig = gangoffourplot(P::LTISystem, C::LTISystem; minimal=true, plotphase=false, kwargs...)
gangoffourplot(P::Union{Vector, LTISystem}, C::Vector; minimal=true, plotphase=false, kwargs...)</code></pre><p>Gang-of-Four plot. <code>kwargs</code> is sent as argument to RecipesBase.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L734-L739">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}" href="#ControlSystems.gangofseven-Tuple{TransferFunction, TransferFunction, TransferFunction}"><code>ControlSystems.gangofseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S, PS, CS, T, RY, RU, RE = gangofseven(P,C,F)</code></pre><p>Given transfer functions describing the Plant <code>P</code>, the controller <code>C</code> and a feed forward block <code>F</code>, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.</p><p><code>S = 1/(1+PC)</code> Sensitivity function</p><p><code>PS = P/(1+PC)</code></p><p><code>CS = C/(1+PC)</code></p><p><code>T = PC/(1+PC)</code> Complementary sensitivity function</p><p><code>RY = PCF/(1+PC)</code></p><p><code>RU = CF/(1+P*C)</code></p><p><code>RE = F/(1+P*C)</code></p><p>Only supports SISO systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L584-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystems.gram-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.gram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gram(sys, opt; kwargs...)</code></pre><p>Compute the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian. If <code>opt</code> is <code>:o</code>, computes the observability grammian.</p><p>See also <a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a> For keyword arguments, see <a href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>grampd</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L67-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}" href="#ControlSystems.grampd-Tuple{AbstractStateSpace, Symbol}"><code>ControlSystems.grampd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U = grampd(sys, opt; kwargs...)</code></pre><p>Return a Cholesky factor <code>U</code> of the grammian of system <code>sys</code>. If <code>opt</code> is <code>:c</code>, computes the controllability grammian <code>G = U*U&#39;</code>. If <code>opt</code> is <code>:o</code>, computes the observability grammian <code>G = U&#39;U</code>.</p><p>Obtain a <code>Cholesky</code> object by <code>Cholesky(U)</code> for observability grammian</p><p>Uses <code>MatrixEquations.plyapc/plyapd</code>. For keyword arguments, see the docstring of <code>ControlSystems.MatrixEquations.plyapc/plyapd</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}" href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>ControlSystems.hinfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(Ninf, ω_peak) = hinfnorm(sys; tol=1e-6)</code></p><p>Compute the H∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain Ninf is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code>  if <code>G</code> is stable (σ_max = largest singular value)       :=        <code>Inf&#39;           if</code>G` is unstable</p><p><code>tol</code> is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>linfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L208-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}" href="#ControlSystems.impulse-Tuple{AbstractStateSpace, AbstractVector}"><code>ControlSystems.impulse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">y, t, x = impulse(sys[, tfinal])
y, t, x = impulse(sys[, t])</code></pre><p>Calculate the impulse response of system <code>sys</code>. If the final time <code>tfinal</code> or time vector <code>t</code> is not provided, one is calculated based on the system pole locations.</p><p><code>y</code> has size <code>(ny, length(t), nu)</code>, <code>x</code> has size <code>(nx, length(t), nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/timeresp.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.innovation_form</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sysi = innovation_form(sys, R1, R2)
sysi = innovation_form(sys; sysw=I, syse=I, R1=I, R2=I)</code></pre><p>Takes a system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Bu + w ~ R1
y  = Cx + e ~ R2</code></pre><p>and returns the system</p><pre><code class="nohighlight hljs">x&#39; = Ax + Kv
y  = Cx + v</code></pre><p>where <code>v</code> is the innovation sequence.</p><p>If <code>sysw</code> (<code>syse</code>) is given, the covariance resulting in filtering noise with <code>R1</code> (<code>R2</code>) through <code>sysw</code> (<code>syse</code>) is used as covariance.</p><p>See Stochastic Control, Chapter 4, Åström</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L617-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.iscontinuous-Tuple{LTISystem}" href="#ControlSystems.iscontinuous-Tuple{LTISystem}"><code>ControlSystems.iscontinuous</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>iscontinuous(sys)</code></p><p>Returns <code>true</code> for a continuous-time system <code>sys</code>, else returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/Lti.jl#L50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.isdiscrete-Tuple{LTISystem}" href="#ControlSystems.isdiscrete-Tuple{LTISystem}"><code>ControlSystems.isdiscrete</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isdiscrete(sys)</code></p><p>Returns <code>true</code> for a discrete-time system <code>sys</code>, else returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/Lti.jl#L54-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.isproper-Tuple{TransferFunction}" href="#ControlSystems.isproper-Tuple{TransferFunction}"><code>ControlSystems.isproper</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isproper(tf)</code></p><p>Returns <code>true</code> if the <code>TransferFunction</code> is proper. This means that order(den)</p><blockquote><p>= order(num))</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/TransferFunction.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.isstable-Tuple{LTISystem}" href="#ControlSystems.isstable-Tuple{LTISystem}"><code>ControlSystems.isstable</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>isstable(sys)</code></p><p>Returns <code>true</code> if <code>sys</code> is stable, else returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/Lti.jl#L83-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.kalman-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.kalman-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.kalman</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kalman(A, C, R1, R2)
kalman(sys, R1, R2)</code></pre><p>Calculate the optimal Kalman gain</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec/ared</code> for more help.</p><p>See also <code>LQG</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/synthesis.jl#L43-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.laglink-Tuple{Any, Any}" href="#ControlSystems.laglink-Tuple{Any, Any}"><code>ControlSystems.laglink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">laglink(a, M; Ts=0)</code></pre><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L162-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlink-Tuple{Any, Any, Any}" href="#ControlSystems.leadlink-Tuple{Any, Any, Any}"><code>ControlSystems.leadlink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leadlink(b, N, K; Ts=0)</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L181-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkat-Tuple{Any, Any, Any}" href="#ControlSystems.leadlinkat-Tuple{Any, Any, Any}"><code>ControlSystems.leadlinkat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leadlinkat(ω, N, K; Ts=0)</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L206-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.leadlinkcurve" href="#ControlSystems.leadlinkcurve"><code>ControlSystems.leadlinkcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>leadlinkcurve(start=1)</p><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link) If an input argument <code>s</code> is given, the curve is plotted from <code>s</code> to 10, else from 1 to 10.</p><p>See also <code>Leadlink, leadlinkat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L226-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lft" href="#ControlSystems.lft"><code>ControlSystems.lft</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lft(G, Δ, type=:l)</code></pre><p>Lower and upper linear fractional transformation between systems <code>G</code> and <code>Δ</code>.</p><p>Specify <code>:l</code> lor lower LFT, and <code>:u</code> for upper LFT.</p><p><code>G</code> must have more inputs and outputs than <code>Δ</code> has outputs and inputs.</p><p>For details, see Chapter 9.1 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L376-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.linfnorm-Tuple{AbstractStateSpace}" href="#ControlSystems.linfnorm-Tuple{AbstractStateSpace}"><code>ControlSystems.linfnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>(Ninf, ω_peak) = linfnorm(sys; tol=1e-6)</code></p><p>Compute the L∞ norm <code>Ninf</code> of the LTI system <code>sys</code>, together with a frequency <code>ω_peak</code> at which the gain <code>Ninf</code> is achieved.</p><p><code>Ninf := sup_ω σ_max[sys(iω)]</code> (σ_max denotes the largest singular value)</p><p><code>tol</code> is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a state space model if needed.</p><p>The continuous-time L∞ norm computation implements the &#39;two-step algorithm&#39; in:<br/><strong>N.A. Bruinsma and M. Steinbuch</strong>, &#39;A fast algorithm to compute the H∞-norm of a transfer function matrix&#39;, Systems and Control Letters (1990), pp. 287-293.</p><p>For the discrete-time version, see:<br/><strong>P. Bongers, O. Bosgra, M. Steinbuch</strong>, &#39;L∞-norm calculation for generalized state space systems in continuous and discrete time&#39;, American Control Conference, 1991.</p><p>See also <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L236-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.loopshapingPI-Tuple{Any, Any}" href="#ControlSystems.loopshapingPI-Tuple{Any, Any}"><code>ControlSystems.loopshapingPI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kp,ki,C = loopshapingPI(P,ωp; ϕl,rl, phasemargin, doplot = false)</code></pre><p>Selects the parameters of a PI-controller such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>If <code>phasemargin</code> is supplied, <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><p>Set <code>doplot = true</code> to plot the <code>gangoffourplot</code> and <code>nyquistplot</code> of the system.</p><p>See also <code>pidplots</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L279-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lqr-Tuple{Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystems.lqr-Tuple{Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystems.lqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lqr(A, B, Q, R, args...; kwargs...)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = -K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the continuous time model <code>dx = Ax + Bu</code>.</p><p><code>lqr(sys, Q, R)</code></p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec</code> for more help.</p><p>See also <code>LQG</code> Usage example:</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/synthesis.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}" href="#ControlSystems.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>ControlSystems.lsim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">result = lsim(sys, u[, t]; x0, method])
result = lsim(sys, u::Function, t; x0, method)</code></pre><p>Calculate the time response of system <code>sys</code> to input <code>u</code>. If <code>x0</code> is ommitted, a zero vector is used.</p><p>The result structure contains the fields <code>y, t, x, u</code> and can be destructured automatically by iteration, e.g.,</p><pre><code class="language-julia hljs">y, t, x, u = result</code></pre><p><code>y</code>, <code>x</code>, <code>u</code> have time in the second dimension. Initial state <code>x0</code> defaults to zero.</p><p>Continuous time systems are simulated using an ODE solver if <code>u</code> is a function. If <code>u</code> is an array, the system is discretized (with <code>method=:zoh</code> by default) before simulation. For a lower level inteface, see <code>?Simulator</code> and <code>?solve</code></p><p><code>u</code> can be a function or a matrix/vector of precalculated control signals. If <code>u</code> is a function, then <code>u(x,i)</code> (<code>u(x,t)</code>) is called to calculate the control signal every iteration (time instance used by solver). This can be used to provide a control law such as state feedback <code>u(x,t) = -L*x</code> calculated by <code>lqr</code>. To simulate a unit step, use <code>(x,i)-&gt; 1</code>, for a ramp, use <code>(x,i)-&gt; i*Ts</code>, for a step at <code>t=5</code>, use (x,i)-&gt; (i*Ts &gt;= 5) etc.</p><p>Usage example:</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots

A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/timeresp.jl#L77-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.lsim-Union{Tuple{S}, Tuple{T}, Tuple{DelayLtiSystem{T, S}, Any, AbstractArray{&lt;:Real}}} where {T, S}" href="#ControlSystems.lsim-Union{Tuple{S}, Tuple{T}, Tuple{DelayLtiSystem{T, S}, Any, AbstractArray{&lt;:Real}}} where {T, S}"><code>ControlSystems.lsim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`y, t, x = lsim(sys::DelayLtiSystem, u, t::AbstractArray{&lt;:Real}; x0=fill(0.0, nstates(sys)), alg=MethodOfSteps(Tsit5()), abstol=1e-6, reltol=1e-6, kwargs...)`

Simulate system `sys`, over time `t`, using input signal `u`, with initial state `x0`, using method `alg` .

Arguments:

`t`: Has to be an `AbstractVector` with equidistant time samples (`t[i] - t[i-1]` constant)
`u`: Function to determine control signal `ut` at a time `t`, on any of the following forms:
    Can be a constant `Number` or `Vector`, interpreted as `ut .= u` , or
    Function `ut .= u(t)`, or
    In-place function `u(ut, t)`. (Slightly more effienct)
`alg, abstol, reltol` and `kwargs...`: are sent to `DelayDiffEq.solve`.

Returns: times `t`, and `y` and `x` at those times.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/delay_systems.jl#L68-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}" href="#ControlSystems.margin-Tuple{LTISystem, AbstractVector{&lt;:Real}}"><code>ControlSystems.margin</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>ωgₘ, gₘ, ωϕₘ, ϕₘ = margin{S&lt;:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)</code></p><p>returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins</p><p>If <code>!allMargins</code>, return only the smallest margin</p><p>If <code>full</code> return also <code>fullPhase</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}" href="#ControlSystems.markovparam-Tuple{AbstractStateSpace, Integer}"><code>ControlSystems.markovparam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">markovparam(sys, n)</code></pre><p>Compute the <code>n</code>th markov parameter of state-space system <code>sys</code>. This is defined as the following:</p><p><code>h(0) = D</code></p><p><code>h(n) = C*A^(n-1)*B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.minreal" href="#ControlSystems.minreal"><code>ControlSystems.minreal</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>tf = minreal(tf::TransferFunction, eps=sqrt(eps()))</code></p><p>Create a minimial representation of each transfer function in <code>tf</code> by cancelling poles and zeros will promote system to an appropriate numeric type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/TransferFunction.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.minreal-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractStateSpace" href="#ControlSystems.minreal-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:AbstractStateSpace"><code>ControlSystems.minreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minreal(sys::T; fast=false, kwargs...)</code></pre><p>Minimal realisation algorithm from P. Van Dooreen, The generalized eigenstructure problem in linear system theory, IEEE Transactions on Automatic Control</p><p>For information about the options, see <code>?ControlSystems.MatrixPencils.lsminreal</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/StateSpace.jl#L423-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nicholsplot" href="#ControlSystems.nicholsplot"><code>ControlSystems.nicholsplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig = nicholsplot{T&lt;:LTISystem}(systems::Vector{T}, w::AbstractVector; kwargs...)</code></pre><p>Create a Nichols plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p>Keyword arguments:</p><pre><code class="nohighlight hljs">text = true
Gains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]
pInc = 30
sat = 0.4
val = 0.85
fontsize = 10</code></pre><p><code>pInc</code> determines the increment in degrees between phase lines.</p><p><code>sat</code> ∈ [0,1] determines the saturation of the gain lines</p><p><code>val</code> ∈ [0,1] determines the brightness of the gain lines</p><p>Additional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular RecipesBase.jl syntax</p><p>This function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L360-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.nyquist-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquist</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>re, im, w = nyquist(sys[, w])</code></p><p>Compute the real and imaginary parts of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>re</code> and <code>im</code> has size <code>(length(w), ny, nu)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L165-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistplot" href="#ControlSystems.nyquistplot"><code>ControlSystems.nyquistplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig = nyquistplot(sys; Ms_circles=Float64[], unit_circle=false, hz = false, kwargs...)
nyquistplot(LTISystem[sys1, sys2...]; Ms_circles=Float64[], unit_circle=false, kwargs...)</code></pre><p>Create a Nyquist plot of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><ul><li><code>unit_circle</code>: if the unit circle should be displayed</li><li><code>Ms_circles</code>: draw circles corresponding to given levels of sensitivity (circles around -1 with  radii <code>1/Ms</code>). <code>Ms_circles</code> can be supplied as a number or a vector of numbers. A design staying outside such a circle has a phase margin of at least <code>2asin(1/(2Ms))</code> rad and a gain margin of at least <code>Ms/(Ms-1)</code>.</li></ul><p>If <code>hz=true</code>, the hover information will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L276-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.nyquistv-Tuple{LTISystem}" href="#ControlSystems.nyquistv-Tuple{LTISystem}"><code>ControlSystems.nyquistv</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>nyquistv(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}" href="#ControlSystems.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>ControlSystems.observer_controller</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cont = observer_controller(sys, L::AbstractMatrix, K::AbstractMatrix)</code></pre><p>Return the observer_controller <code>cont</code> that is given by <code>ss(A - B*L - K*C + K*D*L, K, L, 0)</code></p><p>Such that <code>feedback(sys, cont)</code> produces a closed-loop system with eigenvalues given by <code>A-KC</code> and <code>A-BL</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>sys</code>: Model of system</li><li><code>L</code>: State-feedback gain <code>u = -Lx</code></li><li><code>K</code>: Observer gain</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L670-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.observer_predictor-Union{Tuple{ST}, Tuple{ST, Any, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.observer_predictor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">observer_predictor(sys::AbstractStateSpace, R1, R2)
observer_predictor(sys::AbstractStateSpace, K)</code></pre><p>Return the observer_predictor system x̂&#39; = (A - KC)x̂ + (B-KD)u + Ky ŷ  = Cx + Du with the input equation [B K] * [u; y]</p><p>If covariance matrices <code>R1, R2</code> are given, the kalman gain <code>K</code> is calculaded.</p><p>See also <code>innovation_form</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L647-L659">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.obsv" href="#ControlSystems.obsv"><code>ControlSystems.obsv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">obsv(A, C, n=size(A,1))
obsv(sys, n=sys.nx)</code></pre><p>Compute the observability matrix with <code>n</code> rows for the system described by <code>(A, C)</code> or <code>sys</code>. Providing the optional <code>n &gt; sys.nx</code> returns an extended observability matrix.</p><p>Note that checking for observability by computing the rank from <code>obsv</code> is not the most numerically accurate way, a better method is checking if <code>gram(sys, :o)</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pade-Tuple{DelayLtiSystem, Any}" href="#ControlSystems.pade-Tuple{DelayLtiSystem, Any}"><code>ControlSystems.pade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pade(G::DelayLtiSystem, N)</code></pre><p>Approximate all time-delays in <code>G</code> by Padé approximations of degree <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/delay_systems.jl#L329-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pade-Tuple{Real, Int64}" href="#ControlSystems.pade-Tuple{Real, Int64}"><code>ControlSystems.pade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pade(τ::Real, N::Int)</code></pre><p>Compute the <code>N</code>th order Padé approximation of a time-delay of length <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/delay_systems.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.parallel-Tuple{LTISystem, LTISystem}" href="#ControlSystems.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystems.parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pid-Tuple{}" href="#ControlSystems.pid-Tuple{}"><code>ControlSystems.pid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">C = pid(; kp=0, ki=0; kd=0, time=false, series=false)</code></pre><p>Calculates and returns a PID controller on transfer function form.</p><ul><li><code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants</li><li><code>series</code> indicates  whether or not the series form or parallel form (default) is desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}" href="#ControlSystems.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystems.pidplots</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pidplots(P, args...; kps=0, kis=0, kds=0, time=false, series=false, ω=0)</code></pre><p>Plots interesting figures related to closing the loop around process <code>P</code> with a PID controller Send in a bunch of PID-parameters in any of the vectors kp, ki, kd. The vectors must be the same length.</p><p>-<code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants -<code>series</code> indicates  whether or not the series form or parallel form (default) is desired</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps</p><p>One can also supply a frequency vector ω to be used in Bode and Nyquist plots</p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L19-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.place" href="#ControlSystems.place"><code>ControlSystems.place</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">place(A, B, p, opt=:c)
place(sys::StateSpace, p, opt=:c)</code></pre><p>Calculate the gain matrix <code>K</code> such that <code>A - BK</code> has eigenvalues <code>p</code>.</p><pre><code class="nohighlight hljs">place(A, C, p, opt=:o)
place(sys::StateSpace, p, opt=:o)</code></pre><p>Calculate the observer gain matrix <code>L</code> such that <code>A - LC</code> has eigenvalues <code>p</code>.</p><p>Uses Ackermann&#39;s formula. Currently handles only SISO systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/synthesis.jl#L127-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.placePI-Tuple{Any, Any, Any}" href="#ControlSystems.placePI-Tuple{Any, Any, Any}"><code>ControlSystems.placePI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">piparams, C = placePI(P, ω₀, ζ; form=:standard)</code></pre><p>Selects the parameters of a PI-controller such that the poles of  closed loop between <code>P</code> and <code>C</code> are placed to match the poles of  <code>s^2 + 2ζω₀s + ω₀^2</code>.</p><p>The <code>form</code> keyword allows you to choose which form the PI parameters should be returned on. </p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/Ti/s)</code></li><li><code>:series</code> - <code>Kc*(1 + 1/τi/s)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s</code></li><li><code>:Ti</code> - <code>Kp + 1/(s*Ti)</code>   (non-standard form sometimes used in industry)</li></ul><p><code>piparams</code> is a named tuple with the controller parameters.</p><p><code>C</code> is the transfer function of the controller.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L316-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.poles-Tuple{AbstractStateSpace}" href="#ControlSystems.poles-Tuple{AbstractStateSpace}"><code>ControlSystems.poles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">poles(sys)</code></pre><p>Compute the poles of system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.prescale-Tuple{AbstractStateSpace}" href="#ControlSystems.prescale-Tuple{AbstractStateSpace}"><code>ControlSystems.prescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syst, S = prescale(sys)</code></pre><p>Perform a eigendecomposition on system state-transition matrix <code>sys.A</code>.</p><pre><code class="nohighlight hljs">Ã = S⁻¹AS
B̃ = S⁻¹ B
C̃ = CS
D̃ = D</code></pre><p>Such that <code>Ã</code> is diagonal. Returns a new scaled state-space object and the associated transformation matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L595-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.pzmap" href="#ControlSystems.pzmap"><code>ControlSystems.pzmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig = pzmap(fig, system, args...; kwargs...)</code></pre><p>Create a pole-zero map of the <code>LTISystem</code>(s) in figure <code>fig</code>, <code>args</code> and <code>kwargs</code> will be sent to the <code>scatter</code> plot command.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L685-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}" href="#ControlSystems.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}"><code>ControlSystems.reduce_sys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L257-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.relative_gain_array-Tuple{AbstractMatrix}" href="#ControlSystems.relative_gain_array-Tuple{AbstractMatrix}"><code>ControlSystems.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(A::AbstractMatrix; tol = 1.0e-15)</code></pre><p>Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L360-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}" href="#ControlSystems.relative_gain_array-Tuple{Any, AbstractVector}"><code>ControlSystems.relative_gain_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">relative_gain_array(G, w::AbstractVector)
relative_gain_array(G, w::Number)</code></pre><p>Calculate the relative gain array of <code>G</code> at frequencies <code>w</code>.  G(iω) .* pinv(tranpose(G(iω)))</p><p>The RGA can be used to find input-output pairings for MIMO control using individially tuned loops. Pair the inputs and outputs such that the RGA(ωc) at the crossover frequency becomes as close to diagonal as possible. Avoid pairings such that RGA(0) contains negative diagonal elements. </p><ul><li>The sum of the absolute values of the entries in the RGA is a good measure of the &quot;true condition number&quot; of G, the best condition number that can be achieved by input/output scaling of <code>G</code>, -Glad, Ljung.</li><li>The RGA is invariant to input/output scaling of <code>G</code>.</li><li>If the RGA contains large entries, the system may be sensitive to model errors, -Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;:<ul><li>Uncertainty in the input channels (diagonal input uncertainty). Plants with</li></ul>large RGA-elements around the crossover frequency are fundamentally   difficult to control because of sensitivity to input uncertainty (e.g. caused   by uncertain or neglected actuator dynamics). In particular, decouplers or   other inverse-based controllers should not be used for plants with large RGAeleme<ul><li>Element uncertainty. Large RGA-elements imply sensitivity to element-by-element uncertainty.</li></ul>However, this kind of uncertainty may not occur in practice due to physical couplings   between the transfer function elements. Therefore, diagonal input uncertainty   (which is always present) is usually of more concern for plants with large RGAelemen</li></ul><p>The relative gain array is computed using the The unit-consistent (UC) generalized inverse Reference: &quot;On the Relative Gain Array (RGA) with Singular and Rectangular Matrices&quot; Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L327-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rgaplot" href="#ControlSystems.rgaplot"><code>ControlSystems.rgaplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rgaplot(sys, args...; hz=false)
rgaplot(LTISystem[sys1, sys2...], args...; hz=false)</code></pre><p>Plot the relative-gain array entries of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L761-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rlocusplot" href="#ControlSystems.rlocusplot"><code>ControlSystems.rlocusplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rlocusplot(P::LTISystem, K)</code></pre><p>Computes and plots the root locus of the SISO LTISystem P with a negative feedback loop and feedback gains <code>K</code>, if <code>K</code> is not provided, range(1e-6,stop=500,length=10000) is used. If <code>OrdinaryDiffEq.jl</code> is installed and loaded by the user (<code>using OrdinaryDiffEq</code>), <code>rlocusplot</code> will use an adaptive step-size algorithm to select values of <code>K</code>. A scalar <code>Kmax</code> can then be given as second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L115-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstc-Tuple" href="#ControlSystems.rstc-Tuple"><code>ControlSystems.rstc</code></a> — <span class="docstring-category">Method</span></header><section><div><p>See ?rstd for the discerte case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L137-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.rstd-Tuple" href="#ControlSystems.rstd-Tuple"><code>ControlSystems.rstd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)
R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)
R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></pre><p>rstd  Polynomial synthesis in discrete time.</p><p>Polynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)</p><p>Inputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]</p><p>Outputs: R,S,T  : Polynomials in controller</p><p>See function <code>dab</code> how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L142-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.series-Tuple{LTISystem, LTISystem}" href="#ControlSystems.series-Tuple{LTISystem, LTISystem}"><code>ControlSystems.series</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.setPlotScale-Tuple{AbstractString}" href="#ControlSystems.setPlotScale-Tuple{AbstractString}"><code>ControlSystems.setPlotScale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setPlotScale(str)</code></pre><p>Set the default scale of magnitude in <code>bodeplot</code> and <code>sigmaplot</code>. <code>str</code> should be either <code>&quot;dB&quot;</code> or <code>&quot;log10&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigma-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.sigma-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigma</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sv, w = sigma(sys[, w])</code></p><p>Compute the singular values <code>sv</code> of the frequency response of system <code>sys</code> at frequencies <code>w</code></p><p><code>sv</code> has size <code>(length(w), max(ny, nu))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/freqresp.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmaplot" href="#ControlSystems.sigmaplot"><code>ControlSystems.sigmaplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sigmaplot(sys, args...; hz=false)
sigmaplot(LTISystem[sys1, sys2...], args...; hz=false)</code></pre><p>Plot the singular values of the frequency response of the <code>LTISystem</code>(s). A frequency vector <code>w</code> can be optionally provided.</p><p>If <code>hz=true</code>, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.</p><p><code>kwargs</code> is sent as argument to Plots.plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/plotting.jl#L526-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}" href="#ControlSystems.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sigmav-Tuple{LTISystem}" href="#ControlSystems.sigmav-Tuple{LTISystem}"><code>ControlSystems.sigmav</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sigmav(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/utilities.jl#L177-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace" href="#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST&lt;:AbstractStateSpace"><code>ControlSystems.similarity_transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">syst = similarity_transform(sys, T)</code></pre><p>Perform a similarity transform <code>T : Tx̃ = x</code> on <code>sys</code> such that</p><pre><code class="nohighlight hljs">Ã = T⁻¹AT
B̃ = T⁻¹ B
C̃ = CT
D̃ = D</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L576-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.sminreal-Tuple{StateSpace}" href="#ControlSystems.sminreal-Tuple{StateSpace}"><code>ControlSystems.sminreal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p><p>Systems with numerical noise in the coefficients, e.g., noise on the order of <code>eps</code> require truncation to zero to be affected by structural simplification, e.g.,</p><pre><code class="language-julia hljs">trunc_zero!(A) = A[abs.(A) .&lt; 10eps(maximum(abs, A))] .= 0
trunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)
sminreal(sys)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/simplification.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ss-Tuple" href="#ControlSystems.ss-Tuple"><code>ControlSystems.ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`sys = ss(A, B, C, D [,Ts])`</code></pre><p>Create a state-space model <code>sys::StateSpace{TE, T}</code> with matrix element type <code>T</code> and TE is <code>Continuous</code> or <code>&lt;:Discrete</code>.</p><p>This is a continuous-time model if <code>Ts</code> is omitted. Otherwise, this is a discrete-time model with sampling period <code>Ts</code>.</p><p><code>sys = ss(D [, Ts])</code> specifies a static gain matrix <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/StateSpace.jl#L115-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ssdata-Tuple{AbstractStateSpace}" href="#ControlSystems.ssdata-Tuple{AbstractStateSpace}"><code>ControlSystems.ssdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`A, B, C, D = ssdata(sys)`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/StateSpace.jl#L197-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.ssrand-Tuple{Type, Int64, Int64, Int64}" href="#ControlSystems.ssrand-Tuple{Type, Int64, Int64, Int64}"><code>ControlSystems.ssrand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ssrand(T::Type, ny::Int, nu::Int, nstates::Int; proper=false, stable=true, Ts=nothing)</code></pre><p>Returns a random <code>StateSpace</code> model with <code>ny</code> outputs, <code>nu</code> inputs, and <code>nstates</code> states, whose matrix elements are normally distributed.</p><p>It is possible to specify if the system should be <code>proper</code> or <code>stable</code>.</p><p>Specify a sample time <code>Ts</code> to obtain a discrete-time system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/demo_systems.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.stabregionPID" href="#ControlSystems.stabregionPID"><code>ControlSystems.stabregionPID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fig, kp, ki = stabregionPID(P, [ω]; kd=0, doplot = true)</code></pre><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s</p><p>The curve is found by analyzing P(s)*C(s) = -1 ⟹ |PC| = |P| |C| = 1 arg(P) + arg(C) = -π</p><p>If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions</p><p>See also <code>stabregionPID</code>, <code>loopshapingPI</code>, <code>pidplots</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/pid_design.jl#L242-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}" href="#ControlSystems.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystems.starprod</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">starprod(sys1, sys2, dimu, dimy)</code></pre><p>Compute the Redheffer star product.</p><p><code>length(U1) = length(Y2) = dimu</code> and <code>length(Y1) = length(U2) = dimy</code></p><p>For details, see Chapter 9.3 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/connections.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tf-Union{Tuple{T2}, Tuple{T1}, Tuple{TE}, Tuple{AbstractVecOrMat{&lt;:AbstractVector{T1}}, AbstractVecOrMat{&lt;:AbstractVector{T2}}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T1&lt;:Number, T2&lt;:Number}" href="#ControlSystems.tf-Union{Tuple{T2}, Tuple{T1}, Tuple{TE}, Tuple{AbstractVecOrMat{&lt;:AbstractVector{T1}}, AbstractVecOrMat{&lt;:AbstractVector{T2}}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T1&lt;:Number, T2&lt;:Number}"><code>ControlSystems.tf</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>sys = tf(num, den[, Ts]), sys = tf(gain[, Ts])</code></p><p>Create as a fraction of polynomials:</p><p><code>sys::TransferFunction{SisoRational{T,TR}} = numerator/denominator</code> where T is the type of the coefficients in the polynomial.</p><p><code>num</code>: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>den</code>: the coefficients of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>Ts</code>: Sample time if discrete time system.</p><p>Other uses: <code>tf(sys)</code>: Convert <code>sys</code> to <code>tf</code> form. <code>tf(&quot;s&quot;)</code>, <code>tf(&quot;z&quot;)</code>: Create the continuous transferfunction <code>s</code>.</p><p>See also: <code>zpk</code>, <code>ss</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/tf.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.tzeros-Tuple{TransferFunction}" href="#ControlSystems.tzeros-Tuple{TransferFunction}"><code>ControlSystems.tzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tzeros(sys)</code></pre><p>Compute the invariant zeros of the system <code>sys</code>. If <code>sys</code> is a minimal realization, these are also the transmission zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpconv-NTuple{4, Any}" href="#ControlSystems.zpconv-NTuple{4, Any}"><code>ControlSystems.zpconv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zpc(a,r,b,s)</code></pre><p>form conv(a,r) + conv(b,s) where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/discrete.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpk-Union{Tuple{TP}, Tuple{TZ}, Tuple{T0}, Tuple{TE}, Tuple{VecOrMat{&lt;:AbstractVector{TZ}}, VecOrMat{&lt;:AbstractVector{TP}}, VecOrMat{T0}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T0&lt;:Number, TZ&lt;:Number, TP&lt;:Number}" href="#ControlSystems.zpk-Union{Tuple{TP}, Tuple{TZ}, Tuple{T0}, Tuple{TE}, Tuple{VecOrMat{&lt;:AbstractVector{TZ}}, VecOrMat{&lt;:AbstractVector{TP}}, VecOrMat{T0}, TE}} where {TE&lt;:ControlSystems.TimeEvolution, T0&lt;:Number, TZ&lt;:Number, TP&lt;:Number}"><code>ControlSystems.zpk</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>zpk(gain[, Ts]), zpk(num, den, k[, Ts]), zpk(sys)</code></p><p>Create transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.</p><p><code>sys::TransferFunction{SisoZpk{T,TR}} = k*numerator/denominator</code> where <code>T</code> is the type of <code>k</code> and <code>TR</code> the type of the zeros/poles, usually Float64 and Complex{Float64}.</p><p><code>num</code>: the roots of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>den</code>: the roots of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.</p><p><code>k</code>: The gain of the system. Obs, this is not the same as <code>dcgain</code>.</p><p><code>Ts</code>: Sample time if discrete time system.</p><p>Other uses:</p><p><code>zpk(sys)</code>: Convert <code>sys</code> to <code>zpk</code> form.</p><p><code>zpk(&quot;s&quot;)</code>: Create the transferfunction <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/types/zpk.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ControlSystems.zpkdata-Tuple{LTISystem}" href="#ControlSystems.zpkdata-Tuple{LTISystem}"><code>ControlSystems.zpkdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z, p, k = zpkdata(sys)</code></pre><p>Compute the zeros, poles, and gains of system <code>sys</code>.</p><p><strong>Returns</strong></p><p><code>z</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>p</code> : Matrix{Vector{ComplexF64}}, (ny x nu)</p><p><code>k</code> : Matrix{Float64}, (ny x nu)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/analysis.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>..  norm(sys, p=2; tol=1e-6)</code></p><p><code>norm(sys)</code> or <code>norm(sys,2)</code> computes the H2 norm of the LTI system <code>sys</code>.</p><p><code>norm(sys, Inf)</code> computes the H∞ norm of the LTI system <code>sys</code>. The H∞ norm is the same as the H∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function <code>hinfnorm</code> instead. See <a href="#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{&lt;:Continuous}}"><code>hinfnorm</code></a> for further documentation.</p><p><code>tol</code> is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).</p><p><code>sys</code> is first converted to a <code>StateSpace</code> model if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/699b36e9151520c416ef25135cb180ff37c9a1ae/src/matrix_comps.jl#L180-L195">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lib/plotting/">« Plotting</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Thursday 27 January 2022 06:24">Thursday 27 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
