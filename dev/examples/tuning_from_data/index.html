<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tune a controller using experimental data · ControlSystems.jl</title><meta name="title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta property="og:title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta property="twitter:title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example/">Design</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../automatic_differentiation/">Automatic differentiation</a></li><li class="is-active"><a class="tocitem" href>Tune a controller using experimental data</a><ul class="internal"><li><a class="tocitem" href="#Estimation-of-a-model"><span>Estimation of a model</span></a></li><li><a class="tocitem" href="#Dealing-with-model-uncertainty"><span>Dealing with model uncertainty</span></a></li><li><a class="tocitem" href="#Controller-tuning"><span>Controller tuning</span></a></li><li><a class="tocitem" href="#Pole-placement"><span>Pole placement</span></a></li><li><a class="tocitem" href="#C-Code-generation"><span>C-Code generation</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../zoh/">Analysis of sampled-data (continuous/discrete) systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../lib/constructors/">Constructors</a></li><li><a class="tocitem" href="../../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../../lib/synthesis/">Synthesis</a></li><li><a class="tocitem" href="../../lib/timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../../lib/plotting/">Plotting</a></li><li><a class="tocitem" href="../../lib/nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Tune a controller using experimental data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tune a controller using experimental data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/examples/tuning_from_data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tuning-a-PID-controller-from-data"><a class="docs-heading-anchor" href="#Tuning-a-PID-controller-from-data">Tuning a PID controller from data</a><a id="Tuning-a-PID-controller-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-a-PID-controller-from-data" title="Permalink"></a></h1><p>In this example, we will consider a very commonly occurring workflow: using process data to tune a PID controller.</p><p>The two main steps involved in this workflow are:</p><ol><li>Estimate a process model from data</li><li>Characterize the uncertainty in the estimated model</li><li>Design a controller based on the estimated model</li><li>Verify that the controller is robust with respect to the estimated model uncertainty</li></ol><h2 id="Estimation-of-a-model"><a class="docs-heading-anchor" href="#Estimation-of-a-model">Estimation of a model</a><a id="Estimation-of-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-of-a-model" title="Permalink"></a></h2><p>In this example, which is split into two parts, we will consider tuning a velocity controller for a <strong>flexible robot arm</strong>. Part 1 is available here: <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/dev/examples/flexible_robot/">Flexible Robot Arm Part 1: Estimation of a model.</a>. The system identification uses the package <a href="https://github.com/baggepinnen/ControlSystemIdentification.jl">ControlSystemIdentification.jl</a>.</p><p>The rest of this example makes up part 2, tuning of the controller. We simply replicate the relevant code from part 1 to get the estimated model, and then use the estimated model to tune controllers.</p><pre><code class="language-julia hljs">using DelimitedFiles, Plots
using ControlSystemIdentification, ControlSystems

url = &quot;https://ftp.esat.kuleuven.be/pub/SISTA/data/mechanical/robot_arm.dat.gz&quot;
zipfilename = &quot;/tmp/flex.dat.gz&quot;
path = Base.download(url, zipfilename)
run(`gunzip -f $path`)
data = readdlm(path[1:end-3])
u = data[:, 1]&#39; # torque
y = data[:, 2]&#39; # acceleration
d = iddata(y, u, 0.01) # sample time not specified for data, 0.01 is a guess
Pacc = subspaceid(d, 4, focus=:prediction) # Estimate the process model using subspace-based identification</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemIdentification.N4SIDStateSpace{StateSpace{Discrete{Float64}, Float64}, Hermitian{Float64, Matrix{Float64}}, Hermitian{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}, Float64}
A = 
  0.6949830687775826      0.7362089216106286      0.022283788213858024  0.0074934417166648325
 -0.6870322758159733      0.6990491958013204      0.06057525726444244   0.007931064745775264
  0.0028697839572051414  -0.018715176030545507    0.9323072774684213    0.35923797247733275
 -0.0027486741509647485   0.0028527341438039483  -0.3560944743423597    0.933419895552786
B = 
  0.108945192898385
  0.03284586920148847
 -0.061803778489570395
 -0.16353482327564708
C = 
 -1.4776822390776791  0.7423830811175098  -0.5177358313756605  -0.03835431412955206
D = 
 -0.20473464374062206

Sample Time: 0.01 (seconds)
Discrete-time state-space model</code></pre><p>Since the data used for the system identification had acceleration rather than velocity as output, we multiply the estimated model by the transfer function <span>$1/s$</span> to get a velocity model. Before we do this, we convert the estimated discrete-time model into continuous time using the function <a href="../../lib/synthesis/#ControlSystemsBase.d2c"><code>d2c</code></a>. The estimated system also has a negative gain due to the mounting of the accelerometer, so we multiply the model by <span>$-1$</span> to get a positive gain.</p><pre><code class="language-julia hljs">s = tf(&quot;s&quot;)
P = 1/s * d2c(-Pacc.sys)
bodeplot(P)</code></pre><img src="90d3cf08.svg" alt="Example block output"/><h2 id="Dealing-with-model-uncertainty"><a class="docs-heading-anchor" href="#Dealing-with-model-uncertainty">Dealing with model uncertainty</a><a id="Dealing-with-model-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-model-uncertainty" title="Permalink"></a></h2><p>When using a model for control design, we always have to consider how robust we are with respect to errors in the model. Classical margins like the gain and phase margins are simple measures of robustness, applicable to simple measures of uncertainty. Here, we will attempt to characterize the uncertainty in the model slightly more accurately.</p><p>When we estimate linear black-box models from data, like we did above using <code>subspaceid</code>, we can get a rough estimate of how well a linear model describes the input-output data by looking at the magnitude-squared coherence function <span>$\gamma(i\omega)$</span>:</p><pre><code class="language-julia hljs">coherenceplot(d)</code></pre><img src="7bfae977.svg" alt="Example block output"/><p>For frequencies where <span>$\gamma$</span> is close to one, a linear model is expected to fit well, whereas for frequencies where <span>$\gamma$</span> is close to zero, we cannot trust the model. How does this rough estimate of model certainty translate to our control analysis? In the video <a href="https://youtu.be/uQx192FyA5g?si=kubWnq__ohWOaICw">The benefit and Cost of Feedback</a>, we show that for frequencies where the uncertainty in the model is large, we must have a small sensitivity. In the video, we analyzed the effects of additive uncertainty, in which case we need to make sure that the sensitivity function <span>$CS = C/(1+PC)$</span> is sufficiently small. When using the rough estimate of model uncertainty provided by the coherence function, it may be more reasonable to consider a multiplicative (relative) uncertainty model, in which case we need to verify that the sensitivity function <span>$T = PC/(1+PC)$</span> is small for frequencies where <span>$\gamma$</span> is small.</p><p>Since our coherence drops significantly above <span>$\omega = 130$</span>rad/s, we will try to design a controller that yields a complementary sensitivity function <span>$T$</span> that has low gain above this frequency.</p><p>In the <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/uncertainty/#Multiplicative-uncertainty">documentation of RobustAndOptimalControl.jl</a>, we list a number of common uncertainty models together with the criteria for robust stability. A good resource on the gang of four is available in <a href="https://www.control.lth.se/fileadmin/control/staff/KJ/FeedbackFundamentals.pdf">these slides</a>.</p><h2 id="Controller-tuning"><a class="docs-heading-anchor" href="#Controller-tuning">Controller tuning</a><a id="Controller-tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-tuning" title="Permalink"></a></h2><p>We could take multiple different approaches to tuning the PID controller, a few alternatives are listed here</p><ul><li>Trial and error in simulation or experiment.</li><li>Manual loop shaping</li><li>Automatic loop shaping</li><li>Step-response optimization (<a href="https://juliacontrol.github.io/ControlSystems.jl/stable/examples/automatic_differentiation/#Optimization-based-tuning%E2%80%93PID-controller">example</a>)</li></ul><p>Here, we will attempt a manual loop-shaping approach using the function <a href="../../lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, and then then compare the result to a pole-placement controller.</p><h3 id="Manual-loop-shaping"><a class="docs-heading-anchor" href="#Manual-loop-shaping">Manual loop shaping</a><a id="Manual-loop-shaping-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-loop-shaping" title="Permalink"></a></h3><p>Since the process contains two sharp resonance peaks, visible in the Bode diagram above, we want to include a lowpass filter in the controller to suppress any frequencies above the first resonance so that the resonances do not cause excessive robustness problems. Here, we will use a second-order lowpass filer.</p><p>A PID controller is fundamentally incapable at damping the resonances in this high-order system. Indeed, for a plant model of order 4, we have a closed-loop system with a 7-dimensional state (one pole for the integrator and two for the low-pass filter), but only 3-4 parameters in the PID controller (depending on whether or not we count the filter parameter), so there is no hope for us to arbitrarily place the poles using the PID controller. Trying to use a gain high enough to dampen the resonant poles can result in poor robustness properties, as we will see below.</p><p>The function <a href="../../lib/synthesis/#ControlSystemsBase.pid"><code>pid</code></a> takes the PID parameters &quot;standard form&quot;, but the parameter convention to use can be selected using the <code>form</code> keyword. We use the function <a href="../../lib/plotting/#ControlSystemsBase.marginplot"><code>marginplot</code></a> to guide our tuning, the following parameters were found to give a good result</p><pre><code class="language-julia hljs">K = 10
Tf = 0.4
Ti = 4
Td = 0.1
CF = pid(K, Ti, Td; Tf)
marginplot(P*CF)</code></pre><img src="afdacf12.svg" alt="Example block output"/><p>Here, we have selected the proportional gain <span>$K$</span>large enough to give a crossover bandwidth of about 1rad/s, being careful not to let the resonance peaks reach too close to unit gain, destroying our robustness. The integral time constant <span>$T_i$</span> is selected as low as possible without destroying the phase margin, and the derivative time constant <span>$T_d$</span> is increased slowly to improve the phase margin while not letting the resonance peaks become too large.</p><p>The <a href="../../lib/synthesis/#ControlSystemsBase.pid"><code>pid</code></a> function returns the PI controller with the second-order lowpass filter already applied.</p><p>Next, we form the closed-loop system <span>$G$</span> from reference to output an plot a step response</p><pre><code class="language-julia hljs">G = feedback(P*CF)
plot(step(G, 50), label=&quot;Step response&quot;)</code></pre><img src="a4350313.svg" alt="Example block output"/><p>This looks rather aggressive and with a large overshoot visible. The problem here is that no mechanical system can follow a perfect step in the reference, and it is thus common to generate some form of physically realizable smooth step as input reference. Below, we use the package <a href="https://github.com/baggepinnen/TrajectoryLimiters.jl">TrajectoryLimiters.jl</a> to filter the reference step such that it has bounded acceleration and velocity</p><pre><code class="language-julia hljs">using TrajectoryLimiters
ẋM = 1 # Velocity limit
ẍM = 0.01 # Acceleration limit
limiter = TrajectoryLimiter(d.Ts, ẋM, ẍM)
inputstep, vel, acc = limiter([0; ones(5000)])
timevec = 0:d.Ts:50
plot(step(G, 50), label=&quot;Step response&quot;)
plot!(lsim(G, inputstep&#39;, timevec), label=&quot;Smooth step response&quot;)
plot!(timevec, inputstep, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black))</code></pre><img src="69e1f035.svg" alt="Example block output"/><p>The result now looks much better, with some small amount of overshoot. The performance is not terrific, taking about 20 seconds to realize the step. However, attempting to make the response faster using feedback alone will further exacerbate the robustness problems due to the resonance peaks highlighted above.</p><p>To analyze the robustness of this controller, we can inspect the sensitivity functions in the <a href="https://www.control.lth.se/fileadmin/control/staff/KJ/FeedbackFundamentals.pdf">gang of four</a>. In particular, we are interested in the complementary sensitivity function <span>$T = PC/(1+PC)$</span> </p><pre><code class="language-julia hljs">gangoffourplot(P, CF)</code></pre><img src="dcae8f43.svg" alt="Example block output"/><p>The gang of four indicates that we have a robust tuning, no uncomfortably large peaks appears in either <span>$T$</span> or <span>$S$</span>.</p><p>Below, we attempt a pole-placement design for comparison. Contrary to the PID controller, a state-feedback controller designed using pole placement <em>can</em> place all poles of this system arbitrarily (the system is <em>controllable</em>, which can be verified using the function <a href="../../lib/analysis/#ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>controllability</code></a>).</p><h2 id="Pole-placement"><a class="docs-heading-anchor" href="#Pole-placement">Pole placement</a><a id="Pole-placement-1"></a><a class="docs-heading-anchor-permalink" href="#Pole-placement" title="Permalink"></a></h2><p>We start by inspecting the pole locations of the open-loop plant</p><pre><code class="language-julia hljs">pzmap(P)</code></pre><img src="c692f4fe.svg" alt="Example block output"/><p>As expected, we have 2 resonant pole pairs.</p><p>When dampening fast resonant poles, it is often a good idea to <em>only</em> dampen them, not to change the bandwidth of them. Trying to increase the bandwidth of these fast poles requires very large controller gain, and making the poles slower often causes severe robustness problems. We thus try to place the resonant poles with the same magnitude, but with perfect damping.</p><pre><code class="language-julia hljs">current_poles = poles(P)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{ComplexF64}:
                  0.0 + 0.0im
  -0.3650205987299606 + 79.62234770329262im
  -0.3650205987299606 - 79.62234770329262im
 -0.08657413011071657 + 36.58351938981836im
 -0.08657413011071657 - 36.58351938981836im</code></pre><p>The integrator pole can be placed to achieve a desired bandwidth. Here, we place it in -30rad/s to achieve a faster response than the PID controller achieved.</p><pre><code class="language-julia hljs">desired_poles = -[80, 80, 37, 37, 30];</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 -80
 -80
 -37
 -37
 -30</code></pre><p>We compute the state-feedback gain <span>$L$</span> using the function <a href="../../lib/synthesis/#ControlSystemsBase.place"><code>place</code></a>, and also compute an observer gain <span>$K$</span> using the rule of thumb that the observer poles should be approximately twice as fast as the system poles.</p><pre><code class="language-julia hljs">L = place(P, desired_poles, :c)
K = place(P, 2*desired_poles, :o)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×1 adjoint(::Matrix{Float64}) with eltype Float64:
    527.0968105423192
  52238.13148993665
  37891.00754864752
  97839.72676710371
 -35335.165089836235</code></pre><p>The resulting observer-based state-feedback controller can be constructed using the function <a href="../../lib/analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a>. We also form the closed-loop system <span>$G_{pp}$</span> from reference to output an plot a step response like we did above</p><pre><code class="language-julia hljs">Cpp = observer_controller(P, L, K)
Gpp = feedback(P*Cpp)
plot(lsim(Gpp, inputstep&#39;, timevec), label=&quot;Smooth step response&quot;)
plot!(timevec, inputstep, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black), legend=:bottomright)</code></pre><img src="52d4a7a5.svg" alt="Example block output"/><p>The pole-placement controller achieves a very nice result, but this comes at a cost of using very large controller gain. The gang-of-four plot below indicates that we have a controller with a very large noise-amplification transfer function, <span>$CS$</span> has a large gain for high frequencies, implying that this controller requires a very good sensor to be practical! We also have significant gain in <span>$T$</span> well above the frequency <span>$ω = 130$</span>rad/s above which we couldn&#39;t trust the model.</p><pre><code class="language-julia hljs">gangoffourplot(P, Cpp)
vline!(fill(130, 1, 4), label=&quot;\$ω = 130\$&quot;, l=(:dash, :black))</code></pre><img src="ffaec7d7.svg" alt="Example block output"/><p>Due to the high gain of the controller we got, we redo the design, this time only dampening the resonant poles slightly. We also lower the bandwidth of the integrator pole to make the controller less aggressive</p><pre><code class="language-julia hljs">p1 = current_poles[2]
p2 = current_poles[4]

p1_new = abs(p1) * cis(-pi + deg2rad(65)) # Place the pole with the same magnitude, but with an angle of -pi + 65 degrees
p2_new = abs(p2) * cis(-pi + deg2rad(65))
desired_poles = [-20, p1_new, conj(p1_new), p2_new, conj(p2_new)]
L = place(P, desired_poles, :c) |&gt; real
K = place(P, 2*desired_poles, :o) |&gt; real
Cpp = observer_controller(P, L, K)
Gpp = feedback(P*Cpp)
f1 = plot(lsim(Gpp, inputstep&#39;, timevec), label=&quot;Smooth step response&quot;)
plot!(timevec, inputstep, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black), legend=:bottomright)

f2 = gangoffourplot(P, Cpp)
vline!(fill(130, 1, 4), label=&quot;\$ω = 130\$&quot;, l=(:dash, :black))
plot(f1, f2, size=(800, 600))</code></pre><img src="c55b11cd.svg" alt="Example block output"/><p>We still have a nice step response using this controller, but this time, we have a rolloff in <span>$T$</span> that starts around the frequency <span>$ω = 130$</span>rad/s.</p><h2 id="C-Code-generation"><a class="docs-heading-anchor" href="#C-Code-generation">C-Code generation</a><a id="C-Code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#C-Code-generation" title="Permalink"></a></h2><p>With the PID controller, we can transform the PID parameters to the desired form and enter those into an already existing PID-controller implementation. Care must be taken to incorporate also the measurement filter designed, this filter is important for robustness analysis to be valid. If no existing PID controller implementation is available, we may either make use of the package <a href="https://github.com/JuliaControl/DiscretePIDs.jl">DiscretePIDs.jl</a>, or generate C-code for the controller. Below, we generate some C code.</p><p>Using the pole-placement controller derived above, we discretize the controller using the Tustin (bilinear) method with the function <a href="../../lib/constructors/#ControlSystemsBase.c2d"><code>c2d</code></a>, and then call <a href="https://github.com/JuliaControl/SymbolicControlSystems.jl#code-generation"><code>SymbolicControlSystems.ccode</code></a> to generate the code.</p><pre><code class="language-julia hljs">using SymbolicControlSystems
Cdiscrete = c2d(Cpp, d.Ts, :tustin)
SymbolicControlSystems.ccode(Cdiscrete)</code></pre><p>This produces the following C-code for filtering the error signal through the controller transfer function</p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void transfer_function(double *y, double u) {
    static double x[5] = {0};  // Current state
    double xp[5] = {0};        // Next state
    int i;

    // Advance the state xp = Ax + Bu
    xp[0] = (1.2608412916795442*u - 0.35051915762703334*x[0] + 0.0018847792079810998*x[1] - 0.0035104037080211504*x[2] + 0.0022503125347378308*x[3] + 0.00019318421187795658*x[4]);
    xp[1] = (45.346976964169166*u - 49.856146529754966*x[0] + 0.19058339536496746*x[1] + 0.58214123400704609*x[2] - 0.068048140252114517*x[3] - 0.03667586076286556*x[4]);
    xp[2] = (18.14135831274827*u - 19.16237014106056*x[0] - 0.84117137404200237*x[1] + 0.7024229589860792*x[2] + 0.018736385625077446*x[3] - 0.008392059099094502*x[4]);
    xp[3] = (190.59457176680613*u - 161.57645282794124*x[0] - 0.23872534677018914*x[1] + 1.0884789050298469*x[2] + 0.32394494701618637*x[3] + 0.32518305451736074*x[4]);
    xp[4] = (18.392870361917002*u - 0.43306059549357445*x[0] + 0.60377162139631557*x[1] + 0.62662564832184231*x[2] - 0.48738482327867771*x[3] + 0.98218650191968704*x[4]);

    // Accumulate the output y = C*x + D*u
    y[0] = (182.81664929547824*u - 63.477219815374006*x[0] + 3.5715419988427302*x[1] + 4.1831558072019464*x[2] - 1.0447833362501759*x[3] + 0.27420732436215378*x[4]);

    // Make the predicted state the current state
    for (i=0; i &lt; 5; ++i) {
        x[i] = xp[i];
    }
}</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial has shown how to follow a workflow that consists of</p><ol><li>Estimate a process model using experimental data.</li><li>Design a controller based on the estimated model. We designed a PID controller and one pole-placement controller which was able to cancel the resonances in the system which the PID controllers could not do.</li><li>Simulate the closed-loop system and analyze its robustness properties. Model uncertainty was considered using the coherence function.</li><li>Generate C-code for one of the controllers.</li></ol><p>Each of these steps is covered in additional detail in the videos available in the playlist <a href="https://youtube.com/playlist?list=PLC0QOsNQS8hZtOQPHdtul3kpQwMOBL8Qc&amp;si=yUrXz5cH4QqTPlR_">Control systems in Julia</a>. See also the tutorial <a href="https://help.juliahub.com/juliasimcontrol/dev/examples/quadtank/">Control design for a quadruple-tank system</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../automatic_differentiation/">« Automatic differentiation</a><a class="docs-footer-nextpage" href="../zoh/">Analysis of sampled-data (continuous/discrete) systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 28 November 2024 07:20">Thursday 28 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
