<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tune a controller using experimental data · ControlSystems.jl</title><meta name="title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta property="og:title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta property="twitter:title" content="Tune a controller using experimental data · ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example/">Design</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../automatic_differentiation/">Automatic differentiation</a></li><li class="is-active"><a class="tocitem" href>Tune a controller using experimental data</a><ul class="internal"><li><a class="tocitem" href="#Estimation-of-a-model"><span>Estimation of a model</span></a></li><li><a class="tocitem" href="#Controller-tuning"><span>Controller tuning</span></a></li><li><a class="tocitem" href="#Pole-placement"><span>Pole placement</span></a></li><li><a class="tocitem" href="#C-Code-generation"><span>C-Code generation</span></a></li><li><a class="tocitem" href="#Dealing-with-model-uncertainty"><span>Dealing with model uncertainty</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../lib/constructors/">Constructors</a></li><li><a class="tocitem" href="../../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../../lib/synthesis/">Synthesis</a></li><li><a class="tocitem" href="../../lib/timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../../lib/plotting/">Plotting</a></li><li><a class="tocitem" href="../../lib/nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Tune a controller using experimental data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tune a controller using experimental data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/examples/tuning_from_data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tuning-a-PID-controller-from-data"><a class="docs-heading-anchor" href="#Tuning-a-PID-controller-from-data">Tuning a PID controller from data</a><a id="Tuning-a-PID-controller-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Tuning-a-PID-controller-from-data" title="Permalink"></a></h1><p>In this example, we will consider a very commonly occurring workflow: using process data to tune a PID controller.</p><p>The two main steps involved in this workflow are:</p><ol><li>Estimate a process model from data</li><li>Design a controller based on the estimated model</li></ol><h2 id="Estimation-of-a-model"><a class="docs-heading-anchor" href="#Estimation-of-a-model">Estimation of a model</a><a id="Estimation-of-a-model-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation-of-a-model" title="Permalink"></a></h2><p>In this example, which is split into two parts, we will consider tuning a velocity controller for a <strong>flexible robot arm</strong>. Part 1 is available here: <a href="https://baggepinnen.github.io/ControlSystemIdentification.jl/dev/examples/flexible_robot/">Flexible Robot Arm Part 1: Estimation of a model.</a>. The system identification uses the package <a href="https://github.com/baggepinnen/ControlSystemIdentification.jl">ControlSystemIdentification.jl</a>.</p><p>The rest of this example makes up part 2, tuning of the controller. We simply replicate the relevant code from part 1 to get the estimated model, and then use the estimated model to tune controllers.</p><pre><code class="language-julia hljs">using DelimitedFiles, Plots
using ControlSystemIdentification, ControlSystems

url = &quot;https://ftp.esat.kuleuven.be/pub/SISTA/data/mechanical/robot_arm.dat.gz&quot;
zipfilename = &quot;/tmp/flex.dat.gz&quot;
path = Base.download(url, zipfilename)
run(`gunzip -f $path`)
data = readdlm(path[1:end-3])
u = data[:, 1]&#39; # torque
y = data[:, 2]&#39; # acceleration
d = iddata(y, u, 0.01) # sample time not specified for data, 0.01 is a guess
Pacc = subspaceid(d, 4, focus=:prediction) # Estimate the process model using subspace-based identification</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ControlSystemIdentification.N4SIDStateSpace{StateSpace{Discrete{Float64}, Float64}, Hermitian{Float64, Matrix{Float64}}, Hermitian{Float64, Matrix{Float64}}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vector{Float64}, SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}}, Float64}
A = 
  0.6949830687775829      0.736208921610629       0.02228378821385816   0.0074934417166644274
 -0.6870322758159731      0.6990491958013203      0.060575257264442704  0.007931064745774116
  0.0028697839572054285  -0.018715176030545535    0.9323072774684218    0.3592379724773327
 -0.0027486741509648756   0.0028527341438042988  -0.3560944743423596    0.933419895552785
B = 
  0.10894519289838502
  0.03284586920148841
 -0.06180377848957377
 -0.16353482327564556
C = 
 -1.4776822390776785  0.7423830811175091  -0.5177358313756615  -0.03835431412954211
D = 
 -0.20473464374062197

Sample Time: 0.01 (seconds)
Discrete-time state-space model</code></pre><p>Since the data used for the system identification had acceleration rather than velocity as output, we multiply the estimated model by the transfer function <span>$1/s$</span> to get a velocity model. Before we do this, we convert the estimated discrete-time model into continuous time using the function <a href="../../lib/synthesis/#ControlSystemsBase.d2c"><code>d2c</code></a>. The estimated system also has a negative gain due to the mounting of the accelerometer, so we multiply the model by <span>$-1$</span> to get a positive gain.</p><pre><code class="language-julia hljs">s = tf(&quot;s&quot;)
P = 1/s * d2c(-Pacc.sys)
bodeplot(P)</code></pre><img src="988566e0.svg" alt="Example block output"/><h2 id="Controller-tuning"><a class="docs-heading-anchor" href="#Controller-tuning">Controller tuning</a><a id="Controller-tuning-1"></a><a class="docs-heading-anchor-permalink" href="#Controller-tuning" title="Permalink"></a></h2><p>We could take multiple different approaches to tuning the PID controller, a few alternatives are listed here</p><ul><li>Trial and error in simulation or experiment.</li><li>Manual loop shaping</li><li>Automatic loop shaping</li><li>Step-response optimization (<a href="https://juliacontrol.github.io/ControlSystems.jl/stable/examples/automatic_differentiation/#Optimization-based-tuning%E2%80%93PID-controller">example</a>)</li></ul><p>Here, we will attempt a manual loop-shaping approach using the function <a href="../../lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, and then then compare the result to a pole-placement controller.</p><h3 id="Manual-loop-shaping"><a class="docs-heading-anchor" href="#Manual-loop-shaping">Manual loop shaping</a><a id="Manual-loop-shaping-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-loop-shaping" title="Permalink"></a></h3><p>The function <a href="../../lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a> takes a model and selects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function <span>$L = PC$</span> at the frequency <code>ω</code> is tangent to the circle where the magnitude of the complimentary sensitivity function <span>$T = PC / (1+PC)$</span> equals <span>$M_T$</span>. This allows us to explicitly solve for the PID parameters that achieves a desired target value of <span>$M_T$</span> at a desired frequency <code>ω</code>. The function can optionally produce a plot which draws the design characteristics and the resulting Nyquist curve, which we will make use of here. A Youtube video tutorial that goes into more details on how this function works is <a href="https://youtu.be/BolNmqYYIEg?si=hF-xvsPL_wBngpft&amp;t=775">available here</a>.</p><p>Since the process contains two sharp resonance peaks, visible in the Bode diagram above, the requirements for our velocity controller have to be rather modest. We therefore tell <a href="../../lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a> that we want to include a lowpass filter in the controller to suppress any frequencies above <span>$ω_f = 1/T_f$</span> so that the resonances do not cause excessive robustness problems. We choose the design frequency to be <span>$ω = 5$</span> and the target value of <span>$M_T = 1.35$</span> achieved at an angle of <span>$ϕ_t = 35$</span> degrees from the negative real axis. The function returns the controller, the PID parameters, the resulting Nyquist curve, and the lowpass-filter controlled <code>CF</code>. </p><pre><code class="language-julia hljs">ω = 5
Tf = 1/10
C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.35, ϕt=35, doplot=true, Tf)
fig</code></pre><img src="42fcd3ed.svg" alt="Example block output"/><p>The PID parameters are by default returned on &quot;standard form&quot;, but the parameter convention to use can be selected using the <code>form</code> keyword.</p><p>The result above satisfies the design in the design point, but the sharp resonances peak well above the desired maximum of the complementary sensitivity function. The problem here is that a PID controller is fundamentally incapable at damping the resonances in this high-order system. Indeed, we have a closed-loop system with a 8-dimensional state, but only 3-4 parameters in the PID controller (depending on whether or not we count the filter parameter), so there is no hope for us to arbitrarily place the poles using the PID controller. This can result in poor robustness properties, as we will see below.</p><p>Next, we form the closed-loop system <span>$G$</span> from reference to output an plot a step response</p><pre><code class="language-julia hljs">G = feedback(P*CF)
plot(step(G, 10), label=&quot;Step response&quot;)</code></pre><img src="ea1849ff.svg" alt="Example block output"/><p>This looks extremely aggressive and with clear resonances visible. The problem here is that no mechanical system can follow a perfect step in the reference, and it is thus common to generate some form of physically realizable smooth step as input reference. Below, we use the package <a href="https://github.com/baggepinnen/TrajectoryLimiters.jl">TrajectoryLimiters.jl</a> to filter the reference step such that it has bounded acceleration and velocity</p><pre><code class="language-julia hljs">using TrajectoryLimiters
ẋM = 2 # Velocity limit
ẍM = 1 # Acceleration limit
limiter = TrajectoryLimiter(d.Ts, ẋM, ẍM)
inputstep, vel, acc = limiter([0; ones(1000)])
timevec = 0:d.Ts:10
plot(step(G, 10), label=&quot;Step response&quot;)
plot!(lsim(G, inputstep&#39;, timevec), label=&quot;Smooth step response&quot;)
plot!(timevec, inputstep, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black))</code></pre><img src="978be752.svg" alt="Example block output"/><p>The result now looks much better, with some small amount of overshoot. The performance is not terrific, taking about 2 seconds to realize the step. However, attempting to make the response faster using feedback alone will further exacerbate the robustness problems due to the resonance peaks highlighted above.</p><p>A more conservative and robust tuning, that does not let the resonance peaks cause large peaks in the sensitivity functions, can be realized by manual loop shaping with the help of a <a href="../../lib/plotting/#ControlSystemsBase.marginplot"><code>marginplot</code></a></p><pre><code class="language-julia hljs">Tf = 0.4
Ti = 4
Td = 0.1
CF = pid(10, Ti, Td; Tf)
marginplot(P*CF)</code></pre><img src="f6b0414b.svg" alt="Example block output"/><p>This tuning shows good gain and phase margins, but the price we pay for this is of course performance:</p><pre><code class="language-julia hljs">ẍM = 0.008 # Acceleration limit
limiter2 = TrajectoryLimiter(d.Ts, ẋM, ẍM)
inputstep2, vel, acc = limiter2([0; ones(5000)])
timevec2 = 0:d.Ts:50
G = feedback(P*CF)
plot(step(G, 50), label=&quot;Step response&quot;)
plot!(lsim(G, inputstep2&#39;, timevec2), label=&quot;Smooth step response&quot;)
plot!(timevec2, inputstep2, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black))</code></pre><img src="48c11845.svg" alt="Example block output"/><p>The closed-loop system now responds significantly slower. </p><p>The improved robustness of this controller is visible in the transfer function <span>$T = PC/(1+PC)$</span> where we have a much smaller gain for the frequencies around and above the resonance peaks.</p><pre><code class="language-julia hljs">gangoffourplot(P, CF)</code></pre><img src="16b531d1.svg" alt="Example block output"/><p>Below, we attempt a pole-placement design for comparison. Contrary to the PID controller, a pole-placement controller <em>can</em> place all poles of this system arbitrarily (the system is <em>controllable</em>, which can be verified using the function <a href="../../lib/analysis/#ControlSystemsBase.controllability-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T"><code>controllability</code></a>).</p><h2 id="Pole-placement"><a class="docs-heading-anchor" href="#Pole-placement">Pole placement</a><a id="Pole-placement-1"></a><a class="docs-heading-anchor-permalink" href="#Pole-placement" title="Permalink"></a></h2><p>We start by inspecting the pole locations of the open-loop plant</p><pre><code class="language-julia hljs">pzmap(P)</code></pre><img src="cd7706ea.svg" alt="Example block output"/><p>As expected, we have 2 resonant pole pairs.</p><p>When dampening fast resonant poles, it is often a good idea to <em>only</em> dampen them, not to change the bandwidth of them. Trying to increase the bandwidth of these fast poles requires very large controller gain, and making the poles slower often causes severe robustness problems. We thus place the resonant poles with the same magnitude, but with perfect damping.</p><pre><code class="language-julia hljs">current_pole_magnitudes = abs.(poles(P))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
  0.0
 79.62318439890174
 79.62318439890174
 36.583621827605015
 36.583621827605015</code></pre><p>The integrator pole can be placed to achieve a desired bandwidth. Here, we place it in -30rad/s to achieve a faster response than the PID controller achieved.</p><pre><code class="language-julia hljs">desired_poles = -[80, 80, 37, 37, 30]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Int64}:
 -80
 -80
 -37
 -37
 -30</code></pre><p>We compute the state-feedback gain <span>$L$</span> using the function <a href="../../lib/synthesis/#ControlSystemsBase.place"><code>place</code></a>, and also compute an observer gain <span>$K$</span> using the rule of thumb that the observer poles should be approximately twice as fast as the system poles.</p><pre><code class="language-julia hljs">L = place(P, desired_poles, :c)
K = place(P, 2*desired_poles, :o)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×1 adjoint(::Matrix{Float64}) with eltype Float64:
    527.0968105423185
  52238.13148993655
  37891.007548647634
  97839.72676710329
 -35335.165089838396</code></pre><p>The resulting observer-based state-feedback controller can be constructed using the function <a href="../../lib/analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a>. We also form the closed-loop system <span>$G_{pp}$</span> from reference to output an plot a step response like we did above</p><pre><code class="language-julia hljs">Cpp = observer_controller(P, L, K)
Gpp = feedback(P*Cpp)
plot(lsim(Gpp, inputstep&#39;, timevec), label=&quot;Smooth step response&quot;)
plot!(timevec, inputstep, label=&quot;Smooth reference trajectory&quot;, l=(:dash, :black))</code></pre><img src="645ac136.svg" alt="Example block output"/><p>The pole-placement controller achieves a very nice result, but this comes at a cost of using very large controller gain. The gang-of-four plot below indicates that we have a controller with reasonable robustness properties if we inspect the sensitivity and complimentary sensitivity functions, but the noise-amplification transfer function <span>$CS$</span> has a large gain for high frequencies, implying that this controller requires a very good sensor to be practical!</p><pre><code class="language-julia hljs">gangoffourplot(P, Cpp)</code></pre><img src="bebb648d.svg" alt="Example block output"/><p>With the PID controller, we can transform the PID parameters to the desired form and enter those into an already existing PID-controller implementation. Care must be taken to incorporate also the measurement filter designed by <a href="../../lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, this filter is important for robustness analysis to be valid. If no existing PID controller implementation is available, we may either make use of the package <a href="https://github.com/JuliaControl/DiscretePIDs.jl">DiscretePIDs.jl</a>, or generate C-code for the controller. Below, we generate some C code.</p><h2 id="C-Code-generation"><a class="docs-heading-anchor" href="#C-Code-generation">C-Code generation</a><a id="C-Code-generation-1"></a><a class="docs-heading-anchor-permalink" href="#C-Code-generation" title="Permalink"></a></h2><p>Using the pole-placement controller derived above, we discretize the controller using the Tustin (bilinear) method of the function <a href="../../lib/constructors/#ControlSystemsBase.c2d"><code>c2d</code></a>, and then call <a href="https://github.com/JuliaControl/SymbolicControlSystems.jl#code-generation"><code>SymbolicControlSystems.ccode</code></a>.</p><pre><code class="language-julia hljs">using SymbolicControlSystems
Cdiscrete = c2d(Cpp, d.Ts, :tustin)
SymbolicControlSystems.ccode(Cdiscrete)</code></pre><p>This produces the following C-code for filtering the error signal through the controller transfer function</p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;

#include &lt;math.h&gt;

void transfer_function(double *y, double u) {
    static double x[5] = {0};  // Current state

    double xp[5] = {0};        // Next state
    int i;

    // Advance the state xp = Ax + Bu
    xp[0] = (1.323555302697655*u - 0.39039743126198218*x[0] - 0.0016921457205018749*x[1] - 0.0012917116898466163*x[2] + 0.001714187010327197*x[3] + 0.0016847122113737578*x[4]);
    xp[1] = (96.429820608571958*u - 95.054670090613683*x[0] + 0.13062589956122247*x[1] + 0.78522537641468981*x[2] - 0.21646419099004577*x[3] - 0.081049292550184435*x[4]);
    xp[2] = (13.742733359914924*u - 15.008953114410946*x[0] - 0.89468526010523608*x[1] + 0.717920592086567*x[2] + 0.025588437849127441*x[3] + 0.021322717715438085*x[4]);
    xp[3] = (303.50179259195619*u - 268.71085904944562*x[0] + 1.251906632298234*x[1] + 0.62490471615521814*x[2] + 0.15988074336172073*x[3] - 0.4891888301891486*x[4]);
    xp[4] = (-27.542490469297601*u + 37.631007484177218*x[0] + 1.2366332766644277*x[1] + 0.11855488877285068*x[2] - 0.29543727245267387*x[3] + 0.76660106988104448*x[4]);

    // Accumulate the output y = C*x + D*u
    y[0] = (912.01950044640216*u - 742.76679702406477*x[0] + 10.364451210258789*x[1] + 2.7824392013821053*x[2] - 2.3907024395896719*x[3] - 3.734615363051947*x[4]);

    // Make the predicted state the current state
    for (i=0; i &lt; 5; ++i) {
        x[i] = xp[i];
    }

}</code></pre><h2 id="Dealing-with-model-uncertainty"><a class="docs-heading-anchor" href="#Dealing-with-model-uncertainty">Dealing with model uncertainty</a><a id="Dealing-with-model-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-model-uncertainty" title="Permalink"></a></h2><p>When using a model for control design, we always have to consider how robust we are with respect to errors in the model. In he control design above, we considered classical margins like the gain and phase margins, but also analyzed the sensitivity functions in the <a href="https://www.control.lth.se/fileadmin/control/staff/KJ/FeedbackFundamentals.pdf">gang of four</a>. </p><p>When we estimate linear black-box models from data, like we did above using <code>subspaceid</code>, we can get a rough estimate of how well a linear model describes the input-output data by looking at the magnitude-squared coherence function <span>$\gamma(i\omega)$</span>:</p><pre><code class="language-julia hljs">coherenceplot(d)</code></pre><img src="c40cb22f.svg" alt="Example block output"/><p>For frequencies where <span>$\gamma$</span> is close to one, a linear model is expected to fit well, whereas for frequencies where <span>$\gamma$</span> is close to zero, we cannot trust the model. How does this rough estimate of model certainty translate to our control analysis? In the video <a href="https://youtu.be/uQx192FyA5g?si=kubWnq__ohWOaICw">The benefit and Cost of Feedback</a>, we show that for frequencies where the uncertainty in the model is large, we must have a small sensitivity. In the video, we analyzed the effects of additive uncertainty, in which case we need to make sure that the sensitivity function <span>$CS$</span> is sufficiently small. When using the rough estimate of model uncertainty provided by the coherence function, it may be more reasonable to consider a multiplicative (relative) uncertainty model, in which case we need to verify that the sensitivity function <span>$T = PC/(1+PC)$</span> is small for frequencies where <span>$\gamma$</span> is small. The pole-placement controller has a rather large gain in <span>$T$</span> for high frequencies, well above those where <span>$\gamma$</span> starts to drop. The only controller that abides by the principle of &quot;use low gain where the model uncertainty is large&quot; is the conservatively tuned PID controller. </p><p>In the <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/uncertainty/#Multiplicative-uncertainty">documentation of RobustAndOptimalControl.jl</a>, we list a number of common uncertainty models together with the criteria for robust stability. </p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This tutorial has shown how to follow a workflow that consists of</p><ol><li>Estimate a process model using experimental data.</li><li>Design a controller based on the estimated model. We designed two PID controllers, one aggressive and one conservative. We also designed a pole-placement controller which was able to cancel the resonances in the system which the PID controllers could not do.</li><li>Simulate the closed-loop system and analyze its robustness properties. Model uncertainty was considered using the coherence function. Only the conservatively tuned PID controller truly respected the model uncertainty.</li><li>Generate C-code for the pole-placement controller.</li></ol><p>Each of these steps is covered in additional detail in the videos available in the playlist <a href="https://youtube.com/playlist?list=PLC0QOsNQS8hZtOQPHdtul3kpQwMOBL8Qc&amp;si=yUrXz5cH4QqTPlR_">Control systems in Julia</a>. See also the tutorial <a href="https://help.juliahub.com/juliasimcontrol/dev/examples/quadtank/">Control design for a quadruple-tank system</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../automatic_differentiation/">« Automatic differentiation</a><a class="docs-footer-nextpage" href="../../lib/constructors/">Constructors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Thursday 12 October 2023 12:08">Thursday 12 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
