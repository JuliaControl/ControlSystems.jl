<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Iterative Learning Control (ILC) · ControlSystems.jl</title><meta name="title" content="Iterative Learning Control (ILC) · ControlSystems.jl"/><meta property="og:title" content="Iterative Learning Control (ILC) · ControlSystems.jl"/><meta property="twitter:title" content="Iterative Learning Control (ILC) · ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example/">Design</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li><a class="tocitem" href="../smith_predictor/">Smith predictor</a></li><li class="is-active"><a class="tocitem" href>Iterative Learning Control (ILC)</a><ul class="internal"><li><a class="tocitem" href="#Algorithm"><span>Algorithm</span></a></li><li><a class="tocitem" href="#System-model-and-controller"><span>System model and controller</span></a></li><li><a class="tocitem" href="#Reference-trajectory"><span>Reference trajectory</span></a></li><li><a class="tocitem" href="#Non-causal-filtering"><span>Non-causal filtering</span></a></li><li><a class="tocitem" href="#Choosing-filters"><span>Choosing filters</span></a></li><li><a class="tocitem" href="#ILC-iteration"><span>ILC iteration</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../automatic_differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../tuning_from_data/">Tune a controller using experimental data</a></li><li><a class="tocitem" href="../zoh/">Analysis of sampled-data (continuous/discrete) systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../../lib/constructors/">Constructors</a></li><li><a class="tocitem" href="../../lib/analysis/">Analysis</a></li><li><a class="tocitem" href="../../lib/synthesis/">Synthesis</a></li><li><a class="tocitem" href="../../lib/timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../../lib/plotting/">Plotting</a></li><li><a class="tocitem" href="../../lib/nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Iterative Learning Control (ILC)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Iterative Learning Control (ILC)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/examples/ilc.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Iterative-Learning-Control"><a class="docs-heading-anchor" href="#Iterative-Learning-Control">Iterative-Learning Control</a><a id="Iterative-Learning-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Learning-Control" title="Permalink"></a></h1><p>In this example, we will design an <a href="https://en.wikipedia.org/wiki/Iterative_learning_control">Iterative-Learning Control (ILC)</a> iteration scheme. ILC can be thought of as a simple reinforcement-learning strategy that is suitable in situations where a <em>repetitive task</em> is to be performed multiple times, and disturbances acting on the system are also repetitive and predictable but unknown. Multiple versions of ILC exists, in this tutorial we will consider a heuristic scheme as well as a model-based scheme. </p><div class="admonition is-info" id="Note-18caa23df4ebb245"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-18caa23df4ebb245" title="Permalink"></a></header><div class="admonition-body"><p>See the Julia package <a href="https://baggepinnen.github.io/IterativeLearningControl2.jl/dev/">IterativeLearningControl2.jl</a> for implementations of several different ILC algorithms.</p></div></div><h2 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h2><p>The ILC iteration scheme typically looks something like this (many variants exists), at ILC iteration <span>$k$</span>:</p><p class="math-container">\[\begin{aligned}
y_k(t) &amp;= G(q) \big(r(t) + a_k(t) \big) \\
e_k(t) &amp;= r(t) - y_k(t) \\
a_k(t) &amp;= Q(q) \big( a_{k-1}(t) + L(q) e_{k-1}(t) \big)
\end{aligned}\]</p><p>where <span>$q$</span> is the time-shift operator, <span>$G(q)$</span> is the transfer function from the reference <span>$r$</span> to the output <span>$y$</span>, i.e, typically a closed-loop transfer function, <span>$e_k$</span> is the control error and <span>$a_k$</span> is the ILC adjustment signal, an additive correction to the reference that is learned throughout the ILC iterations in order to minimize the control error. <span>$Q(q)$</span> and <span>$L(q)$</span> are stable filters that control the learning dynamics. Interestingly, these filters does not have to be causal since they operate on the signals <span>$e$</span> and <span>$a$</span> <em>between</em> ILC iterations, when the whole signals are available at once for acausal filtering. </p><p>In simulation (the rollout <span>$y_k = G(q) (r + a_k)$</span> is simulated), this scheme is nothing other than an open-loop optimal-control strategy, while if <span>$y_k = G(q) (r + a_k)$</span> amounts to performing an actual experiment on a process, ILC turns into episode-based reinforcement learning or adaptive control.</p><p>The system to control in this example is a double-mass system with a spring and damper in between. This system is a common model of a servo system where one mass represents the motor and the other represents the load. The spring and damper represents a flexible transmission between them. We will create two instances of the system model. <span>$G$</span> represents the nominal model, whereas <span>$G_{act}$</span> represents the actual (unknown) dynamics. This simulates a model-based approach where there is a slight error in the model. The error will lie in the mass of the load, simulating, e.g., that the motor is driving a heavier load than specified. </p><h2 id="System-model-and-controller"><a class="docs-heading-anchor" href="#System-model-and-controller">System model and controller</a><a id="System-model-and-controller-1"></a><a class="docs-heading-anchor-permalink" href="#System-model-and-controller" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ControlSystemsBase, Plots

function double_mass_model(;
                Jm = 1,   # motor inertia
                Jl = 1,   # load inertia
                k  = 100, # stiffness
                c0 = 1,   # motor damping
                c1 = 1,   # transmission damping
                c2 = 1,   # load damping
)

    A = [
        0.0 1 0 0
        -k/Jm -(c1 + c0)/Jm k/Jm c1/Jm
        0 0 0 1
        k/Jl c1/Jl -k/Jl -(c1 + c2)/Jl
    ]
    B = [0, 1/Jm, 0, 0]
    C = [1 0 0 0]
    ss(A, B, C, 0)
end

G    = double_mass_model(Jl = 1)
Gact = double_mass_model(Jl = 1.5) # 50% more load than modeled

bodeplot([G, Gact], lab=[&quot;G model&quot; &quot;G actual&quot;], plotphase=false)</code></pre><img src="56b4a2fc.svg" alt="Example block output"/><p>We will design a PID controller with a filter for the system, the controller is poorly tuned and not very good at tracking fast reference steps, in practice, one would likely design a feedforward controller as well to improve upon this, but for now we&#39;ll stick with the simple feedback controller.</p><pre><code class="language-julia hljs">C  = pid(10, 1, 1, form = :series) * tf(1, [0.02, 1])
Ts = 0.02 # Sample time
Gc = c2d(feedback(G*C), Ts)       |&gt; tf
Gcact = c2d(feedback(Gact*C), Ts) |&gt; tf
plot(step(Gc, 10), title=&quot;Closed-loop step response&quot;, lab=&quot;model&quot;)
plot!(step(Gcact, 10), lab=&quot;actual&quot;)</code></pre><img src="e9215a85.svg" alt="Example block output"/><h2 id="Reference-trajectory"><a class="docs-heading-anchor" href="#Reference-trajectory">Reference trajectory</a><a id="Reference-trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-trajectory" title="Permalink"></a></h2><p>Next up we design a reference trajectory and simulate the actual closed-loop dynamics.</p><pre><code class="language-julia hljs">T = 3pi    # Duration
t = 0:Ts:T # Time vector
function funnysin(x)
    x = sin(x)
    s,a = sign(x), abs(x)
    s*((a + 0.01)^0.2 - 0.01^0.2)
end
r = funnysin.(t)&#39; |&gt; Array # Reference signal

res = lsim(Gcact, r, t)
plot(res, plotu=true, layout=1, sp=1, title=&quot;Closed-loop simulation with actual dynamics&quot;, lab=[&quot;y&quot; &quot;r&quot;])</code></pre><img src="56b28d55.svg" alt="Example block output"/><p>Performance is poor.. Enter ILC!</p><h2 id="Non-causal-filtering"><a class="docs-heading-anchor" href="#Non-causal-filtering">Non-causal filtering</a><a id="Non-causal-filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Non-causal-filtering" title="Permalink"></a></h2><p>For ILC to work well, we define two helper functions. One that applies a zero-phase filter by filtering both forwards and backwards (<code>filtfilt</code>). This is possible since ILC operates on signals offline, between iterations in the ILC scheme. We also define a special <code>lsim</code> that handles non-causal systems to allow &quot;lookahead&quot; into the future. This typically improves the performance of ILC by quite a lot, and is once again possible since ILC operates on prerecorded signals. </p><pre><code class="language-julia hljs">function lsim_zerophase(G, u, args...; kwargs...)
    res = lsim(G, u[:, end:-1:1], args...; kwargs...)
    lsim(G, res.y[:, end:-1:1], args...; kwargs...).y
end

function lsim_noncausal(L::LTISystem{&lt;:Discrete}, u, args...; kwargs...)
    np = length(denpoly(L)[])
    nz = length(numpoly(L)[])
    zeroexcess = nz-np
    if zeroexcess &lt;= 0
        return lsim(L, u, args...; kwargs...)
    end
    integrators = tf(1, [1, 0], L.Ts)^zeroexcess
    res = lsim(L*integrators, u, args...; kwargs...)
    res.y[1:end-zeroexcess] .= res.y[1+zeroexcess:end]
    res.y
end</code></pre><h2 id="Choosing-filters"><a class="docs-heading-anchor" href="#Choosing-filters">Choosing filters</a><a id="Choosing-filters-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-filters" title="Permalink"></a></h2><p>The next step is to define the ILC filters <span>$Q(q)$</span> and <span>$L(q)$</span>.</p><p>The filter <span>$L(q)$</span> acts as a frequency-dependent step size. To make the procedure take smaller steps, simply scale <span>$L$</span> by a constant &lt; 1. Scaling down <span>$L$</span> makes the learning process slower but more robust. A heuristic choice of <span>$L$</span> is some form of scaled lookahead, such as <span>$0.5z^l$</span> where <span>$l \geq 0$</span> is the number of samples lookahead. A model-based approach may use some form of inverse of the system model, which is what we will use here. <sup class="footnote-reference"><a id="citeref-nonlinear" href="#footnote-nonlinear">[nonlinear]</a></sup></p><p>The filter <span>$Q(q)$</span> acts to make the procedure robust w.r.t. noise and modeling errors. <span>$Q$</span> has a final say over what frequencies appear in <span>$a$</span> and it&#39;s good to choose <span>$Q$</span> with low-pass properties. <span>$Q$</span> will here be applied in zero-phase mode, so the effective transfer function will be <span>$Q(z)Q(z̄)$</span>.</p><pre><code class="language-julia hljs">z = tf(&quot;z&quot;, Ts)
Q = c2d(tf(1, [0.05, 1]), Ts)
# L = 0.9z^1 # A more conservative and heuristic choice
L = 0.5inv(Gc) # Make the scaling factor smaller to take smaller steps</code></pre><p>A theorem due to Norrlöf says that for the ILC iterations to converge, one needs to satisfy <span>$| 1 - LG | &lt; |Q^{-1}|$</span> which we can verify by looking at the Bode curves of the two sides of the inequality</p><pre><code class="language-julia hljs">bodeplot([inv(Q), (1 - L*Gc)], plotphase=false, lab=[&quot;Stability boundary \$Q^{-1}\$&quot; &quot;\$1 - LG\$&quot;])
bodeplot!((1 - L*Gcact), plotphase=false, lab=&quot;\$1 - LG\$ actual&quot;)</code></pre><img src="fb96c460.svg" alt="Example block output"/><p>Above, we plotted this curve also for the actual dynamics. This is of course not possible in a real scenario where this is unknown, but one could plot it for multiple plausible models and verify that they are all below the boundary. See <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/uncertainty/">Uncertainty modeling using RobustAndOptimalControl.jl</a> for guidance on this. Looking at the stability condition, it becomes obvious how making <span>$Q$</span> small where the model is uncertain is beneficial for robustness of the ILC scheme.</p><h2 id="ILC-iteration"><a class="docs-heading-anchor" href="#ILC-iteration">ILC iteration</a><a id="ILC-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#ILC-iteration" title="Permalink"></a></h2><p>The next step is to implement the ILC scheme and run it:</p><pre><code class="language-julia hljs">function ilc(Gc, Q, L)
    a = zero(r) # ILC adjustment signal starts at 0
    fig1 = plot(t, vec(r), sp=1, layout=(3,1), l=(:black, 3), lab=&quot;Ref&quot;)
    fig2 = plot(title=&quot;Sum of squared error&quot;, xlabel=&quot;Iteration&quot;, legend=false, titlefontsize=10, framestyle=:zerolines, ylims=(0, 7.1))
    for iter = 1:5
        ra = r .+ a
        res = lsim(Gc, ra, t) # Simulate system, replaced by an actual experiment if running on real process
        y = res.y             # System response
        e = r .- y            # Error
        Le = lsim_noncausal(L, e, t)
        a  = lsim_zerophase(Q, a + Le, t) # Update ILC adjustment

        err = sum(abs2, e)
        plot!(fig1, res, plotu=true, sp=[1 2], title=[&quot;Output \$y(t)\$&quot; &quot;Adjusted reference \$r + a\$&quot;], lab=&quot;Iter $iter&quot;, c=iter)
        plot!(fig1, e[:], sp=3, title=&quot;Tracking error \$e(t)\$&quot;, lab=&quot;err: $(round(err, digits=2))&quot;, c=iter)
        scatter!(fig2, [iter], [err])
    end
    plot(fig1, fig2, layout=@layout([a{0.7w} b{0.3w}]))
end
ilc(Gc, Q, L)</code></pre><img src="b80816c0.svg" alt="Example block output"/><p>When running on the model, the result looks very good. We see that the tracking error in the last plot decreases rapidly and is much smaller after only a couple of iterations. We also note that the adjusted reference <span>$r+a$</span> has effectively been phase-advanced slightly to compensate for the lag in the system dynamics. This is an effect of the acausal filtering due to <span>$L = G_C^{-1}$</span>.</p><p>How does it work on the &quot;actual&quot; dynamics?</p><pre><code class="language-julia hljs">ilc(Gcact, Q, L)</code></pre><img src="e89d1c75.svg" alt="Example block output"/><p>The result is subtly worse, but considering the rather big model error the result is still quite good. </p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>We have seen how ILC can be used to improve tracking performance in a scenario where a repetitive task is to be executed several times. In simulation like here, ILC can be seen as an optimal-control strategy to come up with a optimal reference trajectory to minimize the control error, while if implemented on a physical process, the scheme amounts to a simple but effective reinforcement-learning or adaptive-control approach. ILC often works very well in practice and has been used in robotics and machining among other areas. </p><p>ILC does not work very well if stochastic disturbances dictate the control performance or a task is to be performed only a small number of times. In, e.g., machining applications, each ILC iteration may imply performing destructive machining on expensive material with suboptimal result before convergence. This may only be cost effective if the task is to be performed many times after an initial &quot;tuning&quot; by means of ILC.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-nonlinear"><a class="tag is-link" href="#citeref-nonlinear">nonlinear</a>Inverse models can be formed also for some nonlinear systems. <a href="https://mtk.sciml.ai/dev/">ModelingToolkit.jl</a> is particularily well suited for inverting models due to its acausal nature.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../smith_predictor/">« Smith predictor</a><a class="docs-footer-nextpage" href="../delay_systems/">Properties of delay systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Monday 9 June 2025 13:02">Monday 9 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
