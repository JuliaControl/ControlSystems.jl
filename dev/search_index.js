var documenterSearchIndex = {"docs":
[{"location":"examples/example/","page":"Design","title":"Design","text":"DocTestSetup = quote\n    using ControlSystems, Plots\n    plotsDir = joinpath(dirname(pathof(ControlSystems)), \"..\", \"docs\", \"build\", \"plots\")\n    mkpath(plotsDir)\n    nyquistplot(ssrand(1,1,1)) # to get the warning for hover already here\n    save_docs_plot(name) = (Plots.savefig(joinpath(plotsDir,name)); nothing)\n    save_docs_plot(p, name) = (Plots.savefig(p, joinpath(plotsDir,name)); nothing)\nend","category":"page"},{"location":"examples/example/#Examples","page":"Design","title":"Examples","text":"","category":"section"},{"location":"examples/example/#LQR-design","page":"Design","title":"LQR design","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"The infinite-horizon LQR controller is derived as the linear state-feedback u = -Lx that minimizes the following quadratic cost function","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"L = textargmin_L int_0^infty x^T Q x + u^T R u  dt","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"where x is the state vector and u is the input vector.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"The example below performs a simple LQR design for a double integrator in discrete time using the function lqr. In this example, we will use the method of lsim that accepts a function u(x t) as input. This allows us to easily simulate the system both control input and a disturbance input. For more advanced LQR and LQG design, see the LQGProblem type in RobustAndOptimalControl.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystemsBase\nusing LinearAlgebra # For identity matrix I\nusing Plots\n\n# Create system\nTs      = 0.1\nA       = [1 Ts; 0 1]\nB       = [0; 1]\nC       = [1 0]\nsys     = ss(A,B,C,0,Ts)\n\n# Design controller\nQ       = I # Weighting matrix for state\nR       = I # Weighting matrix for input\nL       = lqr(Discrete,A,B,Q,R) # lqr(sys,Q,R) can also be used\n\n# Simulation\nu(x,t)  = -L*x .+ 1.5(t>=2.5) # Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t≧2.5\nt       = 0:Ts:5              # Time vector\nx0      = [1,0]               # Initial condition\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x', lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"To design an LQG controller (LQR with a Kalman filter), see the functions","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"kalman\nobserver_controller\nLQGProblem type in RobustAndOptimalControl.","category":"page"},{"location":"examples/example/#PID-design-functions","page":"Design","title":"PID design functions","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"A basic PID controller can be constructed using the constructor pid. In ControlSystems.jl, we often refer to three different formulations of the PID controller, which are defined as","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Standard form: K_p(1 + frac1T_i s + T_ds)\nSeries form: K_c(1 + frac1τ_i s)(τ_d s + 1)\nParallel form: K_p + fracK_is + K_d s","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Most functions that construct PID controllers allow the user to select which form to use.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"The following examples show basic workflows for designing PI/PID controllers. ","category":"page"},{"location":"examples/example/#PI-loop-shaping-example","page":"Design","title":"PI loop shaping example","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"By plotting the gang of four under unit feedback for the process","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"P(s) = dfrac1(s + 1)^4","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystemsBase, Plots\nP = tf(1, [1,1])^4\ngangoffourplot(P, tf(1))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"we notice that the sensitivity function is a bit too high around frequencies ω = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function loopshapingPI and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystemsBase, Plots\nP = tf(1, [1,1])^4\nωp = 0.8\nC,kp,ki,fig = loopshapingPI(P,ωp,phasemargin=60,form=:parallel, doplot=true)\nfig","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"We could also consider a situation where we want to create a closed-loop system with the bandwidth ω = 2 rad/s, in which case we would write something like","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"ωp = 2\nC60,kp,ki,fig = loopshapingPI(P,ωp,rl=1,phasemargin=60,form=:standard,doplot=true)\nfig","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Here we specify that we want the Nyquist curve L(iω) = P(iω)C(iω) to pass the point |L(iω)| = rl = 1,  arg(L(iω)) = -180 + phasemargin = -180 + 60 The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles.","category":"page"},{"location":"examples/example/#PID-loop-shaping","page":"Design","title":"PID loop shaping","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"Processes with inertia, like double integrators, require a derivative term in the controller for good results. The function loopshapingPID allows you to specify a point in the Nyquist plane where the loop-transfer function  L(s) = P(s)C(s) should be tangent to the circle that denotes T = dfracPC1 + PC = M_t The tangent point is specified by specifying M_t and the angle phi_t between the real axis and the tangent point, indicated in the Nyquist plot below.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystemsBase, Plots\nP  = tf(1, [1,0,0]) # A double integrator\nMt = 1.3            # Maximum magnitude of complementary sensitivity\nϕt = 75             # Angle of tangent point\nω  = 1              # Frequency at which the specification holds\nC, kp, ki, kd, fig = loopshapingPID(P, ω; Mt, ϕt, doplot=true)\nfig","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"To get good robustness, we typically aim for a M_t less than 1.5. In general, the smaller M_t we require, the larger the controller gain will be.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Since we are designing a PID controller, we expect a large controller gain for high frequencies. This is generally undesirable for both robustness and noise reasons, and is commonly solved by introducing a lowpass filter in series with the controller. The example below passes the keyword argument Tf=1/20ω to indicate that we want to add a second-order lowpass filter with a cutoff frequency 20 times faster than the design frequency.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Tf = 1/20ω\nC, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt, doplot=true, Tf)\nfig","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"As we can see, the addition of the filter increases the high-frequency roll-off in both T and CS, which is typically desireable.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"To get better control over the filter, it can be pre-designed and supplied to loopshapingPID with the keyword argument F:","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"F = tf(1, [Tf^2, 2*Tf/sqrt(2), 1])\nC, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt, doplot=true, F)","category":"page"},{"location":"examples/example/#Advanced-pole-zero-placement","page":"Design","title":"Advanced pole-zero placement","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"This example illustrates how we can perform advanced pole-zero placement using the function rstc (rstd in discrete time). The task is to make the process P a bit faster and damp the poorly damped poles.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Define the process","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"ζ = 0.2\nω = 1\n\nB = [1]\nA = [1, 2ζ*ω, ω^2]\nP = tf(B,A)","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Define the desired closed-loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystems\nimport DSP: conv\n# Control design\nζ0 = 0.7\nω0 = 2\nAm = [1, 2ζ0*ω0, ω0^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB⁺  = [1] # The process numerator polynomial can be facored as B = B⁺B⁻ where B⁻ contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB⁻  = [1]\nBm  = conv(B⁺, B⁻) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B⁺,B⁻,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nplot(step(P, 20))\nplot!(step(Gcl, 20)) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/example/#Stability-boundary-for-PID-controllers","page":"Design","title":"Stability boundary for PID controllers","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"The stability boundary, i.e., the surface of PID parameters where the transfer function P(s)C(s) equals -1, can be plotted with the command stabregionPID. The process can be given in function form or as a regular LTIsystem.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"P1 = s -> exp(-sqrt(s))\ndoplot = true\nform = :parallel\nkp, ki, f1 = stabregionPID(P1,exp10.(range(-5, stop=1, length=1000)); doplot, form); f1\nP2 = s -> 100*(s+6).^2. /(s.*(s+1).^2. *(s+50).^2)\nkp, ki, f2 = stabregionPID(P2,exp10.(range(-5, stop=2, length=1000)); doplot, form); f2\nP3 = tf(1,[1,1])^4\nkp, ki, f3 = stabregionPID(P3,exp10.(range(-5, stop=0, length=1000)); doplot, form); f3","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/example/#PID-plots","page":"Design","title":"PID plots","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"This example utilizes the function pidplots, which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"using ControlSystemsBase\nP = tf([1.], [1., 1])\n\nζ = 0.5 # Desired damping\nws = exp10.(range(-1, stop=2, length=8)) # A vector of closed-loop bandwidths\nkp = 2*ζ*ws .- 1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\n\nω = exp10.(range(-3, stop = 2, length = 500))\npidplots(\n    P,\n    :nyquist;\n    params_p = kp,\n    params_i = ki,\n    ω = ω,\n    ylims = (-2, 2),\n    xlims = (-3, 3),\n    form = :parallel,\n)\npidplots(P, :gof; params_p = kp, params_i = ki, ω = ω, legend = false, form=:parallel, legendfontsize=6, size=(1000, 1000))\n# You can also request both Nyquist and Gang-of-four plots (more plots are available, see ?pidplots ):\n# pidplots(P,:nyquist,:gof;kps=kp,kis=ki,ω=ω);","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Now try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"kp = range(-1, stop=1, length=8) #\nki = sqrt.(1 .- kp.^2)/10\n\npidplots(P,:nyquist,;params_p=kp,params_i=ki,ylims=(-1,1),xlims=(-1.5,1.5), form=:parallel)\npidplots(P,:gof,;params_p=kp,params_i=ki,legend=false,ylims=(0.08,8),xlims=(0.003,20), form=:parallel, legendfontsize=6, size=(1000, 1000))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/example/#Further-examples","page":"Design","title":"Further examples","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"See the examples folder as well as the notebooks in ControlExamples.jl.\nSee also the paper introducing the toolbox with supplementary material.\nSee the docs for RobustAndOptimalControl.jl for additional examples.","category":"page"},{"location":"man/creating_systems/#Creating-Systems","page":"Creating Systems","title":"Creating Systems","text":"","category":"section"},{"location":"man/creating_systems/#Transfer-Functions","page":"Creating Systems","title":"Transfer Functions","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"DocTestSetup = quote\n    using ControlSystems\nend","category":"page"},{"location":"man/creating_systems/#tf-Rational-Representation","page":"Creating Systems","title":"tf - Rational Representation","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The syntax for creating a transfer function is tf","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf(num, den)     # Continuous-time system\ntf(num, den, Ts) # Discrete-time system","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"where num and den are the polynomial coefficients of the numerator and denominator of the polynomial and Ts, if provided, is the sample time for a discrete-time system.","category":"page"},{"location":"man/creating_systems/#Example:","page":"Creating Systems","title":"Example:","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf([1.0],[1,2,1])\n\n# output\n\nTransferFunction{Continuous, ControlSystemsBase.SisoRational{Float64}}\n        1.0\n-------------------\n1.0s^2 + 2.0s + 1.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The transfer functions created using this method will be of type TransferFunction{SisoRational}.","category":"page"},{"location":"man/creating_systems/#zpk-Pole-Zero-Gain-Representation","page":"Creating Systems","title":"zpk - Pole-Zero-Gain Representation","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Sometimes it's better to represent the transfer function by its poles, zeros and gain, this can be done using the function zpk","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"zpk(zeros, poles, gain)     # Continuous-time system\nzpk(zeros, poles, gain, Ts) # Discrete-time system","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"where zeros and poles are Vectors of the zeros and poles for the system and gain is a gain coefficient.","category":"page"},{"location":"man/creating_systems/#Example","page":"Creating Systems","title":"Example","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"zpk([-1.0,1], [-5, -10], 2)\n\n# output\n\nTransferFunction{Continuous, ControlSystemsBase.SisoZpk{Float64, Float64}}\n   (1.0s + 1.0)(1.0s - 1.0)\n2.0-------------------------\n   (1.0s + 5.0)(1.0s + 10.0)\n\nContinuous-time transfer function model","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The transfer functions created using this method will be of type TransferFunction{SisoZpk}.","category":"page"},{"location":"man/creating_systems/#State-Space-Systems","page":"Creating Systems","title":"State-Space Systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"A state-space system is created using","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"ss(A,B,C,D)    # Continuous-time system\nss(A,B,C,D,Ts) # Discrete-time system","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"and they behave similarly to transfer functions.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The ss constructor allows you to","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Pass 0 instead of a D matrix, and an appropriately sized zero matrix is created automatically.\nPass I instead of a C matrix, and an appropriately sized identity matrix is created automatically. The UniformScaling operator I lives in the LinearAlgebra standard library which must be loaded first.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"State-space systems with heterogeneous matrix types are also available, which can be used to create systems with static or sized matrices, e.g.,","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using ControlSystemsBase, StaticArrays\nsys = ss([-5 0; 0 -5],[2; 2],[3 3],[0])\nHeteroStateSpace(sys, to_sized)\nHeteroStateSpace(sys, to_static)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Notice the different matrix types used.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"To associate names with states, inputs and outputs, see named_ss from RobustAndOptimalControl.jl.","category":"page"},{"location":"man/creating_systems/#Converting-between-types","page":"Creating Systems","title":"Converting between types","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"It is sometime useful to convert one representation to another, this is possible using the constructors tf, zpk, ss, for example","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction{Discrete{Float64}, ControlSystemsBase.SisoRational{Int64}}\n2z + 2\n------\nz - 1\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model","category":"page"},{"location":"man/creating_systems/#Delay-Systems","page":"Creating Systems","title":"Delay Systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The constructor delay creates a pure delay, which may be connected to a system by multiplication:","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"delay(1.2)               # Pure delay or 1.2s\ntf(1, [1, 1])*delay(1.2) # Input delay\ndelay(1.2)*tf(1, [1, 1]) # Output delay","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Delayed systems can also be created using","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"s = tf(\"s\")\nL = 1.2 # Delay time\ntf(1, [1, 1]) * exp(-L*s)","category":"page"},{"location":"man/creating_systems/#Nonlinear-Systems","page":"Creating Systems","title":"Nonlinear Systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"See Nonlinear functionality.","category":"page"},{"location":"man/creating_systems/#Simplifying-systems","page":"Creating Systems","title":"Simplifying systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"A statespace system with a non-minimal realization, or a transfer function with overlapping zeros and poles, may be simplified using the function minreal. Systems that are structurally singular, i.e., that contains outputs that can not be reached from the inputs based on analysis of the structure of the zeros in the system matrices only, can be simplified with the function sminreal.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Examples:","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using ControlSystemsBase\nG = tf([1, 1], [1, 1])\nminreal(G) # Performs pole-zero cancellation\n\nP = tf(1, [1, 1]) |> ss\nG = P / (1 + P) # this creates a non-minimal realization, use feedback(P) instead\nfeedback(P) # Creates a minimal realization directly\nGmin = minreal(G) # this simplifies the realization to a minimal realization\nnorm(Gmin - feedback(P), Inf) # No difference\nbodeplot([G, Gmin, feedback(P)]) # They are all identical","category":"page"},{"location":"man/creating_systems/#Multiplying-systems","page":"Creating Systems","title":"Multiplying systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Two systems can be connected in series by multiplication","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using ControlSystemsBase\nP1 = ss(-1,1,1,0)\nP2 = ss(-2,1,1,0)\nP2*P1","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"If the input dimension of P2 does not match the output dimension of P1, an error is thrown. If one of the systems is SISO and the other is MIMO, broadcasted multiplication will expand the SISO system to match the input or output dimension of the MIMO system, e.g.,","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Pmimo = ssrand(2,2,1)\nPsiso = ss(-2,1,1,0)\n# Psiso * Pmimo # error\nPsiso .* Pmimo ≈ [Psiso 0; 0 Psiso] * Pmimo # Broadcasted multiplication expands SISO into diagonal system","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Broadcasted multiplication between a system and an array is only allowed for diagonal arrays","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using LinearAlgebra\nPsiso .* I(2)","category":"page"},{"location":"man/creating_systems/#MIMO-systems-and-arrays-of-systems","page":"Creating Systems","title":"MIMO systems and arrays of systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Concatenation of systems creates MIMO systems, which is different from an array of systems. For example","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using ControlSystemsBase\nP = ss(-1,1,1,0)\nP_MIMO = [P 2P]","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"is a 1×2 MISO system, not a 1×2 array.","category":"page"},{"location":"man/creating_systems/#From-SISO-to-MIMO","page":"Creating Systems","title":"From SISO to MIMO","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"SISO systems do not multiply MIMO systems directly, i.e.,","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using Test\nsiso = ss(-1,1,1,0)\nmimo = ssrand(2,2,2)\n@test_throws DimensionMismatch siso * mimo","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"To multiply siso with each output channel of mimo in the example above, use broadcasting:","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"siso .* mimo","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"This is equivalent to first expanding the SISO system into a diagonal system","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using LinearAlgebra\n(siso .* I(2)) * mimo","category":"page"},{"location":"man/creating_systems/#Converting-an-array-of-systems-to-a-MIMO-system","page":"Creating Systems","title":"Converting an array of systems to a MIMO system","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Diagonal MIMO systems can be created from a vector of systems using append","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"P1 = ssrand(1,1,1)\nP2 = ssrand(1,1,1)\nappend(P1, P2)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"More general arrays of systems can be converted to a MIMO system using array2mimo.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"sys_array = fill(P, 2, 2) # Creates an array of systems\nmimo_sys = array2mimo(sys_array)","category":"page"},{"location":"man/creating_systems/#Converting-MIMO-system-to-an-array-of-systems","page":"Creating Systems","title":"Converting MIMO system to an array of systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"This conversion is not explicitly supported, but is easy enough to accomplish with standard Julia code, for example:","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"P = ssrand(2,3,1) # A random 2×3 MIMO system\nsys_array = getindex.(Ref(P), 1:P.ny, (1:P.nu)')","category":"page"},{"location":"man/creating_systems/#Creating-arrays-with-different-types-of-systems","page":"Creating Systems","title":"Creating arrays with different types of systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"When calling hcat/vcat, Julia automatically tries to promote the types to the smallest common supertype, this means that creating an array with one continuous and one discrete-time system fails","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"P_cont = ssrand(2,3,1) \nP_disc = ssrand(2,3,1, Ts=1)\n@test_throws ErrorException [P_cont, P_disc] # ERROR: Sampling time mismatch","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"You can explicitly tell Julia that you want a particular supertype, e.g,","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"StateSpace[P_cont, P_disc]","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The type StateSpace is abstract, since the type parameters are not specified.","category":"page"},{"location":"man/creating_systems/#Demo-systems","page":"Creating Systems","title":"Demo systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The module ControlSystemsBase.DemoSystems contains a number of demo systems demonstrating different kinds of dynamics.","category":"page"},{"location":"man/creating_systems/#From-block-diagrams-to-code","page":"Creating Systems","title":"From block diagrams to code","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"This section lists a number of block diagrams, and indicates the corresponding transfer functions and how they are built in code.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The function feedback(G1, G2) can be thought of like this: the first argument G1 is the system that appears directly between the input and the output, while the second argument G2 (defaults to 1 if omitted) contains all other systems that appear in the closed loop. The feedback is assumed to be negative, unless the argument pos_feedback = true is passed (lft is an exception, which due to convention defaults to positive feedback).","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Closed-loop system from reference to output","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"r   ┌─────┐     ┌─────┐\n───►│     │  u  │     │ y\n    │  C  ├────►│  P  ├─┬─►\n -┌►│     │     │     │ │\n  │ └─────┘     └─────┘ │\n  │                     │\n  └─────────────────────┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Y = dfracPCI+PCR","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: feedback(P*C) or equivalently comp_sensitivity(P, C). Here, the system PC appears directly between the input r and the output y, and the feedback loop is negative identity. We thus call feedback(P*C) = feedback(P*C, 1)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"d     ┌───┐   y\n───+─►│ P ├─┬───►\n  -▲  └───┘ │\n   │        │\n   │  ┌───┐ │\n   └──┤ C │◄┘\n      └───┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Y = dfracPI+PCD = PSD","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: feedback(P, C) or equivalently G_PS(P, C). Here, only P appears directly between d and y, while C appears first in the feedback loop. We thus call feedback(P, C)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Sensitivity function at plant input","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"d    e┌───┐   \n───+─►│ P ├─┬───►\n  -▲  └───┘ │\n   │        │\n   │  ┌───┐ │\n   └──┤ C │◄┘\n      └───┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"E = dfrac1I+CPD = SD","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: feedback(1, C*P) or equivalently input_sensitivity(P, C). Here, there are no systems directly between the input and the output, we thus call feedback(1, C*P). Note the order in C*P, which is important for MIMO systems. This computes the sensitivity function at the plant input. It's more common to analyze the sensitivity function at the plant output, illustrated below (for SISO systems they are equivalent).","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Sensitivity function at plant output","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"      ┌───┐   \n───+─►│ P ├─+◄── e\n  -▲  └───┘ │\n   │        │y\n   │  ┌───┐ │\n   └──┤ C │◄┘\n      └───┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Y = dfrac1I+PCE = SE","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: feedback(1, P*C) or equivalently output_sensitivity(P, C). Note the reverse order in PC compared to the input sensitivity function above.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Reference r and input disturbance d to output y and control signal u. This example forms the transfer function matrix with r and d as inputs, and y and u as outputs.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"              d\n     ┌─────┐  │  ┌─────┐\nr    │     │u ▼  │     │ y\n──+─►│  C  ├──+─►│  P  ├─┬─►\n  ▲  │     │     │     │ │\n -│  └─────┘     └─────┘ │\n  │                      │\n  └──────────────────────┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"beginbmatrix\ny  u\nendbmatrix = \nbeginbmatrix\ndfracPCI + PC  dfracCI + PC \ndfracPI + PC  dfrac-PCI + PC\nendbmatrix\nbeginbmatrix\nr  d\nendbmatrix","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: feedback(C, P, W2=:, Z2=:, Zperm=[(1:P.ny).+P.nu; 1:P.nu]) # y,u from r,d. Here, we have reversed the order of P and C to get the correct sign of the control signal. We also make use of the keyword arguments W2 and Z2 to specify that we want to include the inputs and outputs of P as external inputs and outputs, and Zperm to specify the order of the outputs (y before u).","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Linear fractional transformation","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"     ┌─────────┐\nz◄───┤         │◄────w\n     │    P    │\ny┌───┤         │◄───┐u\n │   └─────────┘    │\n │                  │\n │      ┌───┐       │\n │      │   │       │\n └─────►│ K ├───────┘\n        │   │\n        └───┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Z = operatornamelft(P K) W","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: lft(P, K)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"      z1          z2\n      ▲  ┌─────┐  ▲      ┌─────┐\n      │  │     │  │      │     │\nw1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐\n    │    │     │      │  │     │ │\n    │    └─────┘      │  └─────┘ │\n    │                 w2         │\n    └────────────────────────────┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The transfer function from w_1 w_2 to z_1 z_2 contains all the transfer functions that are commonly called \"gang of four\" (see also gangoffour).","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"beginbmatrix\nz_1  z_2\nendbmatrix = \nbeginbmatrix\nI  C\nendbmatrix (I + PC)^-1 beginbmatrix\nI  P\nendbmatrix\nbeginbmatrix\nw_1  w_2\nendbmatrix","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Code: This function requires the package RobustAndOptimalControl.jl.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"RobustAndOptimalControl.extended_gangoffour(P, C, pos=true)\n# For SISO P\nS  = G[1, 1]\nPS = G[1, 2]\nCS = G[2, 1]\nT  = G[2, 2]\n\n# For MIMO P\nS  = G[1:P.ny,     1:P.nu]\nPS = G[1:P.ny,     P.nu+1:end]\nCS = G[P.ny+1:end, 1:P.nu]\nT  = G[P.ny+1:end, P.nu+1:end]","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"See also","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"output_sensitivity\ninput_sensitivity\noutput_comp_sensitivity\ninput_comp_sensitivity\nG_PS\nG_CS\ngangoffour)\ngangoffourplot)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"This diagram is more complicated and forms several connections, including both feedforward and feedback connections. A code file that goes through how to form such complicated connections using named signals is linked below. This example uses the package RobustAndOptimalControl.jl.","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │- └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"See code example complicated_feedback.jl.","category":"page"},{"location":"man/numerical/#Performance-considerations","page":"Performance considerations","title":"Performance considerations","text":"","category":"section"},{"location":"man/numerical/#Numerical-accuracy","page":"Performance considerations","title":"Numerical accuracy","text":"","category":"section"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"Transfer functions, and indeed polynomials in general, are infamous for having poor numerical properties. Consider the simple polynomial ax^n - 1 which, due to rounding of the polynomial coefficients, is represented as (a+epsilon)x^n - 1 where epsilon is on the order of eps(a). The roots of this polynomial have a much larger epsilon, due to the n:th root in the expression dfrac1sqrtn(a + epsilon). For this reason, it's ill-advised to use high-order transfer functions. Orders as low as 6 may already be considered high. When a transfer function is converted to a state-space representation using ss(G), balancing is automatically performed in an attempt at making the numerical properties of the model better.","category":"page"},{"location":"man/numerical/#Frequency-response-calculation","page":"Performance considerations","title":"Frequency-response calculation","text":"","category":"section"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"For small systems (small number of inputs, outputs and states), evaluating the frequency-response of a transfer function is reasonably accurate and very fast.","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"G = tf(1, [1, 1])\nw = exp10.(LinRange(-2, 2, 200));\n@btime freqresp($G, $w);\n# 4.351 μs (2 allocations: 3.31 KiB)","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"Evaluating the frequency-response for the equivalent state-space system incurs some additional allocations due to a Hessenberg matrix factorization","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"sys = ss(G);\n@btime freqresp($sys, $w);\n# 20.820 μs (16 allocations: 37.20 KiB)","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"For larger systems, the state-space calculations are considerably more accurate, provided that the realization is well balanced.","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"For optimal performance, one may preallocate the return array","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"ny,nu = size(G)\nR = zeros(ComplexF64, ny, nu, length(w));\n\n@btime freqresp!($R, $G, $w);\n# 4.214 μs (1 allocation: 64 bytes)","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"Other functions that accept preallocated workspaces are","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"bodemag!\nfreqresp!\nlsim!","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"an example using bodemag! follows:","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"using ControlSystemsBase\nG = tf(ssrand(2,2,5))\nw = exp10.(LinRange(-2, 2, 20000))\n@btime bode($G, $w);\n# 55.120 ms (517957 allocations: 24.42 MiB)\n@btime bode($G, $w, unwrap=false); # phase unwrapping is slow\n# 3.624 ms (7 allocations: 2.44 MiB)\nws = ControlSystemsBase.BodemagWorkspace(G, w)\n@btime bodemag!($ws, $G, $w);\n# 2.991 ms (1 allocation: 64 bytes)","category":"page"},{"location":"man/numerical/#Time-domain-simulation","page":"Performance considerations","title":"Time-domain simulation","text":"","category":"section"},{"location":"man/numerical/#Time-scale","page":"Performance considerations","title":"Time scale","text":"","category":"section"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"When simulating a dynamical system in continuous time, a differential-equation integrator is used. These integrators are sensitive to the scaling of the equations, and may perform poorly for stiff problems or problems with a poorly chosen time scale. In, e.g., electronics, it's common to simulate systems where the dominant dynamics have time constants on the order of microseconds. To simulate such systems accurately, it's often a good idea to model the system in microseconds rather than in seconds. The function time_scale can be used to automatically change the time scale of a system.","category":"page"},{"location":"man/numerical/#Transfer-functions","page":"Performance considerations","title":"Transfer functions","text":"","category":"section"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"Transfer functions are automatically converted to state-space form before time-domain simulation. If you want control over the exact internal representation used, consider modeling the system as a state-space system already from start. ","category":"page"},{"location":"man/numerical/#Discrete-time-simulation","page":"Performance considerations","title":"Discrete-time simulation","text":"","category":"section"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"Linear systems with zero-order-hold inputs can be exactly simulated in discrete time. You may specify ZoH-discretization in the call to lsim using method=:zoh or manually perform the discretization using c2d. Discrete-time simulation is often much faster than continuous-time integration.","category":"page"},{"location":"man/numerical/","page":"Performance considerations","title":"Performance considerations","text":"For discrete-time systems, the function lsim! accepts a pre-allocated workspace objects that can be used to avoid allocations for repeated simulations.","category":"page"},{"location":"examples/ilc/#Iterative-Learning-Control","page":"Iterative Learning Control (ILC)","title":"Iterative-Learning Control","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"In this example, we will design an Iterative-Learning Control (ILC) iteration scheme. ILC can be though of as a simple reinforcement-learning strategy that is suitable in situations where a repetitive task is to be performed multiple times, and disturbances acting on the system are also repetitive and predictable but unknown. Multiple versions of ILC exists, in this tutorial we will consider a heuristic scheme as well as a model-based scheme. ","category":"page"},{"location":"examples/ilc/#Algorithm","page":"Iterative Learning Control (ILC)","title":"Algorithm","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The ILC iteration scheme typically looks something like this (many variants exists), at ILC iteration k:","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"beginaligned\ny_k(t) = G(q) big(r(t) + a_k(t) big) \ne_k(t) = r(t) - y_k(t) \na_k(t) = Q(q) big( a_k-1(t) + L(q) e_k-1(t) big)\nendaligned","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"where q is the time-shift operator, G(q) is the transfer function from the reference r to the output y, i.e, typically a closed-loop transfer function, e_k is the control error and a_k is the ILC adjustment signal, an additive correction to the reference that is learned throughout the ILC iterations in order to minimize the control error. Q(q) and L(q) are stable filters that control the learning dynamics. Interestingly, these filters does not have to be causal since they operate on the signals e and a between ILC iterations, when the whole signals are available at once for acausal filtering. ","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"In simulation (the rollout y_k = G(q) (r + a_k) is simulated), this scheme is nothing other than an open-loop optimal-control strategy, while if y_k = G(q) (r + a_k) amounts to performing an actual experiment on a process, ILC turns into episode-based reinforcement learning or adaptive control.","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The system to control in this example is a double-mass system with a spring and damper in between. This system is a common model of a servo system where one mass represents the motor and the other represents the load. The spring and damper represents a flexible transmission between them. We will create two instances of the system model. G represents the nominal model, whereas G_act represents the actual (unknown) dynamics. This simulates a model-based approach where there is a slight error in the model. The error will lie in the mass of the load, simulating, e.g., that the motor is driving a heavier load than specified. ","category":"page"},{"location":"examples/ilc/#System-model-and-controller","page":"Iterative Learning Control (ILC)","title":"System model and controller","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"using ControlSystemsBase, Plots\n\nfunction double_mass_model(; \n                Jm = 1,   # motor inertia\n                Jl = 1,   # load inertia\n                k  = 100, # stiffness\n                c0 = 1,   # motor damping\n                c1 = 1,   # transmission damping\n                c2 = 1,   # load damping\n)\n\n    A = [\n        0.0 1 0 0\n        -k/Jm -(c1 + c0)/Jm k/Jm c1/Jm\n        0 0 0 1\n        k/Jl c1/Jl -k/Jl -(c1 + c2)/Jl\n    ]\n    B = [0, 1/Jm, 0, 0]\n    C = [1 0 0 0]\n    ss(A, B, C, 0)\nend\n\nG    = double_mass_model(Jl = 1)\nGact = double_mass_model(Jl = 1.5) # 50% more load than modeled\n\nbodeplot([G, Gact], lab=[\"G model\" \"G actual\"], plotphase=false)","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"We will design a PID controller with a filter for the system, the controller is poorly tuned and not very good at tracking fast reference steps, in practice, one would likely design a feedforward controller as well to improve upon this, but for now we'll stick with the simple feedback controller.","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"C  = pid(10, 1, 1, form = :series) * tf(1, [0.02, 1])\nTs = 0.02 # Sample time\nGc = c2d(feedback(G*C), Ts)       |> tf\nGcact = c2d(feedback(Gact*C), Ts) |> tf\nplot(step(Gc, 10), title=\"Closed-loop step response\", lab=\"model\")\nplot!(step(Gcact, 10), lab=\"actual\")","category":"page"},{"location":"examples/ilc/#Reference-trajectory","page":"Iterative Learning Control (ILC)","title":"Reference trajectory","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"Next up we design a reference trajectory and simulate the actual closed-loop dynamics.","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"T = 3pi    # Duration\nt = 0:Ts:T # Time vector\nfunction funnysin(x)\n    x = sin(x)\n    s,a = sign(x), abs(x)\n    s*((a + 0.01)^0.2 - 0.01^0.2)\nend\nr = funnysin.(t)' |> Array # Reference signal\n\nres = lsim(Gcact, r, t)\nplot(res, plotu=true, layout=1, sp=1, title=\"Closed-loop simulation with actual dynamics\", lab=[\"y\" \"r\"])","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"Performance is poor.. Enter ILC!","category":"page"},{"location":"examples/ilc/#Non-causal-filtering","page":"Iterative Learning Control (ILC)","title":"Non-causal filtering","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"For ILC to work well, we define two helper functions. One that applies a zero-phase filter by filtering both forwards and backwards (filtfilt). This is possible since ILC operates on signals offline, between iterations in the ILC scheme. We also define a special lsim that handles non-causal systems to allow \"lookahead\" into the future. This typically improves the performance of ILC by quite a lot, and is once again possible since ILC operates on prerecorded signals. ","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"function lsim_zerophase(G, u, args...; kwargs...)\n    res = lsim(G, u[:, end:-1:1], args...; kwargs...)\n    lsim(G, res.y[:, end:-1:1], args...; kwargs...).y\nend\n\nfunction lsim_noncausal(L::LTISystem{<:Discrete}, u, args...; kwargs...)\n    np = length(denpoly(L)[])\n    nz = length(numpoly(L)[])\n    zeroexcess = nz-np\n    if zeroexcess <= 0\n        return lsim(L, u, args...; kwargs...)\n    end\n    integrators = tf(1, [1, 0], L.Ts)^zeroexcess\n    res = lsim(L*integrators, u, args...; kwargs...)\n    res.y[1:end-zeroexcess] .= res.y[1+zeroexcess:end]\n    res.y\nend\nnothing # hide","category":"page"},{"location":"examples/ilc/#Choosing-filters","page":"Iterative Learning Control (ILC)","title":"Choosing filters","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The next step is to define the ILC filters Q(x) and L(z).","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The filter L(q) acts as a frequency-dependent step size. To make the procedure take smaller steps, simply scale L by a constant < 1. Scaling down L makes the learning process slower but more robust. A heuristic choice of L is some form of scaled lookahead, such as 05z^l where l geq 0 is the number of samples lookahead. A model-based approach may use some form of inverse of the system model, which is what we will use here. [nonlinear]","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"[nonlinear]: Inverse models can be formed also for some nonlinear systems. ModelingToolkit.jl is particularily well suited for inverting models due to its acausal nature.","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The filter Q(q) acts to make the procedure robust w.r.t. noise and modeling errors. Q has a final say over what frequencies appear in a and it's good to choose Q with low-pass properties. Q will here be applied in zero-phase mode, so the effective transfer function will be Q(z)Q(z).","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"z = tf(\"z\", Ts)\nQ = c2d(tf(1, [0.05, 1]), Ts)\n# L = 0.9z^1 # A more conservative and heuristic choice\nL = 0.5inv(Gc) # Make the scaling factor smaller to take smaller steps\nnothing # hide","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"A theorem due to Norrlöf says that for the ILC iterations to converge, one needs to satisfy  1 - LG   Q^-1 which we can verify by looking at the Bode curves of the two sides of the inequality","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"bodeplot([inv(Q), (1 - L*Gc)], plotphase=false, lab=[\"Stability boundary \\$Q^{-1}\\$\" \"\\$1 - LG\\$\"])\nbodeplot!((1 - L*Gcact), plotphase=false, lab=\"\\$1 - LG\\$ actual\")","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"Above, we plotted this curve also for the actual dynamics. This is of course not possible in a real scenario where this is unknown, but one could plot it for multiple plausible models and verify that they are all below the boundary. See Uncertainty modeling using RobustAndOptimalControl.jl for guidance on this. Looking at the stability condition, it becomes obvious how making Q small where the model is uncertain is beneficial for robustness of the ILC scheme.","category":"page"},{"location":"examples/ilc/#ILC-iteration","page":"Iterative Learning Control (ILC)","title":"ILC iteration","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The next step is to implement the ILC scheme and run it:","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"function ilc(Gc, Q, L)\n    a = zero(r) # ILC adjustment signal starts at 0\n    fig = plot(t, vec(r), sp=1, layout=(3,1), l=(:black, 3), lab=\"Ref\")\n    for iter = 1:5\n        ra = r .+ a\n        res = lsim(Gc, ra, t) # Simulate system, replaced by an actual experiment if running on real process\n        y = res.y             # System response\n        e = r .- y            # Error\n        Le = lsim_noncausal(L, e, t)\n        a  = lsim_zerophase(Q, a + Le, t) # Update ILC adjustment\n\n        plot!(res, plotu=true, sp=[1 2], title=[\"Output \\$y(t)\\$\" \"Adjusted reference \\$r + a\\$\"], lab=\"Iter $iter\", c=iter)\n        plot!(e[:], sp=3, title=\"Tracking error \\$e(t)\\$\", lab=\"err: $(round(sum(abs2, e), digits=2))\", c=iter)\n    end\n    fig\nend\nilc(Gc, Q, L)","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"When running on the model, the result looks very good. We see that the tracking error in the last plot decreases rapidly and is much smaller after only a couple of iterations. We also note that the adjusted reference r+a has effectively been phase-advanced slightly to compensate for the lag in the system dynamics. This is an effect of the acausal filtering due to L = G_C^-1.","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"How does it work on the \"actual\" dynamics?","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"ilc(Gcact, Q, L)","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"The result is subtly worse, but considering the rather big model error the result is still quite good. ","category":"page"},{"location":"examples/ilc/#Summary","page":"Iterative Learning Control (ILC)","title":"Summary","text":"","category":"section"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"We have seen how ILC can be used to improve tracking performance in a scenario where a repetitive task is to be executed several times. In simulation like here, ILC can be seen as an optimal-control strategy to come up with a optimal reference trajectory to minimize the control error, while if implemented on a physical process, the scheme amounts to a simple but effective reinforcement-learning or adaptive-control approach. ILC often works very well in practice and has been used in robotics and machining among other areas. ","category":"page"},{"location":"examples/ilc/","page":"Iterative Learning Control (ILC)","title":"Iterative Learning Control (ILC)","text":"ILC does not work very well if stochastic disturbances dictate the control performance or a task is to be performed only a small number of times. In, e.g., machining applications, each ILC iteration may imply performing destructive machining on expensive material with suboptimal result before convergence. This may only be cost effective if the task is to be performed many times after an initial \"tuning\" by means of ILC.","category":"page"},{"location":"man/differences/#Noteworthy-Differences-from-other-Languages","page":"Noteworthy differences from other languages","title":"Noteworthy Differences from other Languages","text":"","category":"section"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"If you are new to the Julia programming language, you are encouraged to visit the documentation page on noteworthy differences between Julia and other programming languages.","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"The rest of this page will list noteworthy differences between ControlSystems.jl and other pieces of control-systems software.","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"Functions to calculate poles and zeros of systems are named using their plural forms, i.e., poles instead of pole, and tzeros instead of tzero.\nSimulation using lsim, step, impulse returns arrays where time is in the second dimension rather than in the first dimension (applies also to freqresp, bode, nyquist etc.). Julia uses a column major memory layout, and this choice is made for performance reasons.\nFunctions are, lqr and kalman have slightly different signatures in julia compared to in other languages. More advanced LQG functionalities are located in RobustAndOptimalControl.jl.\nSimulation using lsim, step, impulse etc. return a structure that can be plotted. These functions never plot anything themselves.\nFunctions bode, nyquist etc. never produce a plot. Instead, see bodeplot, nyquistplot etc.\nIn Julia, functionality is often split up into several different packages. You may therefore have to install and use additional packages in order to cover all your needs. See Ecosystem for a collection of control-related packages.\nIn Julia, 1 has a different type than 1.0, and the types in ControlSystemsBase.jl respect the types chosen by the user. As an example, tf(1, [1, 1]) is a transfer function with integer coefficients, while tf(1.0, [1, 1]) will promote all coefficients to Float64.\nJulia treats matrices and vectors as different types, in particular, column vectors and row vectors are not interchangeable. \nIn Julia, code can often be differentiated using automatic differentiation. When using ControlSystems.jl, we recommend trying ForwardDiff.jl for AD. An example making use of this is available here.\nIn Julia, the source code is often very readable. If you want to learn how a function is implemented, you may find the macros @edit or @less useful to locate the source code.\nIf you run into an issue (bug) with a Julia package, you can share this issue (bug report) on the package's github page and it will often be fixed promptly. To open an issue with ControlSystems.jl, click here. Thank you for helping out improving open-source software!\nJulia compiles code just before it is called the first time. This introduces a noticeable lag, and can make packages take a long time to load. If you want to speed up the loading of ControlSystems.jl, consider building a system image that includes ControlSystems.jl using PackageCompiler.jl. More info about this is available below under Precompilation for faster load times","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"If you find other noteworthy differences between ControlSystems.jl and other pieces of control-related software, please consider submitting a pull request (PR) to add to the list above. You can submit a PR by clicking on \"Edit on GitHub\" at the top of this page and then clicking on the icon that looks like a pen above the file viewer. A two-minute video on this process is available below","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/ZpH1ry8qqfw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"man/differences/#Precompilation-for-faster-load-times","page":"Noteworthy differences from other languages","title":"Precompilation for faster load times","text":"","category":"section"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"In order to make it faster to load the ControlSystems.jl package, you may make use of PackageCompiler.jl. ","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"warning: For developers\nIf you intend to develop ControlSystem.jl, i.e., modify the source code, it's not recommended to build the package into the system image. We then recommend to build OrdinaryDiffEq into the system image since this package contributes the largest part of the loading time.","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"Building a custom system image can dramatically reduce the time to get started in a new Julia session, as an example:","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"Without system image:","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"julia> @time using ControlSystems\n  5.725526 seconds (17.91 M allocations: 1.363 GiB, 8.31% gc time, 14.86% compilation time)","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"With OrdinaryDiffEq and Plots in the system image:","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"julia> @time using ControlSystems\n  0.120975 seconds (413.37 k allocations: 27.672 MiB, 1.66% compilation time)","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"To build a system image with ControlSystems, save the following script in a file, e.g., precompile_controlsystems.jl (feel free to add any additional packages you may want to load).","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"using OrdinaryDiffEq # Include this if you want to develop ControlSystems.jl\nusing ControlSystems # Include this if you only want to use ControlSystems.jl\nusing Plots # In case you also want to use plotting functions\n\n# Run some statements to make sure these are precompiled. Do not include this if you want to develop ControlSystems.jl\nfor P = StateSpace[ssrand(2,2,2), ssrand(2,2,2, Ts=0.1)]\n    bodeplot(P)\n    nyquistplot(P)\n    plot(step(P, 10))\nend","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"Then run the following","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"using PackageCompiler\nPackageCompiler.create_sysimage(\n    [\n        :OrdinaryDiffEq,\n        :Plots,\n        :ControlSystems,\n    ];\n    precompile_execution_file = \"precompile_execution_file\",\n    sysimage_path = \"sys_ControlSystems_$(VERSION).so\",\n)\nexit()","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"When you have created a system image, start Julia with the -J flag pointing to the system image that was created, named sys_ControlSystems_<VERSION>.so, more details here. After this, loading the package should be very fast.","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"warning: Updating packages\nWhen you update installed julia packages, the update will not be reflected in the system image until the image is rebuilt. ","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"You can make vscode load this system image as well by adding","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"\"julia.additionalArgs\": [\n    \"-J/path_to_sysimage/sys_ControlSystems_<VERSION>.so\"\n],","category":"page"},{"location":"man/differences/","page":"Noteworthy differences from other languages","title":"Noteworthy differences from other languages","text":"to settings.json.","category":"page"},{"location":"lib/nonlinear/#Nonlinear-functionality","page":"Nonlinear","title":"Nonlinear functionality","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"danger: Experimental\nThe nonlinear interface is currently experimental and at any time subject to breaking changes not respecting semantic versioning. ","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"ControlSystems.jl can represent nonlinear feedback systems that can be written on the form","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"      ┌─────────┐\n y◄───┤         │◄────u\n      │    P    │\nΔy┌───┤         │◄───┐Δu\n  │   └─────────┘    │\n  │                  │\n  │      ┌───┐       │\n  └─────►│ f ├───────┘\n         └───┘","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"i.e., as a linear-fractional transform (LFT) between a linear system P and a diagonal matrix with scalar non-linear functions f. This representation is identical to that used for delay systems, and is exposed to the user in a similar way as well. The main entry point is the function nonlinearity which takes a nonlinear function f like so, nonlinearity(f). This creates a primitive system containing only the nonlinearity, but which behaves like a standard LTISystem during algebraic operations. We illustrate its usage through a number of examples.","category":"page"},{"location":"lib/nonlinear/#Examples","page":"Nonlinear","title":"Examples","text":"","category":"section"},{"location":"lib/nonlinear/#Control-signal-saturation","page":"Nonlinear","title":"Control-signal saturation","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"To create a controller that saturates the output at pm 07, we call","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"using ControlSystems, Plots\nusing ControlSystemsBase: nonlinearity # This functionality is not exported due to the beta status\n\nC    = pid(1, 0.1, form=:parallel)                  # A standard PI controller\nnl   = nonlinearity(x->clamp(x, -0.7, 0.7)) # a saturating nonlinearity\nsatC = nl*C # Connect the saturation at the output of C","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"we may now use this controller like we would normally do in ControlSystems, e.g.,","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"P   = tf(1, [1, 1])    # a plant\nG   = feedback(P*C)    # closed loop without nonlinearity\nGnl = feedback(P*satC) # closed loop with saturation\n\nGu   = feedback(C, P)    # closed loop from reference to control signal without nonlinearity\nGunl = feedback(satC, P) # closed loop from reference to control signal with saturation\n\nplot(step([G; Gu], 5), lab = [\"Linear y\" \"Linear u\"])\nplot!(step([Gnl; Gunl], 5), lab = [\"Nonlinear y\" \"Nonlinear u\"])","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Since the saturating nonlinearity is common, we provide the constructor ControlSystemsBase.saturation that automatically forms the equivalent to nonlinearity(x->clamp(x, -0.7, 0.7)) while at the same time making sure the function has a recognizable name when the system is printed","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"using ControlSystemsBase: saturation\nsaturation(0.7)","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"See also ControlSystemsBase.ratelimit that saturates the derivative of a signal.","category":"page"},{"location":"lib/nonlinear/#Non-zero-operating-point","page":"Nonlinear","title":"Non-zero operating point","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"It's common to linearize nonlinear systems around some operating point. We may make use of the helper constructor ControlSystemsBase.offset to create affine functions at the inputs and outputs of the linearized system to, e.g.,","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Make sure that simulations result are given in the original coordinates rather than in the coordinates of the linearization point.\nAllow nonlinearities that are added back after the linearization (such as saturations) to operate with their original parameters.","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"We will demonstrate a composite usage of offset and saturation below. The system we'll consider is a linearized model of a quadruple-tank process;","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"The system is linearized around the operating point","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"xr = [10, 10, 4.9, 4.9] # reference state\nur = [0.263, 0.263]     # control input at the operating point\nnothing # hide","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"and is given by","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"using LinearAlgebra\nkc, k1, k2, g = 0.5, 1.6, 1.6, 9.81\nA1 = A3 = A2 = A4 = 4.9\na1, a3, a2, a4 = 0.03, 0.03, 0.03, 0.03\nh01, h02, h03, h04 = xr\nT1, T2 = (A1/a1)sqrt(2*h01/g), (A2/a2)sqrt(2*h02/g)\nT3, T4 = (A3/a3)sqrt(2*h03/g), (A4/a4)sqrt(2*h04/g)\nc1, c2 = (T1*k1*kc/A1), (T2*k2*kc/A2)\nγ1, γ2 = 0.3, 0.3\n\n# Define the process dynamics\nA = [-1/T1     0 A3/(A1*T3)          0\n        0     -1/T2          0 A4/(A2*T4)\n        0         0      -1/T3          0\n        0         0          0      -1/T4]\nB = [γ1*k1/A1     0\n        0                γ2*k2/A2\n        0                (1-γ2)k2/A3\n        (1-γ1)k1/A4 0              ]\n\nC = kc*[I(2) 0*I(2)] # Measure the first two tank levels\nD = 0\nG = ss(A,B,C,D)\nnothing # hide","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"A PID controller with a filter is given by","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"F = tf(1, [0.63, 1.12, 1])\nCpid = pid(0.26, 0.001, 15.9, form=:parallel)*F |> ss\nnothing # hide","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"and to make the controller MIMO, we add a static pre-compensator that decouples the system at the the zero frequency.","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"iG0 = dcgain(G)\niG0 ./= maximum(abs, iG0)\nC = (Cpid .* I(2)) * iG0 \nnothing # hide","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"The pumps (there are two of them) that service the tanks can only add liquid to the tanks, not remove liquid. The pump is thus saturated from below at 0, and from above at the maximum pump capacity 0.4. ","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"using ControlSystemsBase: offset\numin = [0.0, 0.0]\numax = [0.4, 0.4]\n\nyr    = G.C*xr  # Reference output\nGop   = offset(yr) * G * offset(-ur) # Make the plant operate in Δ-coordinates \nC_sat = saturation(umin, umax) * C   # while the controller and the saturation operate in the original coordinates","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"We now simulate the closed-loop system, the initial state of the plant is adjusted with the operating point x0-xr since the plant operates in Δ-coordinates ","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"x0 = [2, 1, 8, 3] # Initial tank levels\nplot(\n    plot(lsim(feedback(Gop*C_sat), yr, 0:1:3000, x0=[x0-xr; zeros(C.nx)]), layout=1, sp=1, title=\"Outputs\", ylabel=\"\"),\n    plot(lsim(feedback(C_sat, Gop), yr, 0:1:3000, x0=[zeros(C.nx); x0-xr]), layout=1, sp=1, title=\"Control signals\", ylabel=\"\")\n)\nhline!([yr[1]], label=\"Reference\", l=:dash, sp=1, c=1)","category":"page"},{"location":"lib/nonlinear/#Duffing-oscillator","page":"Nonlinear","title":"Duffing oscillator","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"In this example, we'll model and control the nonlinear system","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"ddot x = -kx - k_3 x^3 - c dotx + 10u","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"To do this, we first draw the block diagram","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"10u    ┌───┐\n──────►│+  │   ┌───┐   ┌───┐\n ┌────►│-  │ ẍ │ 1 │ ẋ │ 1 │ x\n │ ┌──►│-  ├──►│ - ├┬─►│ - ├─┬──►\n │ │ ┌►│-  │   │ s ││  │ s │ │\n │ │ │ └───┘   └───┘│  └───┘ │\n │ │ │              │        │\n │ │ │   ┌───┐      │        │\n │ │ └───┤ c │◄─────┘        │\n │ │     └───┘               │\n │ │                         │\n │ │     ┌───┐               │\n │ └─────┤ k │◄──────────────┤\n │       └───┘               │\n │                           │\n │       ┌───┐   ┌───┐       │\n └───────┤ k³│◄──┤ x³│◄──────┘\n         └───┘   └───┘","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"We see that the input u passes through the inner velocity loop before reaching the output x, we can form this inner closed-loop transfer function using feedback(1/s, c), i.e., close the loop over an integrator by -c. This inner loop is then connected in series with another integrator an feedback loop is closed with k_3 x^3 + kx = pos_loop_feedback in the feedback path. Notice how we multiply the final system with 10 from the right to get the input gain correct, for nonlinear systems, 10*sys and sys*10 are not always equivalent!","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"using ControlSystems, Plots\nusing ControlSystemsBase: nonlinearity\nk  = 10\nk3 = 2\nc  = 1\n\ns = tf(\"s\")\n\ncube = nonlinearity(x->x^3)\nvel_loop = feedback(1/s, c)\npos_loop_feedback = (k3*cube + k)\nduffing = feedback(vel_loop/s, pos_loop_feedback)*10\n\nplot(step(duffing, 20), title=\"Duffing oscillator open-loop step response\")","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"We now show how we can make use of the circle criterion to prove stability of the closed loop. The function circle_criterion below plots the Nyquist curve of the loop-transfer function and figures out the circle to avoid by finding sector bounds for the static nonlinearity f(x) = x^3. We then choose a controller and check that it stays outside of the circle. To find the sector bounds, we choose a domain to evaluate the nonlinearity over. The function f(x) = x^3 goes to infinity faster than any linear function, and the upper sector bound is thus ∞, but if we restrict the nonlinearity to a smaller domain, we get a finite sector bound:","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"function circle_criterion(L::ControlSystemsBase.HammersteinWienerSystem, domain::Tuple; N=10000)\n    fun = x->L.f[](x)/x\n    x = range(domain[1], stop=domain[2], length=N)\n    0 ∈ x && (x = filter(!=(0), x)) # We cannot divide by zero\n    k1, k2 = extrema(fun, x)\n\n    f1 = plot(L.f[], domain[1], domain[2], title=\"Nonlinearity\", lab=\"f(x)\", xlab=\"x\")\n    plot!(x, [k1.*x k2.*x], lab=[\"k1 = $(round(k1, sigdigits=2))\" \"k2 = $(round(k2, sigdigits=2))\"], l=(:dash), legend=:bottomright)\n\n    p1 = -1/k2 # Close to origin\n    p2 = -1/k1 # Far from origin\n\n    c = (p1 + p2)/2\n    r = (p2 - p1)/2\n\n    Lnominal = sminreal(ss(L.A, L.B1, L.C1, L.D11, L.P.timeevol))\n    f2 = nyquistplot(Lnominal)\n    if p2 < -1000 # Due to bug in plots\n        vspan!([-1000, p1], fillalpha=0.7, c=:red, primary=false)\n    else\n        th = 0:0.01:2pi\n        Cs,Ss = cos.(th), sin.(th)\n        plot!(r.*Cs .+ c, r.*Ss, fill=true, fillalpha=0.7, c=:red, primary=false)\n    end\n\n    plot(f1,f2)\nend\n\n\nC = pid(2, 0, 1, form=:parallel)*tf(1, [0.01,1])\nf1 = circle_criterion(duffing*C, (-1, 1))\nplot!(sp=2, ylims=(-10, 3), xlims=(-5, 11))\nf2 = plot(step(feedback(duffing, C), 8), plotx=true, plot_title=\"Controlled oscillator disturbance step response\", layout=4)\nplot(f1,f2, size=(1300,800))","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Since we evaluated the nonlinearity over a small domain, we should convince ourselves that we indeed never risk leaving this domain. ","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"In the example above, the circle turns into a half plane since the lower sector bound is 0. The example below chooses another nonlinearity","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"f(x) = x + sin(x)","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"to get an actual circle in the Nyquist plane.","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"wiggly = nonlinearity(x->x+sin(x)) # This function is a bit wiggly\nvel_loop = feedback(1/s, c)\npos_loop_feedback = (k3*wiggly + k)\nduffing = feedback(vel_loop/s, pos_loop_feedback)*10\n\nC = pid(2, 5, 1, form=:parallel)*tf(1,[0.1, 1]) \nf1 = circle_criterion(duffing*C, (-2pi, 2pi))\nplot!(sp=2, ylims=(-5, 2), xlims=(-2.1, 0.1))\nf2 = plot(step(feedback(duffing, C), 8), plotx=true, plot_title=\"Controlled wiggly oscillator disturbance step response\", layout=5)\nplot(f1,f2, size=(1300,800))","category":"page"},{"location":"lib/nonlinear/#Limitations","page":"Nonlinear","title":"Limitations","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Remember, this functionality is experimental and subject to breakage.\nCurrently only Continuous systems supported.\nNo nonlinear root-finding is performed during simulation. This limits the kinds of systems that can be simulated somewhat, in particular, no algebraic loops are allowed. \nA lot of functions that expect linear systems will not work for nonlinear systems (naturally).","category":"page"},{"location":"lib/nonlinear/#Possible-future-work","page":"Nonlinear","title":"Possible future work","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Discrete-time support.\nBasic support for nonlinear analysis such as stability proof through the circle criterion etc. In particular, predefined nonlinear functions may specify sector bounds for the gain, required by the circle-criterion calculations.\nAdditional nonlinear components, such as \nIntegrator anti-windup\nFriction models","category":"page"},{"location":"lib/nonlinear/#See-also","page":"Nonlinear","title":"See also","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"More advanced nonlinear modeling is facilitated by ModelingToolkit.jl (MTK) and ModelingToolkitStandardLibrary.jl. The tutorials ","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"Modeling for control using ModelingToolkit\nDisturbance modeling in ModelingToolkit\nModal analysis of a series of masses and springs using MTK","category":"page"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"show how to use these packages to model and simulate control systems.","category":"page"},{"location":"lib/nonlinear/#Docstrings","page":"Nonlinear","title":"Docstrings","text":"","category":"section"},{"location":"lib/nonlinear/","page":"Nonlinear","title":"Nonlinear","text":"ControlSystemsBase.nonlinearity\nControlSystemsBase.offset\nControlSystemsBase.saturation\nControlSystemsBase.ratelimit\nControlSystemsBase.deadzone","category":"page"},{"location":"lib/nonlinear/#ControlSystemsBase.nonlinearity","page":"Nonlinear","title":"ControlSystemsBase.nonlinearity","text":"nonlinearity(f)\nnonlinearity(T, f)\n\nCreate a pure nonlinearity. f is assumed to be a static (no memory) nonlinear function from f  R - R.\n\nThe type T defaults to Float64.\n\nNOTE: The nonlinear functionality in ControlSystemsBase.jl is currently experimental and subject to breaking changes not respecting semantic versioning. Use at your own risk.\n\nExample:\n\nCreate a LTI system with a static input nonlinearity that saturates the input to [-1,1].\n\ntf(1, [1, 1])*nonlinearity(x->clamp(x, -1, 1))\n\nSee also predefined nonlinearities saturation, offset.\n\nNote: when composing linear systems with nonlinearities, it's often important to handle operating points correctly. See ControlSystemsBase.offset for handling operating points.\n\n\n\n\n\n","category":"function"},{"location":"lib/nonlinear/#ControlSystemsBase.offset","page":"Nonlinear","title":"ControlSystemsBase.offset","text":"offset(val)\n\nCreate a constant-offset nonlinearity x -> x + val.\n\nNOTE: The nonlinear functionality in ControlSystemsBase.jl is currently experimental and subject to breaking changes not respecting semantic versioning. Use at your own risk.\n\nExample:\n\nTo create a linear system that operates around operating point y₀, u₀, use\n\noffset_sys = offset(y₀) * sys * offset(-u₀)\n\nnote the sign on the offset u₀. This ensures that sys operates in the coordinates Δu = u-u₀, Δy = y-y₀ and the inputs and outputs to the offset system are in their non-offset coordinate system. If the system is linearized around x₀, y₀ is given by C*x₀. Additional information and an example is available here https://juliacontrol.github.io/ControlSystemsBase.jl/latest/lib/nonlinear/#Non-zero-operating-point\n\n\n\n\n\n","category":"function"},{"location":"lib/nonlinear/#ControlSystemsBase.saturation","page":"Nonlinear","title":"ControlSystemsBase.saturation","text":"saturation(val)\nsaturation(lower, upper)\n\nCreate a saturating nonlinearity. Connect it to the output of a controller C using\n\nCsat = saturation(val) * C\n\n           y▲   ────── upper\n            │  /\n            │ /\n            │/\n  ──────────┼────────► u\n           /│   \n          / │\n         /  │\nlower──── \n\nNOTE: The nonlinear functionality in ControlSystemsBase.jl is currently experimental and subject to breaking changes not respecting semantic versioning. Use at your own risk.\n\nNote: when composing linear systems with nonlinearities, it's often important to handle operating points correctly. See ControlSystemsBase.offset for handling operating points.\n\n\n\n\n\n","category":"function"},{"location":"lib/nonlinear/#ControlSystemsBase.ratelimit","page":"Nonlinear","title":"ControlSystemsBase.ratelimit","text":"ratelimit(val; Tf)\nratelimit(lower, upper; Tf)\n\nCreate a nonlinearity that limits the rate of change of a signal, roughly equivalent to 1s  sat  s. Tf controls the filter time constant on the derivative used to calculate the rate.  NOTE: The nonlinear functionality in ControlSystemsBase.jl is currently experimental and subject to breaking changes not respecting semantic versioning. Use at your own risk.\n\n\n\n\n\n","category":"function"},{"location":"lib/nonlinear/#ControlSystemsBase.deadzone","page":"Nonlinear","title":"ControlSystemsBase.deadzone","text":"deadzone(val)\ndeadzone(lower, upper)\n\nCreate a dead-zone nonlinearity.\n\n       y▲\n        │     /\n        │    /\n  lower │   /\n─────|──┼──|───────► u\n    /   │   upper\n   /    │\n  /     │\n\nNOTE: The nonlinear functionality in ControlSystemsBase.jl is currently experimental and subject to breaking changes not respecting semantic versioning. Use at your own risk.\n\nNote: when composing linear systems with nonlinearities, it's often important to handle operating points correctly. See ControlSystemsBase.offset for handling operating points.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"Pages = [\"plotting.md\"]","category":"page"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"note: Using Plots\nAll plotting requires the user to manually load the Plots.jl library, e.g., by calling using Plots.","category":"page"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"note: Time-domain responses\nThere are no special functions to plot time-domain results, such as step and impulse responses, instead, simply call plot on the result structure (ControlSystemsBase.SimResult) returned by lsim, step, impulse etc.","category":"page"},{"location":"lib/plotting/#Plotting-functions","page":"Plotting","title":"Plotting functions","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ControlSystems, ControlSystemsBase]\nPages   = [libpath*\"/plotting.jl\"]\nOrder   = [:function]\nPrivate = false","category":"page"},{"location":"lib/plotting/#ControlSystemsBase.bodeplot","page":"Plotting","title":"ControlSystemsBase.bodeplot","text":"fig = bodeplot(sys, args...)\nbodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, kwargs...)\n\nCreate a Bode plot of the LTISystem(s). A frequency vector w can be optionally provided. To change the Magnitude scale see setPlotScale(str)\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to RecipesBase.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystemsBase.gangoffourplot-Tuple{Union{LTISystem, Vector}, Vector, Vararg{Any}}","page":"Plotting","title":"ControlSystemsBase.gangoffourplot","text":"fig = gangoffourplot(P::LTISystem, C::LTISystem; minimal=true, plotphase=false, Ms_lines = [1.0, 1.25, 1.5], Mt_lines = [], sigma = true, kwargs...)\n\nGang-of-Four plot.\n\nsigma determines whether a sigmaplot is used instead of a bodeplot for MIMO S and T. kwargs are sent as argument to RecipesBase.plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/plotting/#ControlSystemsBase.nicholsplot","page":"Plotting","title":"ControlSystemsBase.nicholsplot","text":"fig = nicholsplot{T<:LTISystem}(systems::Vector{T}, w::AbstractVector; kwargs...)\n\nCreate a Nichols plot of the LTISystem(s). A frequency vector w can be optionally provided.\n\nKeyword arguments:\n\ntext = true\nGains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]\npInc = 30\nsat = 0.4\nval = 0.85\nfontsize = 10\n\npInc determines the increment in degrees between phase lines.\n\nsat ∈ [0,1] determines the saturation of the gain lines\n\nval ∈ [0,1] determines the brightness of the gain lines\n\nAdditional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular RecipesBase.jl syntax\n\nThis function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystemsBase.nyquistplot","page":"Plotting","title":"ControlSystemsBase.nyquistplot","text":"fig = nyquistplot(sys;                Ms_circles=Float64[], Mt_circles=Float64[], unit_circle=false, hz=false, critical_point=-1, kwargs...)\nnyquistplot(LTISystem[sys1, sys2...]; Ms_circles=Float64[], Mt_circles=Float64[], unit_circle=false, hz=false, critical_point=-1, kwargs...)\n\nCreate a Nyquist plot of the LTISystem(s). A frequency vector w can be optionally provided.\n\nunit_circle: if the unit circle should be displayed. The Nyquist curve crosses the unit circle at the gain corssover frequency.\nMs_circles: draw circles corresponding to given levels of sensitivity (circles around -1 with  radii 1/Ms). Ms_circles can be supplied as a number or a vector of numbers. A design staying outside such a circle has a phase margin of at least 2asin(1/(2Ms)) rad and a gain margin of at least Ms/(Ms-1).\nMt_circles: draw circles corresponding to given levels of complementary sensitivity. Mt_circles can be supplied as a number or a vector of numbers.\ncritical_point: point on real axis to mark as critical for encirclements\n\nIf hz=true, the hover information will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystemsBase.pzmap","page":"Plotting","title":"ControlSystemsBase.pzmap","text":"fig = pzmap(fig, system, args...; kwargs...)\n\nCreate a pole-zero map of the LTISystem(s) in figure fig, args and kwargs will be sent to the scatter plot command.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystemsBase.rgaplot","page":"Plotting","title":"ControlSystemsBase.rgaplot","text":"rgaplot(sys, args...; hz=false)\nrgaplot(LTISystem[sys1, sys2...], args...; hz=false)\n\nPlot the relative-gain array entries of the LTISystem(s). A frequency vector w can be optionally provided.\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystemsBase.setPlotScale-Tuple{AbstractString}","page":"Plotting","title":"ControlSystemsBase.setPlotScale","text":"setPlotScale(str)\n\nSet the default scale of magnitude in bodeplot and sigmaplot. str should be either \"dB\" or \"log10\".\n\n\n\n\n\n","category":"method"},{"location":"lib/plotting/#ControlSystemsBase.sigmaplot","page":"Plotting","title":"ControlSystemsBase.sigmaplot","text":"sigmaplot(sys, args...; hz=false)\nsigmaplot(LTISystem[sys1, sys2...], args...; hz=false)\n\nPlot the singular values of the frequency response of the LTISystem(s). A frequency vector w can be optionally provided.\n\nIf hz=true, the plot x-axis will be displayed in Hertz, the input frequency vector is still treated as rad/s.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#Examples","page":"Plotting","title":"Examples","text":"","category":"section"},{"location":"lib/plotting/#Bode-plot","page":"Plotting","title":"Bode plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: bode)","category":"page"},{"location":"lib/plotting/#Sigma-plot","page":"Plotting","title":"Sigma plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: sigma)","category":"page"},{"location":"lib/plotting/#Margin","page":"Plotting","title":"Margin","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: margin)","category":"page"},{"location":"lib/plotting/#Gangoffour-plot","page":"Plotting","title":"Gangoffour plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: gangoffour)","category":"page"},{"location":"lib/plotting/#Nyquist-plot","page":"Plotting","title":"Nyquist plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: nyquist)","category":"page"},{"location":"lib/plotting/#Nichols-plot","page":"Plotting","title":"Nichols plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: nichols)","category":"page"},{"location":"lib/plotting/#Pole-zero-plot","page":"Plotting","title":"Pole-zero plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: pzmap)","category":"page"},{"location":"lib/plotting/#Rlocus-plot","page":"Plotting","title":"Rlocus plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: rlocus)","category":"page"},{"location":"lib/plotting/#Lsim-response-plot","page":"Plotting","title":"Lsim response plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: lsim)","category":"page"},{"location":"lib/plotting/#Impulse-response-plot","page":"Plotting","title":"Impulse response plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: impulse)","category":"page"},{"location":"lib/plotting/#Step-response-plot","page":"Plotting","title":"Step response plot","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"(Image: step)","category":"page"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Pages = [\"analysis.md\"]","category":"page"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"For robust analysis, see RobustAndOptimalControl.jl.","category":"page"},{"location":"lib/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [ControlSystems, ControlSystemsBase]\nPages   = [\n         libpath*\"/analysis.jl\", \n         libpath*\"/matrix_comps.jl\", \n         libpath*\"/conversion.jl\"\n        ]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/analysis/#ControlSystemsBase.damp-Tuple{LTISystem}","page":"Analysis","title":"ControlSystemsBase.damp","text":"Wn, zeta, ps = damp(sys)\n\nCompute the natural frequencies, Wn, and damping ratios, zeta, of the poles, ps, of sys\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.dampreport-Tuple{IO, LTISystem}","page":"Analysis","title":"ControlSystemsBase.dampreport","text":"dampreport(sys)\n\nDisplay a report of the poles, damping ratio, natural frequency, and time constant of the system sys\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.dcgain","page":"Analysis","title":"ControlSystemsBase.dcgain","text":"dcgain(sys, ϵ=0)\n\nCompute the dcgain of system sys.\n\nequal to G(0) for continuous-time systems and G(1) for discrete-time systems.\n\nϵ can be provided to evaluate the dcgain with a small perturbation into the stability region of the complex plane.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#ControlSystemsBase.delaymargin-Tuple{LTISystem}","page":"Analysis","title":"ControlSystemsBase.delaymargin","text":"dₘ = delaymargin(G::LTISystem)\n\nReturn the delay margin, dₘ. For discrete-time systems, the delay margin is normalized by the sample time, i.e., the value represents the margin in number of sample times.  Only supports SISO systems.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.gangoffour-Tuple{LTISystem, LTISystem}","page":"Analysis","title":"ControlSystemsBase.gangoffour","text":"S, PS, CS, T = gangoffour(P, C; minimal=true)\ngangoffour(P::AbstractVector, C::AbstractVector; minimal=true)\n\nGiven a transfer function describing the plant P and a transfer function describing the controller C, computes the four transfer functions in the Gang-of-Four.\n\nS = 1/(1+PC) Sensitivity function\nPS = (1+PC)\\P Load disturbance to measurement signal\nCS = (1+PC)\\C Measurement noise to control signal\nT = PC/(1+PC) Complementary sensitivity function\n\nIf minimal=true, minreal will be applied to all transfer functions.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.gangofseven-Tuple{LTISystem, LTISystem, LTISystem}","page":"Analysis","title":"ControlSystemsBase.gangofseven","text":"S, PS, CS, T, RY, RU, RE = gangofseven(P,C,F)\n\nGiven transfer functions describing the Plant P, the controller C and a feed forward block F, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.\n\nS = 1/(1+PC) Sensitivity function\nPS = P/(1+PC)\nCS = C/(1+PC)\nT = PC/(1+PC) Complementary sensitivity function\nRY = PCF/(1+PC)\nRU = CF/(1+P*C)\nRE = F/(1+P*C)\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.margin-Tuple{LTISystem, AbstractVector{<:Real}}","page":"Analysis","title":"ControlSystemsBase.margin","text":"wgm, gm, wpm, pm = margin(sys::LTISystem, w::Vector; full=false, allMargins=false)\n\nreturns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins\n\nIf !allMargins, return only the smallest margin\n\nIf full return also fullPhase See also delaymargin and RobustAndOptimalControl.diskmargin\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.markovparam-Tuple{AbstractStateSpace{<:Discrete}, Integer}","page":"Analysis","title":"ControlSystemsBase.markovparam","text":"markovparam(sys, n)\n\nCompute the nth markov parameter of discrete-time state-space system sys. This is defined as the following:\n\nh(0) = D\n\nh(n) = C*A^(n-1)*B\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.poles-Tuple{AbstractStateSpace}","page":"Analysis","title":"ControlSystemsBase.poles","text":"poles(sys)\n\nCompute the poles of system sys.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.reduce_sys-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractMatrix, AbstractFloat}","page":"Analysis","title":"ControlSystemsBase.reduce_sys","text":"reduce_sys(A::AbstractMatrix, B::AbstractMatrix, C::AbstractMatrix, D::AbstractMatrix, meps::AbstractFloat)\n\nImplements REDUCE in the Emami-Naeini & Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.relative_gain_array-Tuple{AbstractMatrix}","page":"Analysis","title":"ControlSystemsBase.relative_gain_array","text":"relative_gain_array(A::AbstractMatrix; tol = 1.0e-15)\n\nReference: \"On the Relative Gain Array (RGA) with Singular and Rectangular Matrices\" Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.relative_gain_array-Tuple{Any, AbstractVector}","page":"Analysis","title":"ControlSystemsBase.relative_gain_array","text":"relative_gain_array(G, w::AbstractVector)\nrelative_gain_array(G, w::Number)\n\nCalculate the relative gain array of G at frequencies w.  G(iω) .* pinv(tranpose(G(iω)))\n\nThe RGA can be used to find input-output pairings for MIMO control using individially tuned loops. Pair the inputs and outputs such that the RGA(ωc) at the crossover frequency becomes as close to diagonal as possible. Avoid pairings such that RGA(0) contains negative diagonal elements. \n\nThe sum of the absolute values of the entries in the RGA is a good measure of the \"true condition number\" of G, the best condition number that can be achieved by input/output scaling of G, -Glad, Ljung.\nThe RGA is invariant to input/output scaling of G.\nIf the RGA contains large entries, the system may be sensitive to model errors, -Skogestad, \"Multivariable Feedback Control: Analysis and Design\":\nUncertainty in the input channels (diagonal input uncertainty). Plants with\nlarge RGA-elements around the crossover frequency are fundamentally   difficult to control because of sensitivity to input uncertainty (e.g. caused   by uncertain or neglected actuator dynamics). In particular, decouplers or   other inverse-based controllers should not be used for plants with large RGAeleme\nElement uncertainty. Large RGA-elements imply sensitivity to element-by-element uncertainty.\nHowever, this kind of uncertainty may not occur in practice due to physical couplings   between the transfer function elements. Therefore, diagonal input uncertainty   (which is always present) is usually of more concern for plants with large RGA elements.\n\nThe relative gain array is computed using the The unit-consistent (UC) generalized inverse Reference: \"On the Relative Gain Array (RGA) with Singular and Rectangular Matrices\" Jeffrey Uhlmann https://arxiv.org/pdf/1805.10312.pdf\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.tzeros-Tuple{TransferFunction}","page":"Analysis","title":"ControlSystemsBase.tzeros","text":"tzeros(sys)\n\nCompute the invariant zeros of the system sys. If sys is a minimal realization, these are also the transmission zeros.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.zpkdata-Tuple{LTISystem}","page":"Analysis","title":"ControlSystemsBase.zpkdata","text":"z, p, k = zpkdata(sys)\n\nCompute the zeros, poles, and gains of system sys.\n\nReturns\n\nz : Matrix{Vector{ComplexF64}}, (ny × nu)\np : Matrix{Vector{ComplexF64}}, (ny × nu)\nk : Matrix{Float64}, (ny × nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.are-Tuple{Union{Continuous, Type{Continuous}}, AbstractMatrix, Any, Any, Any}","page":"Analysis","title":"ControlSystemsBase.are","text":"are(::Continuous, A, B, Q, R)\n\nCompute 'X', the solution to the continuous-time algebraic Riccati equation, defined as A'X + XA - (XB)R^-1(B'X) + Q = 0, where R is non-singular.\n\nIn an LQR problem, Q is associated with the state penalty xQx while R is associated with the control penalty uRu. See lqr for more details.\n\nUses MatrixEquations.arec. For keyword arguments, see the docstring of ControlSystemsBase.MatrixEquations.arec, note that they define the input arguments in a different order.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.are-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any, Any, Any}","page":"Analysis","title":"ControlSystemsBase.are","text":"are(::Discrete, A, B, Q, R; kwargs...)\n\nCompute X, the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where Q>=0 and R>0\n\nIn an LQR problem, Q is associated with the state penalty xQx while R is associated with the control penalty uRu. See lqr for more details.\n\nUses MatrixEquations.ared. For keyword arguments, see the docstring of ControlSystemsBase.MatrixEquations.ared, note that they define the input arguments in a different order.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.balance","page":"Analysis","title":"ControlSystemsBase.balance","text":"S, P, B = balance(A[, perm=true])\n\nCompute a similarity transform T = S*P resulting in B = T\\A*T such that the row and column norms of B are approximately equivalent. If perm=false, the transformation will only scale A using diagonal S, and not permute A (i.e., set P=I).\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#ControlSystemsBase.balreal-Tuple{ST} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystemsBase.balreal","text":"sysr, G, T = balreal(sys::StateSpace)\n\nCalculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal diagm(G). T is the similarity transform between the old state x and the new state z such that Tz = x.\n\nSee also gram, baltrunc\n\nReference: Varga A., Balancing-free square-root algorithm for computing singular perturbation approximations.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.baltrunc-Tuple{ST} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystemsBase.baltrunc","text":"sysr, G, T = baltrunc(sys::StateSpace; atol = √ϵ, rtol=1e-3, n = nothing, residual = false)\n\nReduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal diagm(G), and truncating it to order n. If n is not provided, it's chosen such that all states corresponding to singular values less than atol and less that rtol σmax are removed.\n\nT is the similarity transform between the old state x and the newstate z such that Tz = x.\n\nIf residual = true, matched static gain is achieved through \"residualization\", i.e., setting\n\n0 = A_21x_1 + A_22x_2 + B_2u\n\nwhere indices 1/2 correspond to the remaining/truncated states respectively.\n\nSee also gram, balreal\n\nGlad, Ljung, Reglerteori: Flervariabla och Olinjära metoder.\n\nFor more advanced model reduction, see RobustAndOptimalControl.jl - Model Reduction.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.covar-Tuple{AbstractStateSpace, Any}","page":"Analysis","title":"ControlSystemsBase.covar","text":"P = covar(sys, W)\n\nCalculate the stationary covariance P = E[y(t)y(t)'] of the output y of a StateSpace model sys driven by white Gaussian noise w with covariance E[w(t)w(τ)]=W*δ(t-τ) (δ is the Dirac delta).\n\nRemark: If sys is unstable then the resulting covariance is a matrix of Infs. Entries corresponding to direct feedthrough (DWD' .!= 0) will equal Inf for continuous-time systems.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.ctrb-Tuple{AbstractMatrix, AbstractVecOrMat}","page":"Analysis","title":"ControlSystemsBase.ctrb","text":"ctrb(A, B) or ctrb(sys)\n\nCompute the controllability matrix for the system described by (A, B) or sys.\n\nNote that checking for controllability by computing the rank from ctrb is not the most numerically accurate way, a better method is checking if gram(sys, :c) is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.gram-Tuple{AbstractStateSpace, Symbol}","page":"Analysis","title":"ControlSystemsBase.gram","text":"gram(sys, opt; kwargs...)\n\nCompute the grammian of system sys. If opt is :c, computes the controllability grammian. If opt is :o, computes the observability grammian.\n\nSee also grampd For keyword arguments, see grampd.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.grampd-Tuple{AbstractStateSpace, Symbol}","page":"Analysis","title":"ControlSystemsBase.grampd","text":"U = grampd(sys, opt; kwargs...)\n\nReturn a Cholesky factor U of the grammian of system sys. If opt is :c, computes the controllability grammian G = U*U'. If opt is :o, computes the observability grammian G = U'U.\n\nObtain a Cholesky object by Cholesky(U) for observability grammian\n\nUses MatrixEquations.plyapc/plyapd. For keyword arguments, see the docstring of ControlSystemsBase.MatrixEquations.plyapc/plyapd\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.hinfnorm-Tuple{AbstractStateSpace{<:Continuous}}","page":"Analysis","title":"ControlSystemsBase.hinfnorm","text":"Ninf, ω_peak = hinfnorm(sys; tol=1e-6)\n\nCompute the H∞ norm Ninf of the LTI system sys, together with a frequency ω_peak at which the gain Ninf is achieved.\n\nNinf := sup_ω σ_max[sys(iω)]  if G is stable (σ_max = largest singular value)       :=        Inf'           ifG` is unstable\n\ntol is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).\n\nsys is first converted to a state space model if needed.\n\nThe continuous-time L∞ norm computation implements the 'two-step algorithm' in:\nN.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H∞-norm of a transfer function matrix', Systems and Control Letters (1990), pp. 287-293.\n\nFor the discrete-time version, see:\nP. Bongers, O. Bosgra, M. Steinbuch, 'L∞-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.\n\nSee also linfnorm.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any, Any, Vararg{Any}}} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystemsBase.innovation_form","text":"sysi = innovation_form(sys, R1, R2[, R12])\nsysi = innovation_form(sys; sysw=I, syse=I, R1=I, R2=I)\n\nTakes a system\n\nx' = Ax + Bu + w ~ R1\ny  = Cx + Du + e ~ R2\n\nand returns the system\n\nx' = Ax + Kv\ny  = Cx + v\n\nwhere v is the innovation sequence.\n\nIf sysw (syse) is given, the covariance resulting in filtering noise with R1 (R2) through sysw (syse) is used as covariance.\n\nSee Stochastic Control, Chapter 4, Åström\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.innovation_form-Union{Tuple{ST}, Tuple{ST, Any}} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystemsBase.innovation_form","text":"sysi = innovation_form(sys, K)\n\nTakes a system\n\nx' = Ax + Bu + Kv\ny  = Cx + Du + v\n\nand returns the system\n\nx' = Ax + Kv\ny  = Cx + v\n\nwhere v is the innovation sequence.\n\nSee Stochastic Control, Chapter 4, Åström\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.linfnorm-Tuple{AbstractStateSpace}","page":"Analysis","title":"ControlSystemsBase.linfnorm","text":"Ninf, ω_peak = linfnorm(sys; tol=1e-6)\n\nCompute the L∞ norm Ninf of the LTI system sys, together with a frequency ω_peak at which the gain Ninf is achieved.\n\nNinf := sup_ω σ_max[sys(iω)] (σ_max denotes the largest singular value)\n\ntol is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).\n\nsys is first converted to a state space model if needed.\n\nThe continuous-time L∞ norm computation implements the 'two-step algorithm' in:\nN.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H∞-norm of a transfer function matrix', Systems and Control Letters (1990), pp. 287-293.\n\nFor the discrete-time version, see:\nP. Bongers, O. Bosgra, M. Steinbuch, 'L∞-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.\n\nSee also hinfnorm.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}","page":"Analysis","title":"ControlSystemsBase.observer_controller","text":"cont = observer_controller(sys, L::AbstractMatrix, K::AbstractMatrix)\n\nReturn the observer_controller cont that is given by ss(A - B*L - K*C + K*D*L, K, L, 0)\n\nSuch that feedback(sys, cont) produces a closed-loop system with eigenvalues given by A-KC and A-BL.\n\nArguments:\n\nsys: Model of system\nL: State-feedback gain u = -Lx\nK: Observer gain\n\nSee also observer_predictor and innovation_form.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.observer_predictor-Tuple{AbstractStateSpace, Any, Union{AbstractArray, UniformScaling}, Vararg{Any}}","page":"Analysis","title":"ControlSystemsBase.observer_predictor","text":"observer_predictor(sys::AbstractStateSpace, K; h::Int = 1)\nobserver_predictor(sys::AbstractStateSpace, R1, R2[, R12])\n\nIf sys is continuous, return the observer predictor system\n\nbeginaligned\nx = (A - KC)x + (B-KD)u + Ky \ny  = Cx + Du\nendaligned\n\nwith the input equation [B-KD K] * [u; y]\n\nIf sys is discrete, the prediction horizon h may be specified, in which case measurements up to and including time t-h and inputs up to and including time t are used to predict y(t).\n\nIf covariance matrices R1, R2 are given, the kalman gain K is calculated using kalman.\n\nSee also innovation_form and observer_controller.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.obsv","page":"Analysis","title":"ControlSystemsBase.obsv","text":"obsv(A, C, n=size(A,1))\nobsv(sys, n=sys.nx)\n\nCompute the observability matrix with n rows for the system described by (A, C) or sys. Providing the optional n > sys.nx returns an extended observability matrix.\n\nNote that checking for observability by computing the rank from obsv is not the most numerically accurate way, a better method is checking if gram(sys, :o) is positive definite.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#ControlSystemsBase.similarity_transform-Union{Tuple{ST}, Tuple{ST, Any}} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystemsBase.similarity_transform","text":"syst = similarity_transform(sys, T; unitary=false)\n\nPerform a similarity transform T : Tx̃ = x on sys such that\n\nÃ = T⁻¹AT\nB̃ = T⁻¹ B\nC̃ = CT\nD̃ = D\n\nIf unitary=true, T is assumed unitary and the matrix adjoint is used instead of the inverse. See also balance_statespace.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystemsBase.time_scale-Tuple{AbstractStateSpace{Continuous}, Any}","page":"Analysis","title":"ControlSystemsBase.time_scale","text":"time_scale(sys::AbstractStateSpace{Continuous}, a; balanced = false)\ntime_scale(G::TransferFunction{Continuous},     a; balanced = true)\n\nRescale the time axis (change time unit) of sys.\n\nFor systems where the dominant time constants are very far from 1, e.g., in electronics, rescaling the time axis may be beneficial for numerical performance, in particular for continuous-time simulations.\n\nScaling of time for a function f(t) with Laplace transform F(s) can be stated as\n\nf(at) leftrightarrow dfrac1a Fbig(dfracsabig)\n\nThe keyword argument balanced indicates whether or not to apply a balanced scaling on the B and C matrices. For statespace systems, this defaults to false since it changes the state representation, only B will be scaled. For transfer functions, it defaults to true.\n\nExample:\n\nThe following example show how a system with a time constant on the order of one micro-second is rescaled such that the time constant becomes 1, i.e., the time unit is changed from seconds to micro-seconds. \n\nGs  = tf(1, [1e-6, 1])     # micro-second time scale modeled in seconds\nGms = time_scale(Gs, 1e-6) # Change to micro-second time scale\nGms == tf(1, [1, 1])       # Gms now has micro-seconds as time unit\n\nThe next example illustrates how the time axis of a time-domain simulation changes by time scaling \n\nt = 0:0.1:50 # original time axis\na = 10       # Scaling factor\nsys1 = ssrand(1,1,5)\nres1 = step(sys1, t)      # Perform original simulation\nsys2 = time_scale(sys, a) # Scale time\nres2 = step(sys2, t ./ a) # Simulate on scaled time axis, note the `1/a`\nisapprox(res1.y, res2.y, rtol=1e-3, atol=1e-3)\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#LinearAlgebra.lyap-Tuple{Union{Type{Discrete}, Discrete}, AbstractMatrix, Any}","page":"Analysis","title":"LinearAlgebra.lyap","text":"lyap(A, Q; kwargs...)\n\nCompute the solution X to the discrete Lyapunov equation AXA' - X + Q = 0.\n\nUses MatrixEquations.lyapc / MatrixEquations.lyapd. For keyword arguments, see the docstring of ControlSystemsBase.MatrixEquations.lyapc / ControlSystemsBase.MatrixEquations.lyapd\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#LinearAlgebra.norm","page":"Analysis","title":"LinearAlgebra.norm","text":"norm(sys, p=2; tol=1e-6)\n\nnorm(sys) or norm(sys,2) computes the H2 norm of the LTI system sys.\n\nnorm(sys, Inf) computes the H∞ norm of the LTI system sys. The H∞ norm is the same as the H∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function hinfnorm instead. See hinfnorm for further documentation.\n\ntol is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).\n\nsys is first converted to a StateSpace model if needed.\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#Videos","page":"Analysis","title":"Videos","text":"","category":"section"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Basic usage of robustness analysis with JuliaControl","category":"page"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/zTW4mlWNumo\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"See additional API in RobustAndOptimalControl.jl: API","category":"page"},{"location":"lib/constructors/","page":"Constructors","title":"Constructors","text":"Pages = [\"constructors.md\"]","category":"page"},{"location":"lib/constructors/","page":"Constructors","title":"Constructors","text":"See also Connecting named systems together.","category":"page"},{"location":"lib/constructors/#Constructing-systems","page":"Constructors","title":"Constructing systems","text":"","category":"section"},{"location":"lib/constructors/","page":"Constructors","title":"Constructors","text":"append\nc2d\nfeedback\nfeedback2dof\nminreal\nparallel\nseries\nsminreal\nss\ntf\nzpk\ndelay\nssdata","category":"page"},{"location":"lib/constructors/#ControlSystemsBase.append","page":"Constructors","title":"ControlSystemsBase.append","text":"append(systems::StateSpace...), append(systems::TransferFunction...)\n\nAppend systems in block diagonal form\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.c2d","page":"Constructors","title":"ControlSystemsBase.c2d","text":"sysd = c2d(sys::AbstractStateSpace{<:Continuous}, Ts, method=:zoh; w_prewarp=0)\nGd = c2d(G::TransferFunction{<:Continuous}, Ts, method=:zoh)\n\nConvert the continuous-time system sys into a discrete-time system with sample time Ts, using the specified method (:zoh, :foh, :fwdeuler or :tustin). Note that the forward-Euler method generally requires the sample time to be very small relative to the time constants of the system.\n\nmethod = :tustin performs a bilinear transform with prewarp frequency w_prewarp.\n\nw_prewarp: Frequency (rad/s) for pre-warping when usingthe Tustin method, has no effect for other methods.\n\nSee also c2d_x0map\n\n\n\n\n\nc2d(G::DelayLtiSystem, Ts, method=:zoh)\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.feedback","page":"Constructors","title":"ControlSystemsBase.feedback","text":"feedback(sys)\nfeedback(sys1, sys2)\n\nFor a general LTI-system, feedback forms the negative feedback interconnection\n\n>-+ sys1 +-->\n  |      |\n (-)sys2 +\n\nIf no second system is given, negative identity feedback is assumed\n\n\n\n\n\nfeedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;\n         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],\n         Wperm=:, Zperm=:, pos_feedback::Bool=false)\n\nBasic use feedback(sys1, sys2) forms the feedback interconnection\n\n           ┌──────────────┐\n◄──────────┤     sys1     │◄──── Σ ◄──────\n    │      │              │      │\n    │      └──────────────┘      -1\n    │                            |\n    │      ┌──────────────┐      │\n    └─────►│     sys2     ├──────┘\n           │              │\n           └──────────────┘\n\nAdvanced use feedback also supports more flexible use according to the figure below\n\n              ┌──────────────┐\n      z1◄─────┤     sys1     │◄──────w1\n ┌─── y1◄─────┤              │◄──────u1 ◄─┐\n │            └──────────────┘            │\n │                                        α\n │            ┌──────────────┐            │\n └──► u2─────►│     sys2     ├───────►y2──┘\n      w2─────►│              ├───────►z2\n              └──────────────┘\n\nU1, W1 specifies the indices of the input signals of sys1 corresponding to u1 and w1 Y1, Z1 specifies the indices of the output signals of sys1 corresponding to y1 and z1 U2, W2, Y2, Z2 specifies the corresponding signals of sys2 \n\nSpecify  Wperm and Zperm to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.\n\nNegative feedback (α = -1) is the default. Specify pos_feedback=true for positive feedback (α = 1).\n\nSee also lft, starprod, sensitivity, input_sensitivity, output_sensitivity, comp_sensitivity, input_comp_sensitivity, output_comp_sensitivity, G_PS, G_CS.\n\nSee Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.feedback2dof","page":"Constructors","title":"ControlSystemsBase.feedback2dof","text":"feedback2dof(P,R,S,T)\nfeedback2dof(B,A,R,S,T)\n\nReturn BT/(AR+ST) where B and A are the numerator and denomenator polynomials of P respectively\nReturn BT/(AR+ST)\n\n\n\n\n\nfeedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)\n\nReturn the transfer function P(F+C)/(1+PC) which is the closed-loop system with process P, controller C and feedforward filter F from reference to control signal (by-passing C).\n\n         +-------+\n         |       |\n   +----->   F   +----+\n   |     |       |    |\n   |     +-------+    |\n   |     +-------+    |    +-------+\nr  |  -  |       |    |    |       |    y\n+--+----->   C   +----+---->   P   +---+-->\n      |  |       |         |       |   |\n      |  +-------+         +-------+   |\n      |                                |\n      +--------------------------------+\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.minreal","page":"Constructors","title":"ControlSystemsBase.minreal","text":"minreal(tf::TransferFunction, eps=sqrt(eps()))\n\nCreate a minimial representation of each transfer function in tf by cancelling poles and zeros will promote system to an appropriate numeric type\n\n\n\n\n\nminreal(sys::T; fast=false, kwargs...)\n\nMinimal realisation algorithm from P. Van Dooreen, The generalized eigenstructure problem in linear system theory, IEEE Transactions on Automatic Control\n\nFor information about the options, see ?ControlSystemsBase.MatrixPencils.lsminreal\n\nSee also sminreal, which is both numerically exact and substantially faster than minreal, but with a much more limited potential in removing non-minimal dynamics.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.parallel","page":"Constructors","title":"ControlSystemsBase.parallel","text":"parallel(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in parallel, equivalent to sys2+sys1\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.series","page":"Constructors","title":"ControlSystemsBase.series","text":"series(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in series, equivalent to sys2*sys1\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.sminreal","page":"Constructors","title":"ControlSystemsBase.sminreal","text":"sminreal(sys)\n\nCompute the structurally minimal realization of the state-space system sys. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in sys are removed.\n\nSystems with numerical noise in the coefficients, e.g., noise on the order of eps require truncation to zero to be affected by structural simplification, e.g.,\n\ntrunc_zero!(A) = A[abs.(A) .< 10eps(maximum(abs, A))] .= 0\ntrunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)\nsminreal(sys)\n\nSee also minreal\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.ss","page":"Constructors","title":"ControlSystemsBase.ss","text":"sys = ss(A, B, C, D)      # Continuous\nsys = ss(A, B, C, D, Ts)  # Discrete\n\nCreate a state-space model sys::StateSpace{TE, T} with matrix element type T and TE is Continuous or <:Discrete.\n\nThis is a continuous-time model if Ts is omitted. Otherwise, this is a discrete-time model with sampling period Ts.\n\nD may be specified as 0 in which case a zero matrix of appropriate size is constructed automatically.  sys = ss(D [, Ts]) specifies a static gain matrix D.\n\nTo associate names with states, inputs and outputs, see named_ss.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.tf","page":"Constructors","title":"ControlSystemsBase.tf","text":"sys = tf(num, den[, Ts])\nsys = tf(gain[, Ts])\n\nCreate as a fraction of polynomials:\n\nsys::TransferFunction{SisoRational{T,TR}} = numerator/denominator\n\nwhere T is the type of the coefficients in the polynomial.\n\nnum: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems\n\nor an array of vectors to create MIMO system.\n\nden: the coefficients of the denominator polynomial. Either vector to create SISO systems\n\nor an array of vectors to create MIMO system.\n\nTs: Sample time if discrete time system.\n\nOther uses:\n\ntf(sys): Convert sys to tf form.\ntf(\"s\"), tf(\"z\"): Create the continuous transferfunction s.\n\nSee also: zpk, ss.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.zpk","page":"Constructors","title":"ControlSystemsBase.zpk","text":"zpk(gain[, Ts])\nzpk(num, den, k[, Ts])\nzpk(sys)\n\nCreate transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.\n\nsys::TransferFunction{SisoZpk{T,TR}} = k*numerator/denominator\n\nwhere T is the type of k and TR the type of the zeros/poles, usually Float64 and Complex{Float64}.\n\nnum: the roots of the numerator polynomial. Either scalar or vector to create SISO systems\n\nor an array of vectors to create MIMO system.\n\nden: the roots of the denominator polynomial. Either vector to create SISO systems\n\nor an array of vectors to create MIMO system.\n\nk: The gain of the system. Obs, this is not the same as dcgain.\nTs: Sample time if discrete time system.\n\nOther uses:\n\nzpk(sys): Convert sys to zpk form.\nzpk(\"s\"): Create the transferfunction s.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.delay","page":"Constructors","title":"ControlSystemsBase.delay","text":"delay(tau)\ndelay(tau, Ts)\ndelay(T::Type{<:Number}, tau)\ndelay(T::Type{<:Number}, tau, Ts)\n\nCreate a pure time delay of length τ of type T.\n\nThe type T defaults to promote_type(Float64, typeof(tau)).\n\nIf Ts is given, the delay is discretized with sampling time Ts and a discrete-time StateSpace object is returned.\n\nExample:\n\nCreate a LTI system with an input delay of L\n\nL = 1\ntf(1, [1, 1])*delay(L)\ns = tf(\"s\")\ntf(1, [1, 1])*exp(-s*L) # Equivalent to the version above\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystemsBase.ssdata","page":"Constructors","title":"ControlSystemsBase.ssdata","text":"A, B, C, D = ssdata(sys)\n\nA destructor that outputs the statespace matrices.\n\n\n\n\n\n","category":"function"},{"location":"examples/smith_predictor/#Smith-predictor","page":"Smith predictor","title":"Smith predictor","text":"","category":"section"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"This example designs a controller for a plant with a time delay using the internal-model principle, which in this case implies the use of a Smith predictor. The plant is given by $ \\dfrac{1}{s + 1}e^{-s\\tau} = P_0 e^{-s\\tau}$","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"and the control architecture looks like this","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"                ┌──────┐              ┌─────────────┐\nr               │      │          u   │             │\n───+──+────────►│  C0  ├───────────┬─►│ P0*exp(-st) ├─┐y\n   ▲  ▲         │      │           │  │             │ │\n  -│  │-        └──────┘           │  └─────────────┘ │\n   │  │                            │                  │\n   │  │ ┌──────────┐    ┌──────┐   │                  │\n   │  │ │          │    │      │   │                  │\n   │  └─┤1-exp(-st)│◄───┤  P0  │◄──┘                  │\n   │    │          │    │      │                      │\n   │    └──────────┘    └──────┘                      │\n   │                                                  │\n   └──────────────────────────────────────────────────┘","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"The benefit of this approach is that the controller C_0 can be designed for the nominal plant P_0 without time delay, and still behave well in the presence of the delay. We also see why we refer to such a controller as using an \"internal model\", due to the presence of a model of P_0 in the inner feedback path.","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"We now set up the nominal system and PI controller","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"using ControlSystemsBase, Plots\nP0 = ss(-1, 1, 1, 0) # Nominal system","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"We design a PI controller for nominal system using placePI. To verify the pole placement, use, e.g., dampreport(feedback(P0, C0))","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"ω0 = 2\nζ  = 0.7\nC0, _ = placePI(P0, ω0, ζ)","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"We then setup delayed plant + Smith predictor-based controller","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"τ = 8\nP = delay(τ) * P0\nC = feedback(C0, (1.0 - delay(τ))*P0) # form the inner feedback connection in the diagram above","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"We now plot the closed loop responses. The transfer function from r to y is given by PC_r(1+PC_r) = feedback(P*C,1), and from a load disturbance entering at u the transfer function is P(1+PC_r) = feedback(P, C)","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"using ControlSystems # Load full ControlSystems for delay-system simulation\nG = [feedback(P*C, 1) feedback(P, C)] # Reference step at t = 0 and load disturbance step at t = 15\nfig_timeresp = plot(lsim(G, (_,t) -> [1; t >= 15], 0:0.1:40),  title=\"τ = $τ\")","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"Plot the frequency response of the predictor part and compare to a negative delay, which would be an ideal controller that can (typically) not be realized in practice (a negative delay implies foresight). ","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"C_pred = feedback(1, C0*(ss(1.0) - delay(τ))*P0)\nfig_bode = bodeplot([C_pred, delay(-τ)], exp10.(-1:0.002:0.4), ls=[:solid :solid :dash :dash], title=\"\", lab=[\"Smith predictor\" \"\" \"Ideal predictor\" \"\"])\nplot!(yticks=[0.1, 1, 10], sp=1)\nplot!(yticks=0:180:1080, sp=2)","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"Check the Nyquist plot. Note that the Nyquist curve encircles -1 for τ > 2.99","category":"page"},{"location":"examples/smith_predictor/","page":"Smith predictor","title":"Smith predictor","text":"fig_nyquist = nyquistplot(C * P, exp10.(-1:1e-4:2), title=\"τ = $τ\")","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Pages = [\"timefreqresponse.md\"]","category":"page"},{"location":"lib/timefreqresponse/#Time-and-Frequency-response","page":"Time and Frequency response","title":"Time and Frequency response","text":"","category":"section"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Frequency responses are calculated using freqresp, bode and nyquist.","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Any TransferFunction can be evaluated at a point using F(s), F(omega, true), F(z, false)","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"F(s) evaluates the continuous-time transfer function F at s.\nF(omega,true) evaluates the discrete-time transfer function F at exp(i*Ts*omega)\nF(z,false) evaluates the discrete-time transfer function F at z","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Simulation with arbitrary inputs is primarily handled by the function lsim, with step and impulse serving as convenience functions to simulate responses to particular inputs.","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"For more extensive nonlinear simulation capabilities, see the notes on ModelingToolkit and DifferentialEquations under The wider Julia ecosystem for control.","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Modules = [ControlSystems, ControlSystemsBase]\nPages   = [libpath*\"/timeresp.jl\", libpath*\"/result_types.jl\", libpath*\"/freqresp.jl\", \"simulators.jl\"]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/timefreqresponse/#ControlSystems.Simulator","page":"Time and Frequency response","title":"ControlSystems.Simulator","text":"Simulator\n\nFields:\n\nP::StateSpace\nf = (x,p,t) -> x\ny = (x,t)   -> y\n\n\n\n\n\n","category":"type"},{"location":"lib/timefreqresponse/#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace, F}} where F","page":"Time and Frequency response","title":"ControlSystems.Simulator","text":"Simulator(P::StateSpace, u = (x,t) -> 0)\n\nUsed to simulate continuous-time systems. See function ?solve for additional info.\n\nUsage:\n\nusing OrdinaryDiffEq, Plots\ndt             = 0.1\ntfinal         = 20\nt              = 0:dt:tfinal\nP              = ss(tf(1,[2,1])^2)\nK              = 5\nreference(x,t) = [1.]\ns              = Simulator(P, reference)\nx0             = [0.,0]\ntspan          = (0.0,tfinal)\nsol            = solve(s, x0, tspan, Tsit5())\nplot(t, s.y(sol, t)[:], lab=\"Open loop step response\")\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#Base.step-Tuple{AbstractStateSpace, AbstractVector}","page":"Time and Frequency response","title":"Base.step","text":"y, t, x = step(sys[, tfinal])\ny, t, x = step(sys[, t])\n\nCalculate the step response of system sys. If the final time tfinal or time vector t is not provided, one is calculated based on the system pole locations. The return value is a structure of type SimResult that can be plotted or destructured as y, t, x = result.\n\ny has size (ny, length(t), nu), x has size (nx, length(t), nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.impulse-Tuple{AbstractStateSpace, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.impulse","text":"y, t, x = impulse(sys[, tfinal])\ny, t, x = impulse(sys[, t])\n\nCalculate the impulse response of system sys. If the final time tfinal or time vector t is not provided, one is calculated based on the system pole locations. The return value is a structure of type SimResult that can be plotted or destructured as y, t, x = result.\n\ny has size (ny, length(t), nu), x has size (nx, length(t), nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.lsim!-Union{Tuple{T}, Tuple{LsimWorkspace{T}, AbstractStateSpace{<:Discrete}, Any, AbstractVector}} where T","page":"Time and Frequency response","title":"ControlSystemsBase.lsim!","text":"res = lsim!(ws::LsimWorkspace, sys::AbstractStateSpace{<:Discrete}, u, [t]; x0)\n\nIn-place version of lsim that takes a workspace object created by calling LsimWorkspace. Notice, if u is a function, res.u === ws.u. If u is an array, res.u === u.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.lsim","text":"result = lsim(sys, u[, t]; x0, method])\nresult = lsim(sys, u::Function, t; x0, method)\n\nCalculate the time response of system sys to input u. If x0 is ommitted, a zero vector is used.\n\nThe result structure contains the fields y, t, x, u and can be destructured automatically by iteration, e.g.,\n\ny, t, x, u = result\n\nresult::SimResult can also be plotted directly:\n\nplot(result, plotu=true, plotx=false)\n\ny, x, u have time in the second dimension. Initial state x0 defaults to zero.\n\nContinuous-time systems are simulated using an ODE solver if u is a function (requires using ControlSystems). If u is an array, the system is discretized (with method=:zoh by default) before simulation. For a lower-level inteface, see ?Simulator and ?solve\n\nu can be a function or a matrix of precalculated control signals and must have dimensions (nu, length(t)). If u is a function, then u(x,i) (for discrete systems) or u(x,t) (for continuos ones) is called to calculate the control signal at every iteration (time instance used by solver). This can be used to provide a control law such as state feedback u(x,t) = -L*x calculated by lqr. To simulate a unit step at t=t₀, use (x,t)-> t ≥ t₀, for a ramp, use (x,t)-> t, for a step at t=5, use (x,t)-> (t >= 5) etc.\n\nNote: The function u will be called once before simulating to verify that it returns an array of the correct dimensions. This can cause problems if u is stateful. You can disable this check by passing check_u = false.\n\nFor maximum performance, see function lsim!, available for discrete-time systems only.\n\nUsage example:\n\nusing ControlSystems\nusing LinearAlgebra: I\nusing Plots\n\nA = [0 1; 0 0]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = I\nR = I\nL = lqr(sys,Q,R)\n\nu(x,t) = -L*x # Form control law\nt  = 0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x', lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")\n\n# Alternative way of plotting\nres = lsim(sys,u,t,x0=x0)\nplot(res)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.LsimWorkspace-Tuple{AbstractStateSpace, Int64}","page":"Time and Frequency response","title":"ControlSystemsBase.LsimWorkspace","text":"LsimWorkspace(sys::AbstractStateSpace, N::Int)\nLsimWorkspace(sys::AbstractStateSpace, u::AbstractMatrix)\nLsimWorkspace{T}(ny, nu, nx, N)\n\nGenereate a workspace object for use with the in-place function lsim!. sys is the discrete-time system to be simulated and N is the number of time steps, alternatively, the input u can be provided instead of N. Note: for threaded applications, create one workspace object per thread. \n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.bode-Tuple{LTISystem, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.bode","text":"mag, phase, w = bode(sys[, w]; unwrap=true)\n\nCompute the magnitude and phase parts of the frequency response of system sys at frequencies w. See also bodeplot\n\nmag and phase has size (length(w), ny, nu). If unwrap is true (default), the function unwrap! will be applied to the phase angles. This procedure is costly and can be avoided if the unwrapping is not required.\n\nFor higher performance, see the function bodemag! that computes the magnitude only.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.bodemag!-Tuple{BodemagWorkspace, LTISystem, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.bodemag!","text":"mag = bodemag!(ws::BodemagWorkspace, sys::LTISystem, w::AbstractVector)\n\nCompute the Bode magnitude operating in-place on an instance of BodemagWorkspace. Note that the returned magnitude array is aliased with ws.mag. The output array mag is ∈ 𝐑(ny, nu, nω).\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.evalfr-Tuple{AbstractStateSpace, Number}","page":"Time and Frequency response","title":"ControlSystemsBase.evalfr","text":"evalfr(sys, x)\n\nEvaluate the transfer function of the LTI system sys at the complex number s=x (continuous-time) or z=x (discrete-time).\n\nFor many values of x, use freqresp instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.freqresp!-Union{Tuple{T}, Tuple{Array{T, 3}, LTISystem, AbstractVector{<:Real}}} where T","page":"Time and Frequency response","title":"ControlSystemsBase.freqresp!","text":"freqresp!(R::Array{T, 3}, sys::LTISystem, w_vec::AbstractVector{<:Real})\n\nIn-place version of freqresp that takes a pre-allocated array R of size (ny, nu, nw)`\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.freqresp-Union{Tuple{W}, Tuple{LTISystem, AbstractVector{W}}} where W<:Real","page":"Time and Frequency response","title":"ControlSystemsBase.freqresp","text":"sys_fr = freqresp(sys, w)\n\nEvaluate the frequency response of a linear system\n\nw -> C*((iw*im*I - A)^-1)*B + D\n\nof system sys over the frequency vector w.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.nyquist-Tuple{LTISystem, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.nyquist","text":"re, im, w = nyquist(sys[, w])\n\nCompute the real and imaginary parts of the frequency response of system sys at frequencies w. See also nyquistplot\n\nre and im has size (length(w), ny, nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.sigma-Tuple{LTISystem, AbstractVector}","page":"Time and Frequency response","title":"ControlSystemsBase.sigma","text":"sv, w = sigma(sys[, w])\n\nCompute the singular values sv of the frequency response of system sys at frequencies w. See also sigmaplot\n\nsv has size (length(w), max(ny, nu))\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.BodemagWorkspace-Tuple{LTISystem, Int64}","page":"Time and Frequency response","title":"ControlSystemsBase.BodemagWorkspace","text":"BodemagWorkspace(sys::LTISystem, N::Int)\nBodemagWorkspace(sys::LTISystem, ω::AbstractVector)\nBodemagWorkspace(R::Array{Complex{T}, 3}, mag::Array{T, 3})\nBodemagWorkspace{T}(ny, nu, N)\n\nGenereate a workspace object for use with the in-place function bodemag!. N is the number of frequency points, alternatively, the input ω can be provided instead of N. Note: for threaded applications, create one workspace object per thread. \n\nArguments:\n\nmag: The output array ∈ 𝐑(ny, nu, nω)\nR: Frequency-response array ∈ 𝐂(ny, nu, nω)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystemsBase.TransferFunction-Tuple{Any}","page":"Time and Frequency response","title":"ControlSystemsBase.TransferFunction","text":"F(s), F(omega, true), F(z, false)\n\nNotation for frequency response evaluation.\n\nF(s) evaluates the continuous-time transfer function F at s.\nF(omega,true) evaluates the discrete-time transfer function F at exp(imTsomega)\nF(z,false) evaluates the discrete-time transfer function F at z\n\n\n\n\n\n","category":"method"},{"location":"man/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"To install the full set of features, simply run","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"ControlSystems\")","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"For workflows that do not require continuous-time simulation, you may instead opt to install the much lighter package ControlSystemsBase.jl","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"ControlSystemsBase\")","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"ControlSystemsBase contains all functionality of ControlSystems except continuous-time simulation and root locus, and is considerably faster to load and precompile. To enjoy the faster pre-compilation, do not even install ControlSystems since this will cause pre-compilation of OrdinaryDiffEq, which can take several minutes.","category":"page"},{"location":"man/introduction/#Basic-functions","page":"Introduction","title":"Basic functions","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using ControlSystems\n    P = tf([1],[1,1])\n    T = P/(1+P)\n    plotsDir = joinpath(dirname(pathof(ControlSystems)), \"..\", \"docs\", \"build\", \"plots\")\n    mkpath(plotsDir)\n    save_docs_plot(name) = Plots.savefig(joinpath(plotsDir,name))\n    save_docs_plot(p, name) = Plots.savefig(p, joinpath(plotsDir,name))\nend","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"State-space systems can be created using the function ss and transfer functions can be created using the function tf(num, den) or tf(num, den, Ts), where num and den are vectors representing the numerator and denominator of a rational function and Ts is the sample time for a discrete-time system. See tf or the section [Creating Systems] for more info. These functions can then be connected and modified using the operators +,-,*,/ and functions like append.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Example:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"P = tf([1.0],[1,1])\nT = P/(1+P)\n\n# output\n\nTransferFunction{Continuous, ControlSystemsBase.SisoRational{Float64}}\n    1.0s + 1.0\n-------------------\n1.0s^2 + 3.0s + 2.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Notice that the poles are not canceled automatically, to do this, the function minreal is available","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"minreal(T)\n\n# output\n\nTransferFunction{Continuous, ControlSystemsBase.SisoRational{Float64}}\n   1.0\n----------\n1.0s + 2.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"or use feedback(P) to get a minimal realization directly (recommended):","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using ControlSystems # hide\nP = tf([1.0],[1,1]) # hide\nfeedback(P) # Equivalent to P/(1+P)","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"note: Numerical accuracy\nTransfer functions represent systems using polynomials and may have poor numerical properties for high-order systems. Well-balanced state-space representations are often better behaved. See Performance considerations for more details.","category":"page"},{"location":"man/introduction/#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"The ControlSystems package is using RecipesBase.jl (link) as interface to generate all the plots. This means that it is up to the user to choose a plotting library that supports RecipesBase.jl, a suggestion would be Plots.jl with which the user is also able to freely choose a back-end. The plots in this manual are generated using Plots.jl with the GR backend. If you have several back-ends for plotting then you can select the one you want to use with the corresponding Plots call (for GR this is Plots.gr(), some alternatives are pyplot(), plotly(), pgfplots()). A simple example where we generate a plot and save it to a file is shown below.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"More examples of plots are provided in Plotting functions.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using Plots\nbodeplot(tf(1,[1,2,1]))","category":"page"},{"location":"lib/synthesis/","page":"Synthesis","title":"Synthesis","text":"Pages = [\"synthesis.md\"]","category":"page"},{"location":"lib/synthesis/#Synthesis","page":"Synthesis","title":"Synthesis","text":"","category":"section"},{"location":"lib/synthesis/","page":"Synthesis","title":"Synthesis","text":"For H_infty and H_2 synthesis as well as more advanced LQG design, see RobustAndOptimalControl.","category":"page"},{"location":"lib/synthesis/","page":"Synthesis","title":"Synthesis","text":"Modules = [ControlSystems, ControlSystemsBase]\nPages   = [\n        libpath*\"/synthesis.jl\",\n        libpath*\"/discrete.jl\",\n        libpath*\"/types/lqg.jl\",\n        libpath*\"/pid_design.jl\",\n        libpath*\"/simplification.jl\",\n        libpath*\"/connections.jl\",\n        libpath*\"/sensitivity_functions.jl\",\n        libpath*\"/utilities.jl\"\n    ]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/synthesis/#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}","page":"Synthesis","title":"ControlSystemsBase.kalman","text":"kalman(Continuous, A, C, R1, R2)\nkalman(Discrete, A, C, R1, R2)\nkalman(sys, R1, R2)\n\nCalculate the optimal Kalman gain\n\nThe args...; kwargs... are sent to the Riccati solver, allowing specification of cross-covariance etc. See ?MatrixEquations.arec/ared for more help.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}","page":"Synthesis","title":"ControlSystemsBase.lqr","text":"lqr(sys, Q, R)\nlqr(Continuous, A, B, Q, R, args...; kwargs...)\nlqr(Discrete, A, B, Q, R, args...; kwargs...)\n\nCalculate the optimal gain matrix K for the state-feedback law u = -K*x that minimizes the cost function:\n\nJ = integral(x'Qx + u'Ru, 0, inf) for the continuous-time model dx = Ax + Bu. J = sum(x'Qx + u'Ru, 0, inf) for the discrete-time model x[k+1] = Ax[k] + Bu[k].\n\nSolve the LQR problem for state-space system sys. Works for both discrete and continuous time systems.\n\nThe args...; kwargs... are sent to the Riccati solver, allowing specification of cross-covariance etc. See ?MatrixEquations.arec / ared for more help.\n\nExamples\n\nContinuous time\n\nusing LinearAlgebra # For identity matrix I\nusing Plots\nA = [0 1; 0 0]\nB = [0; 1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = I\nR = I\nL = lqr(sys,Q,R) # lqr(Continuous,A,B,Q,R) can also be used\n\nu(x,t) = -L*x # Form control law,\nt=0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x', lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")\n\nDiscrete time\n\nusing LinearAlgebra # For identity matrix I\nusing Plots\nTs = 0.1\nA = [1 Ts; 0 1]\nB = [0;1]\nC = [1 0]\nsys = ss(A, B, C, 0, Ts)\nQ = I\nR = I\nL = lqr(Discrete, A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(x,t) = -L*x # Form control law,\nt=0:Ts:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x', lab=[\"Position\"  \"Velocity\"], xlabel=\"Time [s]\")\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.place","page":"Synthesis","title":"ControlSystemsBase.place","text":"place(A, B, p, opt=:c)\nplace(sys::StateSpace, p, opt=:c)\n\nCalculate the gain matrix K such that A - BK has eigenvalues p.\n\nplace(A, C, p, opt=:o)\nplace(sys::StateSpace, p, opt=:o)\n\nCalculate the observer gain matrix L such that A - LC has eigenvalues p.\n\nUses Ackermann's formula. Currently handles only SISO systems.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.c2d","page":"Synthesis","title":"ControlSystemsBase.c2d","text":"sysd = c2d(sys::AbstractStateSpace{<:Continuous}, Ts, method=:zoh; w_prewarp=0)\nGd = c2d(G::TransferFunction{<:Continuous}, Ts, method=:zoh)\n\nConvert the continuous-time system sys into a discrete-time system with sample time Ts, using the specified method (:zoh, :foh, :fwdeuler or :tustin). Note that the forward-Euler method generally requires the sample time to be very small relative to the time constants of the system.\n\nmethod = :tustin performs a bilinear transform with prewarp frequency w_prewarp.\n\nw_prewarp: Frequency (rad/s) for pre-warping when usingthe Tustin method, has no effect for other methods.\n\nSee also c2d_x0map\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.c2d_poly2poly","text":"c2d_poly2poly(ro, Ts)\n\nreturns the polynomial coefficients in discrete time given polynomial coefficients in continuous time\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.c2d_roots2poly","text":"c2d_roots2poly(ro, Ts)\n\nreturns the polynomial coefficients in discrete time given a vector of roots in continuous time\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.c2d_x0map","page":"Synthesis","title":"ControlSystemsBase.c2d_x0map","text":"sysd, x0map = c2d_x0map(sys::AbstractStateSpace{<:Continuous}, Ts, method=:zoh; w_prewarp=0)\n\nReturns the discretization sysd of the system sys and a matrix x0map that transforms the initial conditions to the discrete domain by x0_discrete = x0map*[x0; u0]\n\nSee c2d for further details.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.d2c","page":"Synthesis","title":"ControlSystemsBase.d2c","text":"d2c(sys::AbstractStateSpace{<:Discrete}, method::Symbol = :zoh; w_prewarp=0)\n\nConvert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using method. Available methods are `:zoh, :fwdeuler´.\n\nw_prewarp: Frequency for pre-warping when usingthe Tustin method, has no effect for other methods.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.dab-Tuple{Any, Any, Any}","page":"Synthesis","title":"ControlSystemsBase.dab","text":"X,Y = dab(A,B,C)\n\nSolves the Diophantine-Aryabhatta-Bezout identity\n\nAX + BY = C, where A B C X and Y are polynomials and deg Y = deg A - 1.\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.rstc-Tuple","page":"Synthesis","title":"ControlSystemsBase.rstc","text":"See ?rstd for the discrete case\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.rstd-Tuple","page":"Synthesis","title":"ControlSystemsBase.rstd","text":"R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)\nR,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)\nR,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO)\n\nPolynomial synthesis in discrete time.\n\nPolynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)\n\nInputs:\n\nBPLUS  : Part of open loop numerator\nBMINUS : Part of open loop numerator\nA      : Open loop denominator\nBM1    : Additional zeros\nAM     : Closed loop denominator\nAO     : Observer polynomial\nAR     : Pre-specified factor of R,\n\ne.g integral part [1, -1]^k\n\nAS     : Pre-specified factor of S,\n\ne.g notch filter [1, 0, w^2]\n\nOutputs: R,S,T  : Polynomials in controller\n\nSee function dab how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.zpconv-NTuple{4, Any}","page":"Synthesis","title":"ControlSystemsBase.zpconv","text":"zpc(a,r,b,s)\n\nform conv(a,r) + conv(b,s) where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.laglink-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.laglink","text":"laglink(a, M; [Ts])\n\nReturns a phase retarding link, the rule of thumb a = 0.1ωc guarantees less than 6 degrees phase margin loss. The bode curve will go from M, bend down at a/M and level out at 1 for frequencies > a\n\ndfracs + as + aM = M dfrac1 + sa1 + sMa\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.leadlink","page":"Synthesis","title":"ControlSystemsBase.leadlink","text":"leadlink(b, N, K=1; [Ts])\n\nReturns a phase advancing link, the top of the phase curve is located at ω = b√(N) where the link amplification is K√(N) The bode curve will go from K, bend up at b and level out at KN for frequencies > bN\n\nThe phase advance at ω = b√(N) can be plotted as a function of N with leadlinkcurve()\n\nValues of N < 1 will give a phase retarding link.\n\nKN dfracs + bs + bN = K dfrac1 + sb1 + s(bN)\n\nSee also leadlinkat laglink\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.leadlinkat","page":"Synthesis","title":"ControlSystemsBase.leadlinkat","text":"leadlinkat(ω, N, K=1; [Ts])\n\nReturns a phase advancing link, the top of the phase curve is located at ω where the link amplification is K√(N) The bode curve will go from K, bend up at ω/√(N) and level out at KN for frequencies > ω√(N)\n\nThe phase advance at ω can be plotted as a function of N with leadlinkcurve()\n\nValues of N < 1 will give a phase retarding link.\n\nSee also leadlink laglink\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.leadlinkcurve","page":"Synthesis","title":"ControlSystemsBase.leadlinkcurve","text":"leadlinkcurve(start=1)\n\nPlot the phase advance as a function of N for a lead link (phase advance link) If an input argument start is given, the curve is plotted from start to 10, else from 1 to 10.\n\nSee also leadlink, leadlinkat\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.loopshapingPI","text":"C, kp, ki, fig, CF = loopshapingPI(P, ωp; ϕl, rl, phasemargin, form=:standard, doplot=false, Tf, F)\n\nSelects the parameters of a PI-controller (on parallel form) such that the Nyquist curve of P at the frequency ωp is moved to rl exp(i ϕl)\n\nThe parameters can be returned as one of several common representations  chosen by form, the options are\n\n:standard - K_p(1 + 1(T_i s) + T_ds)\n:series - K_c(1 + 1(τ_i s))(τ_d s + 1)\n:parallel - K_p + K_is + K_d s\n\nIf phasemargin is supplied (in degrees), ϕl is selected such that the curve is moved to an angle of phasemargin - 180 degrees\n\nIf no rl is given, the magnitude of the curve at ωp is kept the same and only the phase is affected, the same goes for ϕl if no phasemargin is given.\n\nTf: An optional time constant for second-order measurement noise filter on the form tf(1, [Tf^2, 2*Tf/sqrt(2), 1]) to make the controller strictly proper.\nF: A pre-designed filter to use instead of the default second-order filter that is used if Tf is given.\ndoplot plot the gangoffourplot and nyquistplot of the system.\n\nSee also loopshapingPID, pidplots, stabregionPID and placePI.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.loopshapingPID","text":"C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.3, ϕt=75, form=:standard, doplot=false, lb=-10, ub=10, Tf = 1/1000ω, F = nothing)\n\nSelects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function L = PC at the frequency ω is tangent to the circle where the magnitude of T = PC  (1+PC) equals Mt. ϕt denotes the positive angle in degrees between the real axis and the tangent point.\n\nThe default values for Mt and ϕt are chosen to give a good design for processes with inertia, and may need tuning for simpler processes.\n\nThe gain of the resulting controller is generally increasing with increasing ω and Mt.\n\nArguments:\n\nP: A SISO plant.\nω: The specification frequency.\nMt: The magnitude of the complementary sensitivity function at the specification frequency, T(iω).\nϕt: The \ndoplot: If true, gang of four and Nyquist plots will be returned in fig.\nlb: log10 of lower bound for kd.\nub: log10 of upper bound for kd.\nTf: Time constant for second-order measurement noise filter on the form tf(1, [Tf^2, 2*Tf/sqrt(2), 1]) to make the controller strictly proper. A practical controller typically sets this time constant slower than the default, e.g., Tf = 1/100ω or Tf = 1/10ω\nF: A pre-designed filter to use instead of the default second-order filter.\n\nThe parameters can be returned as one of several common representations  chosen by form, the options are\n\n:standard - K_p(1 + 1(T_i s) + T_ds)\n:series - K_c(1 + 1(τ_i s))(τ_d s + 1)\n:parallel - K_p + K_is + K_d s\n\nSee also loopshapingPI, pidplots, stabregionPID and placePI.\n\nExample:\n\nP  = tf(1, [1,0,0]) # A double integrator\nMt = 1.3  # Maximum magnitude of complementary sensitivity\nω  = 1    # Frequency at which the specification holds\nC, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt = 75, doplot=true)\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.pid","page":"Synthesis","title":"ControlSystemsBase.pid","text":"C = pid(param_p, param_i, [param_d]; form=:standard, state_space=false, [Tf], [Ts])\n\nCalculates and returns a PID controller. \n\nThe form can be chosen as one of the following\n\n:standard - Kp*(1 + 1/(Ti*s) + Td*s) \n:series - Kc*(1 + 1/(τi*s))*(τd*s + 1)\n:parallel - Kp + Ki/s + Kd*s\n\nIf state_space is set to true, either kd has to be zero  or a positive Tf has to be provided for creating a filter on  the input to allow for a state space realization.  The filter used is 1 / (1 + s*Tf + (s*Tf)^2/2), where Tf can typically  be chosen as Ti/N for a PI controller and Td/N for a PID controller, and N is commonly in the range 2 to 20.  The state space will be returned on controllable canonical form.\n\nFor a discrete controller a positive Ts can be supplied.\n\nExamples\n\nC1 = pid(3.3, 1, 2)                             # Kd≠0 works without filter in tf form\nC2 = pid(3.3, 1, 2; Tf=0.3, state_space=true)   # In statespace a filter is needed\nC3 = pid(2., 3, 0; Ts=0.4, state_space=true)    # Discrete\n\nThe functions pid_tf and pid_ss are also exported. They take the same parameters and is what is actually called in pid based on the state_space parameter.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}","page":"Synthesis","title":"ControlSystemsBase.pidplots","text":"pidplots(P, args...; params_p, params_i, params_d=0, form=:standard, ω=0, grid=false, kwargs...)\n\nPlots interesting figures related to closing the loop around process P with a PID controller supplied in params on one of the following forms:\n\n:standard - Kp*(1 + 1/(Ti*s) + Td*s) \n:series - Kc*(1 + 1/(τi*s))*(τd*s + 1)\n:parallel - Kp + Ki/s + Kd*s\n\nThe sent in values can be arrays to evaluate multiple different controllers, and if grid=true it will be a grid search  over all possible combinations of the values.\n\nAvailable plots are :gof for Gang of four, :nyquist, :controller for a bode plot of the controller TF and :pz for pole-zero maps and should be supplied as additional arguments to the function.\n\nOne can also supply a frequency vector ω to be used in Bode and Nyquist plots.\n\nSee also loopshapingPI, stabregionPID\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{<:Continuous, <:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T","page":"Synthesis","title":"ControlSystemsBase.placePI","text":"C, kp, ki = placePI(P, ω₀, ζ; form=:standard)\n\nSelects the parameters of a PI-controller such that the poles of  closed loop between P and C are placed to match the poles of  s^2 + 2ζω₀s + ω₀^2.\n\nThe parameters can be returned as one of several common representations  chose by form, the options are\n\n:standard - K_p(1 + 1(T_i s))\n:series - K_c(1 + 1(τ_i s)) (equivalent to above for PI controllers)\n:parallel - K_p + K_is\n\nC is the returned transfer function of the controller and params  is a named tuple containing the parameters. The parameters can be accessed as params.Kp or params[\"Kp\"] from the named tuple, or they can be unpacked using Kp, Ti, Td = values(params).\n\nSee also loopshapingPI\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.stabregionPID","page":"Synthesis","title":"ControlSystemsBase.stabregionPID","text":"kp, ki, fig = stabregionPID(P, [ω]; kd=0, doplot=false, form=:standard)\n\nSegments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The provided derivative gain is expected on parallel form, i.e., the form kp + ki/s + kd s, but the result can be transformed to any form given by the form keyword. The curve is found by analyzing\n\nP(s)C(s) = -1  \nPC = P C = 1 \narg(P) + arg(C) = -π\n\nIf P is a function (e.g. s -> exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions See also loopshapingPI, loopshapingPID, pidplots\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}","page":"Synthesis","title":"ControlSystemsBase.sminreal","text":"sminreal(sys)\n\nCompute the structurally minimal realization of the state-space system sys. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in sys are removed.\n\nSystems with numerical noise in the coefficients, e.g., noise on the order of eps require truncation to zero to be affected by structural simplification, e.g.,\n\ntrunc_zero!(A) = A[abs.(A) .< 10eps(maximum(abs, A))] .= 0\ntrunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)\nsminreal(sys)\n\nSee also minreal\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.add_input","page":"Synthesis","title":"ControlSystemsBase.add_input","text":"add_input(sys::AbstractStateSpace, B2::AbstractArray, D2 = 0)\n\nAdd inputs to sys by forming\n\nx = Ax + B  B_2u\ny  = Cx + D  D_2u\n\nIf B2 is an integer it will be interpreted as an index and an input matrix containing a single 1 at the specified index will be used.\n\nExample: The following example forms an innovation model that takes innovations as inputs\n\nG   = ssrand(2,2,3, Ts=1)\nK   = kalman(G, I(G.nx), I(G.ny))\nsys = add_input(G, K)\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.add_output","page":"Synthesis","title":"ControlSystemsBase.add_output","text":"add_output(sys::AbstractStateSpace, C2::AbstractArray, D2 = 0)\n\nAdd outputs to sys by forming\n\nx = Ax + Bu\ny  = C C_2x + D D_2u\n\nIf C2 is an integer it will be interpreted as an index and an output matrix containing a single 1 at the specified index will be used.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}","page":"Synthesis","title":"ControlSystemsBase.append","text":"append(systems::StateSpace...), append(systems::TransferFunction...)\n\nAppend systems in block diagonal form\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.array2mimo-Tuple{AbstractArray{<:LTISystem}}","page":"Synthesis","title":"ControlSystemsBase.array2mimo","text":"array2mimo(M::AbstractArray{<:LTISystem})\n\nTake an array of LTISystems and create a single MIMO system.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}","page":"Synthesis","title":"ControlSystemsBase.feedback","text":"feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;\n         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],\n         Wperm=:, Zperm=:, pos_feedback::Bool=false)\n\nBasic use feedback(sys1, sys2) forms the feedback interconnection\n\n           ┌──────────────┐\n◄──────────┤     sys1     │◄──── Σ ◄──────\n    │      │              │      │\n    │      └──────────────┘      -1\n    │                            |\n    │      ┌──────────────┐      │\n    └─────►│     sys2     ├──────┘\n           │              │\n           └──────────────┘\n\nAdvanced use feedback also supports more flexible use according to the figure below\n\n              ┌──────────────┐\n      z1◄─────┤     sys1     │◄──────w1\n ┌─── y1◄─────┤              │◄──────u1 ◄─┐\n │            └──────────────┘            │\n │                                        α\n │            ┌──────────────┐            │\n └──► u2─────►│     sys2     ├───────►y2──┘\n      w2─────►│              ├───────►z2\n              └──────────────┘\n\nU1, W1 specifies the indices of the input signals of sys1 corresponding to u1 and w1 Y1, Z1 specifies the indices of the output signals of sys1 corresponding to y1 and z1 U2, W2, Y2, Z2 specifies the corresponding signals of sys2 \n\nSpecify  Wperm and Zperm to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.\n\nNegative feedback (α = -1) is the default. Specify pos_feedback=true for positive feedback (α = 1).\n\nSee also lft, starprod, sensitivity, input_sensitivity, output_sensitivity, comp_sensitivity, input_comp_sensitivity, output_comp_sensitivity, G_PS, G_CS.\n\nSee Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.feedback-Tuple{TransferFunction}","page":"Synthesis","title":"ControlSystemsBase.feedback","text":"feedback(sys)\nfeedback(sys1, sys2)\n\nFor a general LTI-system, feedback forms the negative feedback interconnection\n\n>-+ sys1 +-->\n  |      |\n (-)sys2 +\n\nIf no second system is given, negative identity feedback is assumed\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}","page":"Synthesis","title":"ControlSystemsBase.feedback2dof","text":"feedback2dof(P,R,S,T)\nfeedback2dof(B,A,R,S,T)\n\nReturn BT/(AR+ST) where B and A are the numerator and denomenator polynomials of P respectively\nReturn BT/(AR+ST)\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE","page":"Synthesis","title":"ControlSystemsBase.feedback2dof","text":"feedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)\n\nReturn the transfer function P(F+C)/(1+PC) which is the closed-loop system with process P, controller C and feedforward filter F from reference to control signal (by-passing C).\n\n         +-------+\n         |       |\n   +----->   F   +----+\n   |     |       |    |\n   |     +-------+    |\n   |     +-------+    |    +-------+\nr  |  -  |       |    |    |       |    y\n+--+----->   C   +----+---->   P   +---+-->\n      |  |       |         |       |   |\n      |  +-------+         +-------+   |\n      |                                |\n      +--------------------------------+\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.lft","page":"Synthesis","title":"ControlSystemsBase.lft","text":"lft(G, Δ, type=:l)\n\nLower and upper linear fractional transformation between systems G and Δ.\n\nSpecify :l lor lower LFT, and :u for upper LFT.\n\nG must have more inputs and outputs than Δ has outputs and inputs.\n\nFor details, see Chapter 9.1 in Zhou, K. and JC Doyle. Essentials of robust control, Prentice hall (NJ), 1998\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}","page":"Synthesis","title":"ControlSystemsBase.parallel","text":"parallel(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in parallel, equivalent to sys2+sys1\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.series-Tuple{LTISystem, LTISystem}","page":"Synthesis","title":"ControlSystemsBase.series","text":"series(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in series, equivalent to sys2*sys1\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}","page":"Synthesis","title":"ControlSystemsBase.starprod","text":"starprod(sys1, sys2, dimu, dimy)\n\nCompute the Redheffer star product.\n\nlength(U1) = length(Y2) = dimu and length(Y1) = length(U2) = dimy\n\nFor details, see Chapter 9.3 in Zhou, K. and JC Doyle. Essentials of robust control, Prentice hall (NJ), 1998\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.G_CS-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.G_CS","text":"G_CS(P, C)\n\nThe closed-loop transfer function from (-) measurement noise or (+) reference to control signal. Technically, the transfer function is given by (1 + CP)⁻¹C so SC would be a better, but nonstandard name.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.G_PS-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.G_PS","text":"G_PS(P, C)\n\nThe closed-loop transfer function from load disturbance to plant output. Technically, the transfer function is given by (1 + PC)⁻¹P so SP would be a better, but nonstandard name.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.comp_sensitivity-Tuple","page":"Synthesis","title":"ControlSystemsBase.comp_sensitivity","text":"See output_comp_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.extended_gangoffour","page":"Synthesis","title":"ControlSystemsBase.extended_gangoffour","text":"extended_gangoffour(P, C, pos=true)\n\nReturns a single statespace system that maps \n\nw1 reference or measurement noise\nw2 load disturbance\n\nto\n\nz1 control error\nz2 control input\n\n      z1          z2\n      ▲  ┌─────┐  ▲      ┌─────┐\n      │  │     │  │      │     │\nw1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐\n    │    │     │      │  │     │ │\n    │    └─────┘      │  └─────┘ │\n    │                 w2         │\n    └────────────────────────────┘\n\nThe returned system has the transfer-function matrix\n\nbeginbmatrix\nI  C\nendbmatrix (I + PC)^-1 beginbmatrix\nI  P\nendbmatrix\n\nor in code\n\n# For SISO P\nS  = G[1, 1]\nPS = G[1, 2]\nCS = G[2, 1]\nT  = G[2, 2]\n\n# For MIMO P\nS  = G[1:P.ny,     1:P.nu]\nPS = G[1:P.ny,     P.nu+1:end]\nCS = G[P.ny+1:end, 1:P.nu]\nT  = G[P.ny+1:end, P.nu+1:end]\n\nThe gang of four can be plotted like so\n\nGcl = extended_gangoffour(G, C) # Form closed-loop system\nbodeplot(Gcl, lab=[\"S\" \"CS\" \"PS\" \"T\"], plotphase=false) |> display # Plot gang of four\n\nNote, the last input of Gcl is the negative of the PS and T transfer functions from gangoffour2. To get a transfer matrix with the same sign as G_PS and input_comp_sensitivity, call extended_gangoffour(P, C, pos=false). See glover_mcfarlane from RobustAndOptimalControl.jl for an extended example. See also ncfmargin and feedback_control from RobustAndOptimalControl.jl.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.input_comp_sensitivity","text":"input_comp_sensitivity(P,C)\n\nTransfer function from load disturbance to control signal.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case controller output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.input_sensitivity","text":"input_sensitivity(P, C)\n\nTransfer function from load disturbance to total plant input.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.output_comp_sensitivity","text":"output_comp_sensitivity(P,C)\n\nTransfer function from measurement noise / reference to plant output.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case plant output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}","page":"Synthesis","title":"ControlSystemsBase.output_sensitivity","text":"output_sensitivity(P, C)\n\nTransfer function from measurement noise / reference to control error.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.sensitivity-Tuple","page":"Synthesis","title":"ControlSystemsBase.sensitivity","text":"See output_sensitivity\n\nThe output sensitivity function S_o = (I + PC)^-1 is the transfer function from a reference input to control error, while the input sensitivity function S_i = (I + CP)^-1 is the transfer function from a disturbance at the plant input to the total plant input. For SISO systems, input and output sensitivity functions are equal. In general, we want to minimize the sensitivity function to improve robustness and performance, but pracitcal constraints always cause the sensitivity function to tend to 1 for high frequencies. A robust design minimizes the peak of the sensitivity function, M_S. The peak magnitude of S is the inverse of the distance between the open-loop Nyquist curve and the critical point -1. Upper bounding the sensitivity peak M_S gives lower-bounds on phase and gain margins according to\n\nϕ_m  2textsin^-1(frac12M_S) g_m  fracM_SM_S-1\n\nGenerally, bounding M_S is a better objective than looking at gain and phase margins due to the possibility of combined gain and pahse variations, which may lead to poor robustness despite large gain and pahse margins.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │     └─────┘     │\n      │                 │\n      │     ┌─────┐    -│\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\ninput_sensitivity is the transfer function from d₁ to e₁,       (I + CP)⁻¹\noutput_sensitivity is the transfer function from d₂ to e₃,      (I + PC)⁻¹\ninput_comp_sensitivity is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP\noutput_comp_sensitivity is the transfer function from d₂ to e₄, (I + PC)⁻¹PC\nG_PS is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P\nG_CS is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}","page":"Synthesis","title":"ControlSystemsBase.bodev","text":"bodev(sys::LTISystem, w::AbstractVector; $(Expr(:kw, :unwrap, true)))\n\nFor use with SISO systems where it acts the same as bode but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.bodev-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystemsBase.bodev","text":"bodev(sys::LTISystem; )\n\nFor use with SISO systems where it acts the same as bode but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{<:Real}}","page":"Synthesis","title":"ControlSystemsBase.freqrespv","text":"freqrespv(G::AbstractMatrix, w_vec::AbstractVector{<:Real}; )\n\nFor use with SISO systems where it acts the same as freqresp but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{<:Real}}","page":"Synthesis","title":"ControlSystemsBase.freqrespv","text":"freqrespv(G::Number, w_vec::AbstractVector{<:Real}; )\n\nFor use with SISO systems where it acts the same as freqresp but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.freqrespv-Union{Tuple{var\"#319#W\"}, Tuple{LTISystem, AbstractVector{var\"#319#W\"}}} where var\"#319#W\"<:Real","page":"Synthesis","title":"ControlSystemsBase.freqrespv","text":"freqrespv(sys::LTISystem, w_vec::AbstractVector{W}; )\n\nFor use with SISO systems where it acts the same as freqresp but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}","page":"Synthesis","title":"ControlSystemsBase.nyquistv","text":"nyquistv(sys::LTISystem, w::AbstractVector; )\n\nFor use with SISO systems where it acts the same as nyquist but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.nyquistv-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystemsBase.nyquistv","text":"nyquistv(sys::LTISystem; )\n\nFor use with SISO systems where it acts the same as nyquist but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}","page":"Synthesis","title":"ControlSystemsBase.sigmav","text":"sigmav(sys::LTISystem, w::AbstractVector; )\n\nFor use with SISO systems where it acts the same as sigma but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystemsBase.sigmav-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystemsBase.sigmav","text":"sigmav(sys::LTISystem; )\n\nFor use with SISO systems where it acts the same as sigma but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<p style=\"text-align:center\">\n\n<img src=\"https://avatars.githubusercontent.com/u/10605979?s=400&u=7b2efdd404c4db3b3f067f04c305d40c025a8961&v=4\" alt=\"JuliaControl logo\">\n\n<br> \n\n<a class=\"github-button\" href=\"https://github.com/JuliaControl/ControlSystems.jl\" data-color-scheme=\"no-preference: light; light: light; dark: dark;\" data-icon=\"octicon-star\" data-show-count=\"true\" aria-label=\"Star JuliaControl/ControlSystems.jl on GitHub\">Star</a>\n\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n</p> ","category":"page"},{"location":"#ControlSystems.jl-Manual","page":"Home","title":"ControlSystems.jl Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ControlSystems\nconst libpath = haskey(ENV, \"CI\") ? dirname(pathof(ControlSystemsBase)) : \"lib/src\"\nDocTestFilters = [\n    r\"StateSpace.+?\\n\"\n    r\"HeteroStateSpace.+?\\n\"\n    r\"TransferFunction.+?\\n\"\n    r\"DelayLtiSystem.+?\\n\"\n    r\"┌ Warning: Keyword argument hover.+\\n*.+\\n*\" # remove next line as well\n    r\"\\[ Info: Precompiling.+\\n*\"\n]\nnyquistplot(ssrand(1,1,1))","category":"page"},{"location":"","page":"Home","title":"Home","text":"ControlSystems.jl and the rest of the packages in the JuliaControl organization implement solutions for analysis and design of (primarily linear) control systems. If you are new to the Julia programming language, learn more here. If you are familiar with Julia but unfamiliar with the ecosystem for control, learn more under Ecosystem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is structured into an introductory section labeled Introductory guide, a section with Examples and a reference section sorted into topics, labeled Functions.","category":"page"},{"location":"#Introductory-guide","page":"Home","title":"Introductory guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/introduction.md\", \"man/creating_systems.md\", \"man/numerical.md\", \"man/differences.md\"]\nDepth = 1","category":"page"},{"location":"#index_examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"examples/example.md\", \"examples/ilc.md\", \"examples/smith_predictor.md\"]\nDepth = 2","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/constructors.md\",  \"lib/analysis.md\", \"lib/synthesis.md\", \"lib/timefreqresponse.md\", \"lib/plotting.md\", \"lib/nonlinear.md\"]\nDepth = 1","category":"page"},{"location":"#Ecosystem","page":"Home","title":"Ecosystem","text":"","category":"section"},{"location":"#JuliaControl","page":"Home","title":"JuliaControl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The JuliaControl and surrounding ecosystem contains a few additional packages that may be of interest","category":"page"},{"location":"","page":"Home","title":"Home","text":"RobustAndOptimalControl.jl contains more advanced features for LQG design, robust analysis and synthesis, uncertainty modeling, named systems and an interface to DescriptorSystems.jl.\nSymbolicControlSystems.jl contains basic C-code generation for linear systems.\nControlSystemIdentification.jl is a system-identification toolbox for identification of LTI systems using either time or frequency-domain data.\nDiscretePIDs.jl contains a reference implementation in Julia of a discrete-time PID controller including set-point weighting, integrator anti-windup, derivative filtering and bumpless transfer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also the paper describing the toolbox","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bagge Carlson, F., Fält, M., Heimerson, A., & Troeng, O. (2021). ControlSystems.jl: A Control Toolbox in Julia. In 2021 60th IEEE Conference on Decision and Control (CDC) IEEE Press. https://doi.org/10.1109/CDC45484.2021.9683403","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the introductory Youtube video below, as well as the following Youtube playlist with videos about using Julia for control.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<iframe style=\"height: 315px; width: 560px\" src=\"https://www.youtube.com/embed/Fdz2Fsm1aTY\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#The-wider-Julia-ecosystem-for-control","page":"Home","title":"The wider Julia ecosystem for control","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following is a list of packages from the wider Julia ecosystem that may be of interest.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DescriptorSystems.jl contains types that represent statespace systems on descriptor form, i.e., with a mass matrix. These systems can represent linear DAE systems and non-proper systems.\nTrajectoryOptimization.jl is one of the more developed packages for open-loop optimal control and trajectory optimization in Julia.\nLowLevelParticleFilters.jl is a library for state estimation using particle filters and Kalman filters of different flavors.\nModelingToolkit.jl is an acausal modeling tool, similar in spirit to Modelica. A video showing ControlSystems and ModelingToolkit together is available here. ControlSystemsMTK.jl exists to ease the use of these two packages together.\nJuliaSimControl.jl is a product that builds upon the JuliaControl ecosystem and ModelingToolkit, providing additional nonlinear and robust control methods.\nFaultDetectionTools.jl contains utilities and observers for online fault detection.\nReachabilityAnalysis.jl is a package for reachability analysis. This can be used to verify stability and safety properties of linear and nonlinear systems.\nMatrixEquations.jl contains solvers for many different matrix equations common in control. ControlSystems.jl makes use of this package for solving Riccati and Lyapunov equations.\nJuMP.jl is a modeling language for optimization, similar to YALMIP. JuMP is suitable for solving LMI/SDP problems as well as advanced linear MPC problems. \nSumOfSquares.jl is a package for sum-of-squares programming that builds on top of JuMP. Their documentation contains examples of Lyapunov-function search and nonlinear synthesis.\nMonteCarloMeasurements.jl is a library for working with parametric uncertainty. An example using ControlSystems is available here.\nDifferentialEquations.jl is the home of the SciML ecosystem that provides solvers for scientific problems. ControlSystems.jl uses these solvers for continuous-time simulations.\nDojo.jl is a differentiable robot simulator.\nStaticCompiler.jl contains tools for compiling small binaries of Julia programs.\nJuliaPOMDP is a Julia ecosystem for reinforcement learning. \nJuliaReinforcementLearning is another Julia ecosystem for reinforcement learning. ","category":"page"},{"location":"examples/delay_systems/#Properties-of-delay-systems","page":"Properties of delay systems","title":"Properties of delay systems","text":"","category":"section"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"Delay systems can sometimes have non-intuitive properties, in particular when the delays appear inside of the system, i.e., not directly on the inputs or outputs. ","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"The Nyquist plot of delay systems usually spirals towards the origin for delay systems. This is due to the phase loss at high frequencies due to the delay:","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"using ControlSystemsBase, Plots\nw = exp10.(LinRange(-2, 2, 2000))\nP = tf(1, [1, 1]) * delay(2) # Plant with delay on the input\nnyquistplot(P, w)","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"When forming a feedback interconnection, making the delay appear in the closed loop, we may get gain ripple:","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"bodeplot(feedback(P), w)","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"If the system with delay has a direct feedthrough term, step responses may show repeated steps at integer multiples of the delay:","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"using ControlSystems # Load full control systems to get simulation functionality\nP = tf([1, 1], [1, 0])*delay(1)\nplot(step(feedback(P, 0.5), 0:0.001:20))","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"Indeed, if the system has a non-zero feedthrough, the output will contain a delayed step attenuated by the feedthrough term, in this case","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"ss(feedback(tf([1, 1], [1, 0]))).D[]","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"the steps will thus in this case decay exponentially with decay rate 0.5. ","category":"page"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"For a more advanced example using time delays, see the Smith predictor tutorial.","category":"page"},{"location":"examples/delay_systems/#Simulation-of-time-delay-systems","page":"Properties of delay systems","title":"Simulation of time-delay systems","text":"","category":"section"},{"location":"examples/delay_systems/","page":"Properties of delay systems","title":"Properties of delay systems","text":"Time-delay systems are numerically challenging to simulate, if you run into problems, please open an issue with a reproducing example. The lsim, step and impulse functions accept keyword arguments that are passed along to the ODE integrator, this can be used to both select integration method and to tweak the integrator options. The documentation for solving delay-differential equations is available here and here.","category":"page"}]
}
