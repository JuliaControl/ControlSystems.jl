var documenterSearchIndex = {"docs":
[{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Pages = [\"analysis.md\"]","category":"page"},{"location":"lib/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"lib/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [ControlSystems]\nPages   = [\"analysis.jl\", \"matrix_comps.jl\"]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/analysis/#ControlSystems.damp-Tuple{LTISystem}","page":"Analysis","title":"ControlSystems.damp","text":"Wn, zeta, ps = damp(sys)\n\nCompute the natural frequencies, Wn, and damping ratios, zeta, of the poles, ps, of sys\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.dampreport-Tuple{IO,LTISystem}","page":"Analysis","title":"ControlSystems.dampreport","text":"dampreport(sys)\n\nDisplay a report of the poles, damping ratio, natural frequency, and time constant of the system sys\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.dcgain-Tuple{LTISystem}","page":"Analysis","title":"ControlSystems.dcgain","text":"dcgain(sys)\n\nCompute the dcgain of system sys.\n\nequal to G(0) for continuous-time systems and G(1) for discrete-time systems.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.delaymargin-Tuple{LTISystem}","page":"Analysis","title":"ControlSystems.delaymargin","text":"dₘ = delaymargin(G::LTISystem)\n\nOnly supports SISO systems\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.gangoffour-Tuple{LTISystem,LTISystem}","page":"Analysis","title":"ControlSystems.gangoffour","text":"S,D,N,T = gangoffour(P,C; minimal=true)\ngangoffour(P::AbstractVector,C::AbstractVector; minimal=true)\n\nGiven a transfer function describing the Plant P and a transfer function describing the controller C, computes the four transfer functions in the Gang-of-Four.\n\nminimal determines whether or not to call minreal on the computed systems.\n\nS = 1/(1+PC) Sensitivity function\n\nD = P/(1+PC)\n\nN = C/(1+PC)\n\nT = PC/(1+PC) Complementary sensitivity function\n\nOnly supports SISO systems\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.gangofseven-Tuple{TransferFunction,TransferFunction,TransferFunction}","page":"Analysis","title":"ControlSystems.gangofseven","text":"S, D, N, T, RY, RU, RE = gangofseven(P,C,F)\n\nGiven transfer functions describing the Plant P, the controller C and a feed forward block F, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.\n\nS = 1/(1+PC) Sensitivity function\n\nD = P/(1+PC)\n\nN = C/(1+PC)\n\nT = PC/(1+PC) Complementary sensitivity function\n\nRY = PCF/(1+PC)\n\nRU = CF/(1+P*C)\n\nRE = F/(1+P*C)\n\nOnly supports SISO systems\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.margin-Tuple{LTISystem,AbstractArray{var\"#s322\",1} where var\"#s322\"<:Real}","page":"Analysis","title":"ControlSystems.margin","text":"ωgₘ, gₘ, ωϕₘ, ϕₘ = margin{S<:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)\n\nreturns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins\n\nIf !allMargins, return only the smallest margin\n\nIf full return also fullPhase\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.markovparam-Tuple{AbstractStateSpace,Integer}","page":"Analysis","title":"ControlSystems.markovparam","text":"markovparam(sys, n)\n\nCompute the nth markov parameter of state-space system sys. This is defined as the following:\n\nh(0) = D\n\nh(n) = C*A^(n-1)*B\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.pole-Tuple{AbstractStateSpace}","page":"Analysis","title":"ControlSystems.pole","text":"pole(sys)\n\nCompute the poles of system sys.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.reduce_sys-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractArray{T,2} where T,AbstractFloat}","page":"Analysis","title":"ControlSystems.reduce_sys","text":"Implements REDUCE in the Emami-Naeini & Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.tzero-Tuple{TransferFunction}","page":"Analysis","title":"ControlSystems.tzero","text":"tzero(sys)\n\nCompute the invariant zeros of the system sys. If sys is a minimal realization, these are also the transmission zeros.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.zpkdata-Tuple{LTISystem}","page":"Analysis","title":"ControlSystems.zpkdata","text":"z, p, k = zpkdata(sys)\n\nCompute the zeros, poles, and gains of system sys.\n\nReturns\n\nz : Matrix{Vector{ComplexF64}}, (ny x nu)\n\np : Matrix{Vector{ComplexF64}}, (ny x nu)\n\nk : Matrix{Float64}, (ny x nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.balance","page":"Analysis","title":"ControlSystems.balance","text":"S, P, B = balance(A[, perm=true])\n\nCompute a similarity transform T resulting in B = T\\A*T such that the row and column norms of B are approximately equivalent. If perm=false, the transformation will only scale A using diagonal S, and not permute A (i.e., set P=I).\n\n\n\n\n\n","category":"function"},{"location":"lib/analysis/#ControlSystems.balreal-Tuple{ST} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystems.balreal","text":"sysr, G = balreal(sys::StateSpace)\n\nCalculates a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal G\n\nSee also gram, baltrunc\n\nGlad, Ljung, Reglerteori: Flervariabla och Olinjära metoder\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.baltrunc-Tuple{ST} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystems.baltrunc","text":"sysr, G = baltrunc(sys::StateSpace, atol = √ϵ, rtol=1e-3, unitgain=true)\n\nReduces the state dimension by calculating a balanced realization of the system sys, such that the observability and reachability gramians of the balanced system are equal and diagonal G, and truncating it such that all states corresponding to singular values less than atol and less that rtol σmax are removed. If unitgain=true, the matrix D is chosen such that unit static gain is achieved.\n\nSee also gram, balreal\n\nGlad, Ljung, Reglerteori: Flervariabla och Olinjära metoder\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.care-NTuple{4,Any}","page":"Analysis","title":"ControlSystems.care","text":"care(A, B, Q, R)\n\nCompute 'X', the solution to the continuous-time algebraic Riccati equation, defined as A'X + XA - (XB)R^-1(B'X) + Q = 0, where R is non-singular.\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.covar-Tuple{AbstractStateSpace,Any}","page":"Analysis","title":"ControlSystems.covar","text":"P = covar(sys, W)\n\nCalculate the stationary covariance P = E[y(t)y(t)'] of the output y of a StateSpace model sys driven by white Gaussian noise w with covariance E[w(t)w(τ)]=W*δ(t-τ) (δ is the Dirac delta).\n\nRemark: If sys is unstable then the resulting covariance is a matrix of Infs. Entries corresponding to direct feedthrough (DWD' .!= 0) will equal Inf for continuous-time systems.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.ctrb-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Analysis","title":"ControlSystems.ctrb","text":"ctrb(A, B) or ctrb(sys)\n\nCompute the controllability matrix for the system described by (A, B) or sys.\n\nNote that checking for controllability by computing the rank from ctrb is not the most numerically accurate way, a better method is checking if gram(sys, :c) is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.dare-NTuple{4,Any}","page":"Analysis","title":"ControlSystems.dare","text":"dare(A, B, Q, R)\n\nCompute X, the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where Q>=0 and R>0\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.dlyap-Tuple{AbstractArray{T,2} where T,Any}","page":"Analysis","title":"ControlSystems.dlyap","text":"dlyap(A, Q)\n\nCompute the solution X to the discrete Lyapunov equation AXA' - X + Q = 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.gram-Tuple{AbstractStateSpace,Symbol}","page":"Analysis","title":"ControlSystems.gram","text":"gram(sys, opt)\n\nCompute the grammian of system sys. If opt is :c, computes the controllability grammian. If opt is :o, computes the observability grammian.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.hinfnorm-Tuple{AbstractStateSpace{var\"#s158\"} where var\"#s158\"<:Continuous}","page":"Analysis","title":"ControlSystems.hinfnorm","text":"(Ninf, ω_peak) = hinfnorm(sys; tol=1e-6)\n\nCompute the H∞ norm Ninf of the LTI system sys, together with a frequency ω_peak at which the gain Ninf is achieved.\n\nNinf := sup_ω σ_max[sys(iω)]  if G is stable (σ_max = largest singular value)       :=        Inf'           ifG` is unstable\n\ntol is an optional keyword argument for the desired relative accuracy for the computed H∞ norm (not an absolute certificate).\n\nsys is first converted to a state space model if needed.\n\nThe continuous-time L∞ norm computation implements the 'two-step algorithm' in:\nN.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H∞-norm of a transfer function matrix', Systems and Control Letters (1990), pp. 287-293.\n\nFor the discrete-time version, see:\nP. Bongers, O. Bosgra, M. Steinbuch, 'L∞-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.\n\nSee also linfnorm.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.innovation_form-Union{Tuple{ST}, Tuple{ST,Any,Any}} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystems.innovation_form","text":"sysi = innovationform(sys, R1, R2) sysi = innovationform(sys; sysw=I, syse=I, R1=I, R2=I)\n\nTakes a system\n\nx' = Ax + Bu + w ~ R1\ny  = Cx + e ~ R2\n\nand returns the system\n\nx' = Ax + Kv\ny  = Cx + v\n\nwhere v is the innovation sequence.\n\nIf sysw (syse) is given, the covariance resulting in filtering noise with R1 (R2) through sysw (syse) is used as covariance.\n\nSee Stochastic Control, Chapter 4, Åström\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.linfnorm-Tuple{AbstractStateSpace}","page":"Analysis","title":"ControlSystems.linfnorm","text":"(Ninf, ω_peak) = linfnorm(sys; tol=1e-6)\n\nCompute the L∞ norm Ninf of the LTI system sys, together with a frequency ω_peak at which the gain Ninf is achieved.\n\nNinf := sup_ω σ_max[sys(iω)] (σ_max denotes the largest singular value)\n\ntol is an optional keyword argument representing the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).\n\nsys is first converted to a state space model if needed.\n\nThe continuous-time L∞ norm computation implements the 'two-step algorithm' in:\nN.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H∞-norm of a transfer function matrix', Systems and Control Letters (1990), pp. 287-293.\n\nFor the discrete-time version, see:\nP. Bongers, O. Bosgra, M. Steinbuch, 'L∞-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.\n\nSee also hinfnorm.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.obsv-Tuple{AbstractArray{T,2} where T,AbstractArray{T,2} where T}","page":"Analysis","title":"ControlSystems.obsv","text":"obsv(A, C) or obsv(sys)\n\nCompute the observability matrix for the system described by (A, C) or sys.\n\nNote that checking for observability by computing the rank from obsv is not the most numerically accurate way, a better method is checking if gram(sys, :o) is positive definite.\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#ControlSystems.similarity_transform-Union{Tuple{ST}, Tuple{ST,Any}} where ST<:AbstractStateSpace","page":"Analysis","title":"ControlSystems.similarity_transform","text":"syst = similarity_transform(sys, T)\n\nPerform a similarity transform T : Tx̃ = x on sys such that\n\nÃ = T⁻¹AT\nB̃ = T⁻¹ B\nC̃ = CT\nD̃ = D\n\n\n\n\n\n","category":"method"},{"location":"lib/analysis/#LinearAlgebra.norm","page":"Analysis","title":"LinearAlgebra.norm","text":"..  norm(sys, p=2; tol=1e-6)\n\nnorm(sys) or norm(sys,2) computes the H2 norm of the LTI system sys.\n\nnorm(sys, Inf) computes the H∞ norm of the LTI system sys. The H∞ norm is the same as the H∞ for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function hinfnorm instead. See hinfnorm for further documentation.\n\ntol is an optional keyword argument, used only for the computation of L∞ norms. It represents the desired relative accuracy for the computed L∞ norm (this is not an absolute certificate however).\n\nsys is first converted to a StateSpace model if needed.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/","page":"Synthesis","title":"Synthesis","text":"Pages = [\"synthesis.md\"]","category":"page"},{"location":"lib/synthesis/#Synthesis","page":"Synthesis","title":"Synthesis","text":"","category":"section"},{"location":"lib/synthesis/","page":"Synthesis","title":"Synthesis","text":"Modules = [ControlSystems]\nPages   = [\"synthesis.jl\", \"discrete.jl\", \"pid_design.jl\", \"simplification.jl\", \"connections.jl\", \"utilities.jl\"]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/synthesis/#ControlSystems.dkalman-NTuple{4,Any}","page":"Synthesis","title":"ControlSystems.dkalman","text":"dkalman(A, C, R1, R2) kalman(sys, R1, R2)`\n\nCalculate the optimal Kalman gain for discrete time systems\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.dlqr-NTuple{4,Any}","page":"Synthesis","title":"ControlSystems.dlqr","text":"dlqr(A, B, Q, R), dlqr(sys, Q, R)\n\nCalculate the optimal gain matrix K for the state-feedback law u[k] = K*x[k] that minimizes the cost function:\n\nJ = sum(x'Qx + u'Ru, 0, inf).\n\nFor the discrte time model x[k+1] = Ax[k] + Bu[k].\n\nSee also lqg\n\nUsage example:\n\nusing LinearAlgebra # For identity matrix I\nh = 0.1\nA = [1 h; 0 1]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0, h)\nQ = I\nR = I\nL = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(x,t) = -L*x # Form control law,\nt=0:h:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x, lab=[\"Position\"  \"Velocity\"], xlabel=\"Time [s]\")\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.kalman-NTuple{4,Any}","page":"Synthesis","title":"ControlSystems.kalman","text":"kalman(A, C, R1, R2) kalman(sys, R1, R2)`\n\nCalculate the optimal Kalman gain\n\nSee also LQG\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.lqr-NTuple{4,Any}","page":"Synthesis","title":"ControlSystems.lqr","text":"lqr(A, B, Q, R)\n\nCalculate the optimal gain matrix K for the state-feedback law u = K*x that minimizes the cost function:\n\nJ = integral(x'Qx + u'Ru, 0, inf).\n\nFor the continuous time model dx = Ax + Bu.\n\nlqr(sys, Q, R)\n\nSolve the LQR problem for state-space system sys. Works for both discrete and continuous time systems.\n\nSee also LQG\n\nUsage example:\n\nusing LinearAlgebra # For identity matrix I\nA = [0 1; 0 0]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = I\nR = I\nL = lqr(sys,Q,R)\n\nu(x,t) = -L*x # Form control law,\nt=0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x, lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.place-Tuple{Any,Any,Any}","page":"Synthesis","title":"ControlSystems.place","text":"place(A, B, p), place(sys::StateSpace, p)\n\nCalculate gain matrix K such that the poles of (A-BK) in are in p.\n\nUses Ackermann's formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.c2d","page":"Synthesis","title":"ControlSystems.c2d","text":"[sysd, x0map] = c2d(sys, Ts, method=:zoh)\n\nConvert the continuous system sys into a discrete system with sample time Ts, using the provided method. Currently only :zoh and :foh are provided.\n\nReturns the discrete system sysd, and a matrix x0map that transforms the initial conditions to the discrete domain by x0_discrete = x0map*[x0; u0]\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystems.c2d_poly2poly-Tuple{Any,Any}","page":"Synthesis","title":"ControlSystems.c2d_poly2poly","text":"c2d_poly2poly(ro,h)\n\nreturns the polynomial coefficients in discrete time given polynomial coefficients in continuous time\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.c2d_roots2poly-Tuple{Any,Any}","page":"Synthesis","title":"ControlSystems.c2d_roots2poly","text":"c2d_roots2poly(ro,h)\n\nreturns the polynomial coefficients in discrete time given a vector of roots in continuous time\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.dab-Tuple{Any,Any,Any}","page":"Synthesis","title":"ControlSystems.dab","text":"DAB   Solves the Diophantine-Aryabhatta-Bezout identity\n\nX,Y = DAB(A,B,C)\n\nAX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.rstc-Tuple","page":"Synthesis","title":"ControlSystems.rstc","text":"See ?rstd for the discerte case\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.rstd-Tuple","page":"Synthesis","title":"ControlSystems.rstd","text":"rstd  Polynomial synthesis in discrete time.\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)\n\nPolynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)\n\nInputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]\n\nOutputs: R,S,T  : Polynomials in controller\n\nSee function DAB how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.zpconv-NTuple{4,Any}","page":"Synthesis","title":"ControlSystems.zpconv","text":"zpc(a,r,b,s) form conv(a,r) + conv(b,s) where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.laglink-Tuple{Any,Any}","page":"Synthesis","title":"ControlSystems.laglink","text":"laglink(a, M; h=0)\n\nReturns a phase retarding link, the rule of thumb a = 0.1ωc guarantees less than 6 degrees phase margin loss. The bode curve will go from M, bend down at a/M and level out at 1 for frequencies > a\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.leadlink-Tuple{Any,Any,Any}","page":"Synthesis","title":"ControlSystems.leadlink","text":"leadlink(b, N, K; h=0)\n\nReturns a phase advancing link, the top of the phase curve is located at ω = b√(N) where the link amplification is K√(N) The bode curve will go from K, bend up at b and level out at KN for frequencies > bN\n\nThe phase advance at ω = b√(N) can be plotted as a function of N with leadlinkcurve()\n\nValues of N < 1 will give a phase retarding link.\n\nSee also leadlinkat laglink\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.leadlinkat-Tuple{Any,Any,Any}","page":"Synthesis","title":"ControlSystems.leadlinkat","text":"leadlinkat(ω, N, K; h=0)\n\nReturns a phase advancing link, the top of the phase curve is located at ω where the link amplification is K√(N) The bode curve will go from K, bend up at ω/√(N) and level out at KN for frequencies > ω√(N)\n\nThe phase advance at ω can be plotted as a function of N with leadlinkcurve()\n\nValues of N < 1 will give a phase retarding link.\n\nSee also leadlink laglink\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.leadlinkcurve","page":"Synthesis","title":"ControlSystems.leadlinkcurve","text":"Plot the phase advance as a function of N for a lead link (phase advance link)\n\nIf an input argument s is given, the curve is plotted from s to 10, else from 1 to 10.\n\nSee also Leadlink, leadlinkat\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystems.loopshapingPI-Tuple{Any,Any}","page":"Synthesis","title":"ControlSystems.loopshapingPI","text":"kp,ki,C = loopshapingPI(P,ωp; ϕl,rl, phasemargin, doplot = false)\n\nSelects the parameters of a PI-controller such that the Nyquist curve of P at the frequency ωp is moved to rl exp(i ϕl)\n\nIf phasemargin is supplied, ϕl is selected such that the curve is moved to an angle of phasemargin - 180 degrees\n\nIf no rl is given, the magnitude of the curve at ωp is kept the same and only the phase is affected, the same goes for ϕl if no phasemargin is given.\n\nSet doplot = true to plot the gangoffourplot and nyquistplot of the system.\n\nSee also pidplots, stabregionPID\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.pid-Tuple{}","page":"Synthesis","title":"ControlSystems.pid","text":"Calculates and returns a PID controller on transfer function form. time indicates whether or not the parameters are given as gains (default) or as time constants series indicates  whether or not the series form or parallel form (default) is desired\n\nC = pid(; kp=0, ki=0; kd=0, time=false, series=false)\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.pidplots-Tuple{LTISystem,Vararg{Any,N} where N}","page":"Synthesis","title":"ControlSystems.pidplots","text":"Plots interesting figures related to closing the loop around process P with a PID controller Send in a bunch of PID-parameters in any of the vectors kp, ki, kd. The vectors must be the same length.\n\ntime indicates whether or not the parameters are given as gains (default) or as time constants\n\nseries indicates  whether or not the series form or parallel form (default) is desired\n\nAvailable plots are :gof for Gang of four, :nyquist, :controller for a bode plot of the controller TF and :pz for pole-zero maps\n\nOne can also supply a frequency vector ω to be used in Bode and Nyquist plots\n\npidplots(P, args...; kps=0, kis=0, kds=0, time=false, series=false, ω=0)\n\nSee also loopshapingPI, stabregionPID\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.rlocus","page":"Synthesis","title":"ControlSystems.rlocus","text":"rlocusplot(P::LTISystem, K)\n\nComputes and plots the root locus of the SISO LTISystem P with a negative feedback loop and feedback gains K, if K is not provided, range(1e-6,stop=500,length=10000) is used. If OrdinaryDiffEq.jl is installed and loaded by the user (using OrdinaryDiffEq), rlocusplot will use an adaptive step-size algorithm to select values of K. A scalar Kmax can then be given as second argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystems.stabregionPID","page":"Synthesis","title":"ControlSystems.stabregionPID","text":"fig, kp, ki = stabregionPID(P, [ω]; kd=0, doplot = true)\n\nSegments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s\n\nThe curve is found by analyzing P(s)*C(s) = -1 ⟹ |PC| = |P| |C| = 1 arg(P) + arg(C) = -π\n\nIf P is a function (e.g. s -> exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions\n\nSee also stabregionPID, loopshapingPI, pidplots\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystems.sminreal-Tuple{StateSpace}","page":"Synthesis","title":"ControlSystems.sminreal","text":"sminreal(sys)\n\nCompute the structurally minimal realization of the state-space system sys. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in sys are removed.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.append-Tuple{Vararg{AbstractStateSpace,N} where N}","page":"Synthesis","title":"ControlSystems.append","text":"append(systems::StateSpace...), append(systems::TransferFunction...)\n\nAppend systems in block diagonal form\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.feedback-Tuple{AbstractStateSpace,AbstractStateSpace}","page":"Synthesis","title":"ControlSystems.feedback","text":"feedback(s1::AbstractStateSpace, s2::AbstractStateSpace;\n         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],\n         Wperm=:, Zperm=:, pos_feedback::Bool=false)\n\nU1, Y1, U2, Y2 contain the indices of the signals that should be connected. W1, Z1, W2, Z2 contain the signal indices of s1 and s2 that should be kept.\n\nSpecify  Wperm and Zperm to reorder [w1; w2] and [z1; z2] in the resulting statespace model.\n\nNegative feedback is the default. Specify pos_feedback=true for positive feedback.\n\nSee Zhou etc. for similar (somewhat less symmetric) formulas.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.feedback-Tuple{TransferFunction}","page":"Synthesis","title":"ControlSystems.feedback","text":"feedback(L) Returns L/(1+L) feedback(P1,P2) Returns P1/(1+P1*P2)\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.feedback-Tuple{Union{DelayLtiSystem, StateSpace}}","page":"Synthesis","title":"ControlSystems.feedback","text":"feedback(sys)\n\nfeedback(sys1,sys2)\n\nForms the negative feedback interconnection\n\n>-+ sys1 +-->\n  |      |\n (-)sys2 +\n\nIf no second system is given, negative identity feedback is assumed\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.feedback2dof-Tuple{TransferFunction,Any,Any,Any}","page":"Synthesis","title":"ControlSystems.feedback2dof","text":"feedback2dof(P,R,S,T) Return BT/(AR+ST) where B and A are the numerator and denomenator polynomials of P respectively feedback2dof(B,A,R,S,T) Return BT/(AR+ST)\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.lft","page":"Synthesis","title":"ControlSystems.lft","text":"lft(G, Δ, type=:l)\n\nLower and upper linear fractional transformation between systems G and Δ.\n\nSpecify :l lor lower LFT, and :u for upper LFT.\n\nG must have more inputs and outputs than Δ has outputs and inputs.\n\nFor details, see Chapter 9.1 in Zhou, K. and JC Doyle. Essentials of robust control, Prentice hall (NJ), 1998\n\n\n\n\n\n","category":"function"},{"location":"lib/synthesis/#ControlSystems.parallel-Tuple{LTISystem,LTISystem}","page":"Synthesis","title":"ControlSystems.parallel","text":"parallel(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in parallel, equivalent to sys2+sys1\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.series-Tuple{LTISystem,LTISystem}","page":"Synthesis","title":"ControlSystems.series","text":"series(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in series, equivalent to sys2*sys1\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.starprod-Tuple{Any,Any,Int64,Int64}","page":"Synthesis","title":"ControlSystems.starprod","text":"starprod(sys1, sys2, dimu, dimy)\n\nCompute the Redheffer star product.\n\nlength(U1) = length(Y2) = dimu and length(Y1) = length(U2) = dimy\n\nFor details, see Chapter 9.3 in Zhou, K. and JC Doyle. Essentials of robust control, Prentice hall (NJ), 1998\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.bodev-Tuple{LTISystem,AbstractArray{T,1} where T}","page":"Synthesis","title":"ControlSystems.bodev","text":"bodev(sys::LTISystem, w::AbstractVector; ) \n\nFor use with SISO systems where it acts the same as bode  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.bodev-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystems.bodev","text":"bodev(sys::LTISystem; ) \n\nFor use with SISO systems where it acts the same as bode  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.nyquistv-Tuple{LTISystem,AbstractArray{T,1} where T}","page":"Synthesis","title":"ControlSystems.nyquistv","text":"nyquistv(sys::LTISystem, w::AbstractVector; ) \n\nFor use with SISO systems where it acts the same as nyquist  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.nyquistv-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystems.nyquistv","text":"nyquistv(sys::LTISystem; ) \n\nFor use with SISO systems where it acts the same as nyquist  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.sigmav-Tuple{LTISystem,AbstractArray{T,1} where T}","page":"Synthesis","title":"ControlSystems.sigmav","text":"sigmav(sys::LTISystem, w::AbstractVector; ) \n\nFor use with SISO systems where it acts the same as sigma  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/synthesis/#ControlSystems.sigmav-Tuple{LTISystem}","page":"Synthesis","title":"ControlSystems.sigmav","text":"sigmav(sys::LTISystem; ) \n\nFor use with SISO systems where it acts the same as sigma  but with the extra dimensions removed in the returned values.\n\n\n\n\n\n","category":"method"},{"location":"man/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/introduction/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"To install this package simply run","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"ControlSystems\")","category":"page"},{"location":"man/introduction/#Basic-functions","page":"Introduction","title":"Basic functions","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using ControlSystems\n    P = tf([1],[1,1])\n    T = P/(1+P)\n    plotsDir = joinpath(dirname(pathof(ControlSystems)), \"..\", \"docs\", \"build\", \"plots\")\n    mkpath(plotsDir)\n    save_docs_plot(name) = Plots.savefig(joinpath(plotsDir,name))\n    save_docs_plot(p, name) = Plots.savefig(p, joinpath(plotsDir,name))\nend","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Transfer functions can easily be created using the function tf(num, den, Ts=0), where num and den are vectors representing the numerator and denominator of a rational function. See tf or the section \"Creating Transfer Functions\" for more info. These functions can then be connected and modified using the operators +,-,*,/ and functions like append.","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Example:","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"P = tf([1.0],[1,1])\nT = P/(1+P)\n\n# output\n\nTransferFunction{Continuous,ControlSystems.SisoRational{Float64}}\n     1.0*s + 1.0\n---------------------\n1.0*s^2 + 3.0*s + 2.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Notice that the poles are not canceled automatically, to do this, the function minreal is available","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"minreal(T)\n\n# output\n\nTransferFunction{Continuous,ControlSystems.SisoRational{Float64}}\n    1.0\n-----------\n1.0*s + 2.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/introduction/#Plotting","page":"Introduction","title":"Plotting","text":"","category":"section"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"Plotting requires some extra care. The ControlSystems package is using Plots.jl (link) as interface to generate all the plots. This means that the user is able to freely choose back-end. The plots in this manual are generated using PyPlot. If you have several back-ends for plotting then you can select the one you want to use with the corresponding Plots call (for PyPlot this is Plots.pyplot(), some alternatives are gr(), plotly(), pgfplots()). A simple example where we generate a plot and save it to a file is","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"fig = bodeplot(tf(1,[1,2,1]))\n\nPlots.savefig(fig, \"myfile.svg\")","category":"page"},{"location":"man/introduction/","page":"Introduction","title":"Introduction","text":"(Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"DocTestSetup = quote\n    using ControlSystems\n    plotsDir = joinpath(dirname(pathof(ControlSystems)), \"..\", \"docs\", \"build\", \"plots\")\n    mkpath(plotsDir)\n    save_docs_plot(name) = Plots.savefig(joinpath(plotsDir,name))\n    save_docs_plot(p, name) = Plots.savefig(p, joinpath(plotsDir,name))\nend","category":"page"},{"location":"examples/example/#LQR-design","page":"Design","title":"LQR design","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"using LinearAlgebra # For identity matrix I\nh       = 0.1\nA       = [1 h; 0 1]\nB       = [0 1]' # To handle bug TODO\nC       = [1 0]\nsys     = ss(A,B,C,0, h)\nQ       = I\nR       = I\nL       = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(x,t)  = -L*x .+ 1.5(t>=2.5)# Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t≧2.5\nt       =0:h:5\nx0      = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nPlots.plot(t,x, lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: )","category":"page"},{"location":"examples/example/#PID-design-functions","page":"Design","title":"PID design functions","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"By plotting the gang of four under unit feedback for the process","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"P = tf(1,[1,1])^4\ngangoffourplot(P,tf(1))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"we notice that the sensitivity function is a bit too high around frequencies ω = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function loopshapingPI and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"ωp = 0.8\nkp,ki,C = loopshapingPI(P,ωp,phasemargin=60)\n\np1 = gangoffourplot(P, [tf(1), C]);\np2 = nyquistplot([P, P*C], ylims=(-1,1), xlims=(-1.5,1.5));\n\nPlots.plot(p1,p2, layout=(2,1), size=(800,800))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"We could also cosider a situation where we want to create a closed-loop system with the bandwidth ω = 2 rad/s, in which case we would write something like","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"ωp = 2\nkp,ki,C60 = loopshapingPI(P,ωp,rl=1,phasemargin=60, doplot=true)\n\np1 = gangoffourplot(P, [tf(1), C60]);\np2 = nyquistplot([P, P*C60], ylims=(-2,2), xlims=(-3,3));\n\nPlots.plot(p1,p2, layout=(2,1), size=(800,800))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Here we specify that we want the Nyquist curve L(iω) = P(iω)C(iω) to pass the point |L(iω)| = rl = 1,  arg(L(iω)) = -180 + phasemargin = -180 + 60 The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles. (Image: )","category":"page"},{"location":"examples/example/#Advanced-pole-zero-placement","page":"Design","title":"Advanced pole-zero placement","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"This example illustrates how we can perform advanced pole-zero placement. The task is to make the process a bit faster and damp the poorly damped poles.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Define the process","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"ζ = 0.2\nω = 1\n\nB = [1]\nA   = [1, 2ζ*ω, ω^2]\nP  = tf(B,A)","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Define the desired closed loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"import DSP: conv\n# Control design\nζ0 = 0.7\nω0 = 2\nAm = [1, 2ζ0*ω0, ω0^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB⁺  = [1] # The process numerator polynomial can be facored as B = B⁺B⁻ where B⁻ contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB⁻  = [1]\nBm  = conv(B⁺, B⁻) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B⁺,B⁻,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nstepplot([P,Gcl]) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/example/#Stability-boundary-for-PID-controllers","page":"Design","title":"Stability boundary for PID controllers","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"The stability boundary, where the transfer function P(s)C(s) = -1, can be plotted with the command stabregionPID. The process can be given in string form or as a regular LTIsystem.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"P1 = s -> exp(-sqrt(s))\nf1, kp, ki = stabregionPID(P1,exp10.(range(-5, stop=1, length=1000))); f1\nP2 = s -> 100*(s+6).^2. /(s.*(s+1).^2. *(s+50).^2)\nf2, kp, ki = stabregionPID(P2,exp10.(range(-5, stop=2, length=1000))); f2\nP3 = tf(1,[1,1])^4\nf3, kp, ki = stabregionPID(P3,exp10.(range(-5, stop=0, length=1000))); f3","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/example/#PID-plots","page":"Design","title":"PID plots","text":"","category":"section"},{"location":"examples/example/","page":"Design","title":"Design","text":"This example utilizes the function pidplots, which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"P = tf([1.],[1., 1])\n\nζ = 0.5 # Desired damping\n\nws = exp10.(range(-1, stop=2, length=8)) # A vector of closed-loop bandwidths\nkp = 2*ζ*ws .- 1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\n\nω = exp10.(range(-3, stop = 2, length = 500))\npidplots(\n    P,\n    :nyquist;\n    kps = kp,\n    kis = ki,\n    ω = ω,\n    ylims = (-2, 2),\n    xlims = (-3, 3),\n)\npidplots(P, :gof; kps = kp, kis = ki, ω = ω, legend = false)\n# You can also request both Nyquist and Gang-of-four plots (more plots are available, see ?pidplots ):\n# pidplots(P,:nyquist,:gof;kps=kp,kis=ki,ω=ω);","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"Now try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"kp = range(-1, stop=1, length=8) #\nki = sqrt.(1 .- kp.^2)/10\n\npidplots(P,:nyquist,;kps=kp,kis=ki,ylims=(-1,1),xlims=(-1.5,1.5))\npidplots(P,:gof,;kps=kp,kis=ki,legend=false,ylims=(0.08,8),xlims=(0.003,20))","category":"page"},{"location":"examples/example/","page":"Design","title":"Design","text":"(Image: ) (Image: )","category":"page"},{"location":"man/creating_systems/#Creating-Transfer-Functions","page":"Creating Systems","title":"Creating Transfer Functions","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"DocTestSetup = quote\n    using ControlSystems\nend","category":"page"},{"location":"man/creating_systems/#tf-Rational-Representation","page":"Creating Systems","title":"tf - Rational Representation","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The syntax for creating a transfer function is","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf(num, den, Ts=0)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"where num and den are the polynomial coefficients of the numerator and denominator of the polynomial and Ts is the sample time.","category":"page"},{"location":"man/creating_systems/#Example:","page":"Creating Systems","title":"Example:","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf([1.0],[1,2,1])\n\n# output\n\nTransferFunction{Continuous,ControlSystems.SisoRational{Float64}}\n         1.0\n---------------------\n1.0*s^2 + 2.0*s + 1.0\n\nContinuous-time transfer function model","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The transfer functions created using this method will be of type TransferFunction{SisoRational}.","category":"page"},{"location":"man/creating_systems/#zpk-Pole-Zero-Gain-Representation","page":"Creating Systems","title":"zpk - Pole-Zero-Gain Representation","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Sometimes it's better to represent the transfer function by its poles, zeros and gain, this can be done using","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"zpk(zeros, poles, gain, Ts=0)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"where zeros and poles are Vectors of the zeros and poles for the system and gain is a gain coefficient.","category":"page"},{"location":"man/creating_systems/#Example","page":"Creating Systems","title":"Example","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"zpk([-1.0,1], [-5, -10], 2)\n\n# output\n\nTransferFunction{Continuous,ControlSystems.SisoZpk{Float64,Float64}}\n   (1.0*s + 1.0)(1.0*s - 1.0)\n2.0---------------------------\n   (1.0*s + 5.0)(1.0*s + 10.0)\n\nContinuous-time transfer function model","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"The transfer functions created using this method will be of type TransferFunction{SisoZpk}.","category":"page"},{"location":"man/creating_systems/#Converting-between-types","page":"Creating Systems","title":"Converting between types","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"It is sometime useful to convert one representation to another, this is possible using the same functions, for example","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"tf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction{Discrete{Float64},ControlSystems.SisoRational{Int64}}\n2*z + 2\n-------\n z - 1\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model","category":"page"},{"location":"man/creating_systems/#Creating-State-Space-Systems","page":"Creating Systems","title":"Creating State-Space Systems","text":"","category":"section"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"A state-space system is created using","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"ss(A,B,C,D,Ts=0)","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"and they behave similarily to transfer functions. State-space systems with heterogeneous matrix types are also available, which can be used to create systems with static or sized matrices, e.g.,","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"using StaticArrays\nimport ControlSystems.HeteroStateSpace\n@inline to_static(a::Number) = a\n@inline to_static(a::AbstractArray) = SMatrix{size(a)...}(a)\n@inline to_sized(a::Number) = a\n@inline to_sized(a::AbstractArray) = SizedArray{Tuple{size(a)...}}(a)\nfunction HeteroStateSpace(A,B,C,D,Ts=0,f::F=to_static) where F\n    HeteroStateSpace(f(A),f(B),f(C),f(D),Ts)\nend\n@inline HeteroStateSpace(s,f) = HeteroStateSpace(s.A,s.B,s.C,s.D,s.timeevol,f)\nControlSystems._string_mat_with_headers(a::SizedArray) = ControlSystems._string_mat_with_headers(Matrix(a)); # Overload for printing purposes","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"Notice the different matrix types used","category":"page"},{"location":"man/creating_systems/","page":"Creating Systems","title":"Creating Systems","text":"julia> sys = ss([-5 0; 0 -5],[2; 2],[3 3],[0])\nStateSpace{Continuous,Int64,Array{Int64,2}}\nA =\n -5   0\n  0  -5\nB =\n 2\n 2\nC =\n 3  3\nD =\n 0\n\nContinuous-time state-space model\n\njulia> HeteroStateSpace(sys, to_static)\nHeteroStateSpace{Continuous,SArray{Tuple{2,2},Int64,2,4},SArray{Tuple{2,1},Int64,2,2},SArray{Tuple{1,2},Int64,2,2},SArray{Tuple{1,1},Int64,2,1}}\nA =\n -5   0\n  0  -5\nB =\n 2\n 2\nC =\n 3  3\nD =\n 0\n\nContinuous-time state-space model\n\njulia> HeteroStateSpace(sys, to_sized)\nHeteroStateSpace{Continuous,SizedArray{Tuple{2,2},Int64,2,2},SizedArray{Tuple{2,1},Int64,2,2},SizedArray{Tuple{1,2},Int64,2,2},SizedArray{Tuple{1,1},Int64,2,2}}\nA =\n -5   0\n  0  -5\nB =\n 2\n 2\nC =\n 3  3\nD =\n 0\n\nContinuous-time state-space model","category":"page"},{"location":"lib/constructors/","page":"Constructors","title":"Constructors","text":"Pages = [\"constructors.md\"]","category":"page"},{"location":"lib/constructors/#Constructing-transfer-functions","page":"Constructors","title":"Constructing transfer functions","text":"","category":"section"},{"location":"lib/constructors/","page":"Constructors","title":"Constructors","text":"append\nc2d\nfeedback\nfeedback2dof\nminreal\nparallel\nseries\nsminreal\nss\ntf\nzpk","category":"page"},{"location":"lib/constructors/#ControlSystems.append","page":"Constructors","title":"ControlSystems.append","text":"append(systems::StateSpace...), append(systems::TransferFunction...)\n\nAppend systems in block diagonal form\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.c2d","page":"Constructors","title":"ControlSystems.c2d","text":"[sysd, x0map] = c2d(sys, Ts, method=:zoh)\n\nConvert the continuous system sys into a discrete system with sample time Ts, using the provided method. Currently only :zoh and :foh are provided.\n\nReturns the discrete system sysd, and a matrix x0map that transforms the initial conditions to the discrete domain by x0_discrete = x0map*[x0; u0]\n\n\n\n\n\nc2d(G::DelayLtiSystem, Ts, method=:zoh)\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.feedback","page":"Constructors","title":"ControlSystems.feedback","text":"feedback(L) Returns L/(1+L) feedback(P1,P2) Returns P1/(1+P1*P2)\n\n\n\n\n\nfeedback(sys)\n\nfeedback(sys1,sys2)\n\nForms the negative feedback interconnection\n\n>-+ sys1 +-->\n  |      |\n (-)sys2 +\n\nIf no second system is given, negative identity feedback is assumed\n\n\n\n\n\nfeedback(s1::AbstractStateSpace, s2::AbstractStateSpace;\n         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],\n         Wperm=:, Zperm=:, pos_feedback::Bool=false)\n\nU1, Y1, U2, Y2 contain the indices of the signals that should be connected. W1, Z1, W2, Z2 contain the signal indices of s1 and s2 that should be kept.\n\nSpecify  Wperm and Zperm to reorder [w1; w2] and [z1; z2] in the resulting statespace model.\n\nNegative feedback is the default. Specify pos_feedback=true for positive feedback.\n\nSee Zhou etc. for similar (somewhat less symmetric) formulas.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.feedback2dof","page":"Constructors","title":"ControlSystems.feedback2dof","text":"feedback2dof(P,R,S,T) Return BT/(AR+ST) where B and A are the numerator and denomenator polynomials of P respectively feedback2dof(B,A,R,S,T) Return BT/(AR+ST)\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.minreal","page":"Constructors","title":"ControlSystems.minreal","text":"tf = minreal(tf::TransferFunction, eps=sqrt(eps()))\n\nCreate a minimial representation of each transfer function in tf by cancelling poles and zeros will promote system to an appropriate numeric type\n\n\n\n\n\nminsys = minreal(s::StateSpace, tol=sqrt(eps())) is implemented via baltrunc and returns a system on diagonal form.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.parallel","page":"Constructors","title":"ControlSystems.parallel","text":"parallel(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in parallel, equivalent to sys2+sys1\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.series","page":"Constructors","title":"ControlSystems.series","text":"series(sys1::LTISystem, sys2::LTISystem)\n\nConnect systems in series, equivalent to sys2*sys1\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.sminreal","page":"Constructors","title":"ControlSystems.sminreal","text":"sminreal(sys)\n\nCompute the structurally minimal realization of the state-space system sys. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in sys are removed.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.ss","page":"Constructors","title":"ControlSystems.ss","text":"`sys = ss(A, B, C, D [,Ts])`\n\nCreate a state-space model sys::StateSpace{TE, T, MT<:AbstractMatrix{T}} where MT is the type of matrixes A,B,C,D, T the element type and TE is Continuous or Discrete.\n\nThis is a continuous-time model if Ts is omitted. Otherwise, this is a discrete-time model with sampling period Ts.\n\nsys = ss(D [, Ts]) specifies a static gain matrix D.\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.tf","page":"Constructors","title":"ControlSystems.tf","text":"sys = tf(num, den[, Ts]), sys = tf(gain[, Ts])\n\nCreate as a fraction of polynomials:\n\nsys::TransferFunction{SisoRational{T,TR}} = numerator/denominator where T is the type of the coefficients in the polynomial.\n\nnum: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.\n\nden: the coefficients of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.\n\nTs: Sample time if discrete time system.\n\nOther uses: tf(sys): Convert sys to tf form. tf(\"s\"), tf(\"z\"): Create the continuous transferfunction s.\n\nSee also: zpk, ss\n\n\n\n\n\n","category":"function"},{"location":"lib/constructors/#ControlSystems.zpk","page":"Constructors","title":"ControlSystems.zpk","text":"zpk(gain[, Ts]), zpk(num, den, k[, Ts]), zpk(sys)\n\nCreate transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.\n\nsys::TransferFunction{SisoZpk{T,TR}} = k*numerator/denominator where T is the type of k and TR the type of the zeros/poles, usually Float64 and Complex{Float64}.\n\nnum: the roots of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.\n\nden: the roots of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.\n\nk: The gain of the system. Obs, this is not the same as dcgain.\n\nTs: Sample time if discrete time system.\n\nOther uses:\n\nzpk(sys): Convert sys to zpk form.\n\nzpk(\"s\"): Create the transferfunction s.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"Pages = [\"plotting.md\"]","category":"page"},{"location":"lib/plotting/#Plotting-functions","page":"Plotting","title":"Plotting functions","text":"","category":"section"},{"location":"lib/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ControlSystems]\nPages   = [\"plotting.jl\"]\nOrder   = [:function]\nPrivate = false","category":"page"},{"location":"lib/plotting/#ControlSystems.bodeplot","page":"Plotting","title":"ControlSystems.bodeplot","text":"fig = bodeplot(sys, args...), bodeplot(LTISystem[sys1, sys2...], args...; plotphase=true, kwargs...)\n\nCreate a Bode plot of the LTISystem(s). A frequency vector w can be optionally provided. To change the Magnitude scale see setPlotScale(str)\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.gangoffourplot-Tuple{Union{LTISystem, Array{T,1} where T},Array{T,1} where T,Vararg{Any,N} where N}","page":"Plotting","title":"ControlSystems.gangoffourplot","text":"fig = gangoffourplot(P::LTISystem, C::LTISystem), gangoffourplot(P::Union{Vector, LTISystem}, C::Vector; plotphase=false)\n\nGang-of-Four plot.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/plotting/#ControlSystems.impulseplot","page":"Plotting","title":"ControlSystems.impulseplot","text":"impulseplot(sys[, tfinal[,  dt]])\n\nPlot step response of sys with optional final time tfinal and discretization time dt. If not defined, suitable values are chosen based on sys.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.lsimplot","page":"Plotting","title":"ControlSystems.lsimplot","text":"fig = lsimplot(sys::LTISystem, u, t; x0=0, method)\n\nlsimplot(LTISystem[sys1, sys2...], u, t; x0, method)\n\nCalculate the time response of the LTISystem(s) to input u. If x0 is not specified, a zero vector is used.\n\nContinuous time systems are discretized before simulation. By default, the method is chosen based on the smoothness of the input signal. Optionally, the method parameter can be specified as either :zoh or :foh.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.marginplot-Union{Tuple{T}, Tuple{Union{AbstractArray{T,1}, T},Vararg{Any,N} where N}} where T<:LTISystem","page":"Plotting","title":"ControlSystems.marginplot","text":"fig = marginplot(sys::LTISystem [,w::AbstractVector];  kwargs...), marginplot(sys::Vector{LTISystem}, w::AbstractVector;  kwargs...)\n\nPlot all the amplitude and phase margins of the system(s) sys. A frequency vector w can be optionally provided.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"method"},{"location":"lib/plotting/#ControlSystems.nicholsplot","page":"Plotting","title":"ControlSystems.nicholsplot","text":"fig = nicholsplot{T<:LTISystem}(systems::Vector{T}, w::AbstractVector; kwargs...)\n\nCreate a Nichols plot of the LTISystem(s). A frequency vector w can be optionally provided.\n\nKeyword arguments:\n\ntext = true\nGains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]\npInc = 30\nsat = 0.4\nval = 0.85\nfontsize = 10\n\npInc determines the increment in degrees between phase lines.\n\nsat ∈ [0,1] determines the saturation of the gain lines\n\nval ∈ [0,1] determines the brightness of the gain lines\n\nAdditional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular Plots.jl syntax\n\nThis function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.nyquistplot","page":"Plotting","title":"ControlSystems.nyquistplot","text":"fig = nyquistplot(sys; gaincircles=true, kwargs...), nyquistplot(LTISystem[sys1, sys2...]; gaincircles=true, kwargs...)\n\nCreate a Nyquist plot of the LTISystem(s). A frequency vector w can be optionally provided.\n\ngaincircles plots the circles corresponding to |S(iω)| = 1 and |T(iω)| = 1, where S and T are the sensitivity and complementary sensitivity functions.\n\nkwargs is sent as argument to plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.pzmap","page":"Plotting","title":"ControlSystems.pzmap","text":"fig = pzmap(fig, system, args...; kwargs...)\n\nCreate a pole-zero map of the LTISystem(s) in figure fig, args and kwargs will be sent to the scatter plot command.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.setPlotScale-Tuple{AbstractString}","page":"Plotting","title":"ControlSystems.setPlotScale","text":"setPlotScale(str)\n\nSet the default scale of magnitude in bodeplot and sigmaplot. str should be either \"dB\" or \"log10\".\n\n\n\n\n\n","category":"method"},{"location":"lib/plotting/#ControlSystems.sigmaplot","page":"Plotting","title":"ControlSystems.sigmaplot","text":"sigmaplot(sys, args...), sigmaplot(LTISystem[sys1, sys2...], args...)\n\nPlot the singular values of the frequency response of the LTISystem(s). A frequency vector w can be optionally provided.\n\nkwargs is sent as argument to Plots.plot.\n\n\n\n\n\n","category":"function"},{"location":"lib/plotting/#ControlSystems.stepplot","page":"Plotting","title":"ControlSystems.stepplot","text":"stepplot(sys[, tfinal[,  dt]])\n\nPlot step response of sys with optional final time tfinal and discretization time dt. If not defined, suitable values are chosen based on sys.\n\n\n\n\n\n","category":"function"},{"location":"#ControlSystems.jl-Manual","page":"Home","title":"ControlSystems.jl Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ControlSystems","category":"page"},{"location":"#Guide","page":"Home","title":"Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/introduction.md\", \"man/creating_systems.md\"]\nDepth = 1","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"examples/example.md\"]\nDepth = 2","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/constructors.md\",  \"lib/analysis.md\", \"lib/syntheis.md\", \"lib/timefreqresponse.md\", \"lib/plotting.md\"]\nDepth = 1","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Pages = [\"timefreqresponse.md\"]","category":"page"},{"location":"lib/timefreqresponse/#Time-and-Frequency-response","page":"Time and Frequency response","title":"Time and Frequency response","text":"","category":"section"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Any TransferFunction can be evaluated at a point using F(s), F(omega, true), F(z, false)","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"F(s) evaluates the continuous-time transfer function F at s.\nF(omega,true) evaluates the discrete-time transfer function F at exp(i*Ts*omega)\nF(z,false) evaluates the discrete-time transfer function F at z","category":"page"},{"location":"lib/timefreqresponse/","page":"Time and Frequency response","title":"Time and Frequency response","text":"Modules = [ControlSystems]\nPages   = [\"timeresp.jl\", \"freqresp.jl\", \"simulators.jl\"]\nOrder   = [:function, :type]\nPrivate = false","category":"page"},{"location":"lib/timefreqresponse/#Base.step-Tuple{AbstractStateSpace,AbstractArray{T,1} where T}","page":"Time and Frequency response","title":"Base.step","text":"y, t, x = step(sys[, Tf]) or y, t, x = step(sys[, t])\n\nCalculate the step response of system sys. If the final time Tf or time vector t is not provided, one is calculated based on the system pole locations.\n\ny has size (length(t), ny, nu), x has size (length(t), nx, nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystems.impulse-Tuple{AbstractStateSpace,AbstractArray{T,1} where T}","page":"Time and Frequency response","title":"ControlSystems.impulse","text":"y, t, x = impulse(sys[, Tf]) or y, t, x = impulse(sys[, t])\n\nCalculate the impulse response of system sys. If the final time Tf or time vector t is not provided, one is calculated based on the system pole locations.\n\ny has size (length(t), ny, nu), x has size (length(t), nx, nu)\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystems.lsim-Tuple{AbstractStateSpace,Union{AbstractArray{T,1}, AbstractArray{T,2}} where T,AbstractArray{T,1} where T}","page":"Time and Frequency response","title":"ControlSystems.lsim","text":"y, t, x = lsim(sys, u[, t]; x0, method])\n\ny, t, x, uout = lsim(sys, u::Function, t; x0, method)\n\nCalculate the time response of system sys to input u. If x0 is ommitted, a zero vector is used.\n\ny, x, uout has time in the first dimension. Initial state x0 defaults to zero.\n\nContinuous time systems are simulated using an ODE solver if u is a function. If u is an array, the system is discretized before simulation. For a lower level inteface, see ?Simulator and ?solve\n\nu can be a function or a matrix/vector of precalculated control signals. If u is a function, then u(x,i) (u(x,t)) is called to calculate the control signal every iteration (time instance used by solver). This can be used to provide a control law such as state feedback u(x,t) = -L*x calculated by lqr. To simulate a unit step, use (x,i)-> 1, for a ramp, use (x,i)-> i*h, for a step at t=5, use (x,i)-> (i*h >= 5) etc.\n\nUsage example:\n\nusing LinearAlgebra # For identity matrix I\nusing Plots\n\nA = [0 1; 0 0]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = I\nR = I\nL = lqr(sys,Q,R)\n\nu(x,t) = -L*x # Form control law,\nt=0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0=x0)\nplot(t,x, lab=[\"Position\" \"Velocity\"], xlabel=\"Time [s]\")\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystems.bode","page":"Time and Frequency response","title":"ControlSystems.bode","text":"mag, phase, w = bode(sys[, w])\n\nCompute the magnitude and phase parts of the frequency response of system sys at frequencies w\n\nmag and phase has size (length(w), ny, nu)\n\n\n\n\n\n","category":"function"},{"location":"lib/timefreqresponse/#ControlSystems.evalfr-Tuple{AbstractStateSpace,Number}","page":"Time and Frequency response","title":"ControlSystems.evalfr","text":"evalfr(sys, x) Evaluate the transfer function of the LTI system sys at the complex number s=x (continuous-time) or z=x (discrete-time).\n\nFor many values of x, use freqresp instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystems.freqresp-Tuple{LTISystem,AbstractArray{var\"#s159\",1} where var\"#s159\"<:Real}","page":"Time and Frequency response","title":"ControlSystems.freqresp","text":"sys_fr = freqresp(sys, w)\n\nEvaluate the frequency response of a linear system\n\nw -> C*((iw*im -A)^-1)*B + D\n\nof system sys over the frequency vector w.\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#ControlSystems.nyquist","page":"Time and Frequency response","title":"ControlSystems.nyquist","text":"re, im, w = nyquist(sys[, w])\n\nCompute the real and imaginary parts of the frequency response of system sys at frequencies w\n\nre and im has size (length(w), ny, nu)\n\n\n\n\n\n","category":"function"},{"location":"lib/timefreqresponse/#ControlSystems.sigma","page":"Time and Frequency response","title":"ControlSystems.sigma","text":"sv, w = sigma(sys[, w])\n\nCompute the singular values of the frequency response of system sys at frequencies w\n\nsv has size (length(w), max(ny, nu))\n\n\n\n\n\n","category":"function"},{"location":"lib/timefreqresponse/#ControlSystems.TransferFunction-Tuple{Any}","page":"Time and Frequency response","title":"ControlSystems.TransferFunction","text":"F(s), F(omega, true), F(z, false)\n\nNotation for frequency response evaluation.\n\nF(s) evaluates the continuous-time transfer function F at s.\nF(omega,true) evaluates the discrete-time transfer function F at exp(imTsomega)\nF(z,false) evaluates the discrete-time transfer function F at z\n\n\n\n\n\n","category":"method"},{"location":"lib/timefreqresponse/#DiffEqBase.solve","page":"Time and Frequency response","title":"DiffEqBase.solve","text":"sol = solve(s::AbstractSimulator, x0, tspan,  args...; kwargs...)\n\nSimulate the system represented by s from initial state x0 over time span tspan = (t0,tf). args and kwargs are sent to the solve function from OrdinaryDiffEq, e.g., solve(s, x0, tspan,  Tsit5(), reltol=1e-5) solves the problem with solver Tsit5() and relative tolerance 1e-5.\n\nSee also Simulator lsim\n\n\n\n\n\n","category":"function"},{"location":"lib/timefreqresponse/#ControlSystems.Simulator","page":"Time and Frequency response","title":"ControlSystems.Simulator","text":"Simulator\n\nFields:\n\nP::StateSpace\nf = (x,p,t) -> x\ny = (x,t)   -> y\n\n\n\n\n\n","category":"type"},{"location":"lib/timefreqresponse/#ControlSystems.Simulator-Union{Tuple{AbstractStateSpace}, Tuple{F}, Tuple{AbstractStateSpace,F}} where F","page":"Time and Frequency response","title":"ControlSystems.Simulator","text":"Simulator(P::StateSpace, u = (x,t) -> 0)\n\nUsed to simulate continuous-time systems. See function ?solve for additional info.\n\nUsage:\n\nusing OrdinaryDiffEq\nh              = 0.1\nTf             = 20\nt              = 0:h:Tf\nP              = ss(tf(1,[2,1])^2)\nK              = 5\nreference(x,t) = [1.]\ns              = Simulator(P, reference)\nx0             = [0.,0]\ntspan          = (0.0,Tf)\nsol            = solve(s, x0, tspan, Tsit5())\nplot(t, s.y(sol, t)[:], lab=\"Open loop step response\")\n\n\n\n\n\n","category":"method"}]
}
