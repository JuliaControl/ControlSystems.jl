<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis · ControlSystems.jl</title><meta name="title" content="Synthesis · ControlSystems.jl"/><meta property="og:title" content="Synthesis · ControlSystems.jl"/><meta property="twitter:title" content="Synthesis · ControlSystems.jl"/><meta name="description" content="Documentation for ControlSystems.jl."/><meta property="og:description" content="Documentation for ControlSystems.jl."/><meta property="twitter:description" content="Documentation for ControlSystems.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ControlSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Introductory guide</span><ul><li><a class="tocitem" href="../../man/introduction/">Introduction</a></li><li><a class="tocitem" href="../../man/creating_systems/">Creating Systems</a></li><li><a class="tocitem" href="../../man/numerical/">Performance considerations</a></li><li><a class="tocitem" href="../../man/differences/">Noteworthy differences from other languages</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/example/">Design</a></li><li><a class="tocitem" href="../../examples/analysis/">Analysis</a></li><li><a class="tocitem" href="../../examples/smith_predictor/">Smith predictor</a></li><li><a class="tocitem" href="../../examples/ilc/">Iterative Learning Control (ILC)</a></li><li><a class="tocitem" href="../../examples/delay_systems/">Properties of delay systems</a></li><li><a class="tocitem" href="../../examples/automatic_differentiation/">Automatic differentiation</a></li><li><a class="tocitem" href="../../examples/tuning_from_data/">Tune a controller using experimental data</a></li><li><a class="tocitem" href="../../examples/zoh/">Analysis of sampled-data (continuous/discrete) systems</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li><a class="tocitem" href="../constructors/">Constructors</a></li><li><a class="tocitem" href="../analysis/">Analysis</a></li><li class="is-active"><a class="tocitem" href>Synthesis</a></li><li><a class="tocitem" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../nonlinear/">Nonlinear</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Synthesis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Synthesis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/synthesis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>ControlSystemsBase.G_CS</code></a></li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>ControlSystemsBase.G_PS</code></a></li><li><a href="#ControlSystemsBase.add_input"><code>ControlSystemsBase.add_input</code></a></li><li><a href="#ControlSystemsBase.add_output"><code>ControlSystemsBase.add_output</code></a></li><li><a href="#ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystemsBase.append</code></a></li><li><a href="#ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystemsBase.array2mimo</code></a></li><li><a href="#ControlSystemsBase.bodev-Tuple{LTISystem}"><code>ControlSystemsBase.bodev</code></a></li><li><a href="#ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.bodev</code></a></li><li><a href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a></li><li><a href="#ControlSystemsBase.c2d-Tuple{AbstractStateSpace{&lt;:Continuous}, AbstractMatrix, Real}"><code>ControlSystemsBase.c2d</code></a></li><li><a href="#ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_poly2poly</code></a></li><li><a href="#ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_roots2poly</code></a></li><li><a href="#ControlSystemsBase.c2d_x0map"><code>ControlSystemsBase.c2d_x0map</code></a></li><li><a href="#ControlSystemsBase.comp_sensitivity-Tuple"><code>ControlSystemsBase.comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a></li><li><a href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a></li><li><a href="#ControlSystemsBase.d2c_exact"><code>ControlSystemsBase.d2c_exact</code></a></li><li><a href="#ControlSystemsBase.dab-Tuple{Any, Any, Any}"><code>ControlSystemsBase.dab</code></a></li><li><a href="#ControlSystemsBase.extended_gangoffour"><code>ControlSystemsBase.extended_gangoffour</code></a></li><li><a href="#ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystemsBase.feedback</code></a></li><li><a href="#ControlSystemsBase.feedback-Tuple{TransferFunction}"><code>ControlSystemsBase.feedback</code></a></li><li><a href="#ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystemsBase.feedback2dof</code></a></li><li><a href="#ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystemsBase.feedback2dof</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#450#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#450#W&quot;}}} where var&quot;#450#W&quot;&lt;:Real"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a></li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.input_resolvent-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.input_resolvent</code></a></li><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_sensitivity</code></a></li><li><a href="#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.kalman</code></a></li><li><a href="#ControlSystemsBase.laglink-Tuple{Any, Any}"><code>ControlSystemsBase.laglink</code></a></li><li><a href="#ControlSystemsBase.leadlink"><code>ControlSystemsBase.leadlink</code></a></li><li><a href="#ControlSystemsBase.leadlinkat"><code>ControlSystemsBase.leadlinkat</code></a></li><li><a href="#ControlSystemsBase.leadlinkcurve"><code>ControlSystemsBase.leadlinkcurve</code></a></li><li><a href="#ControlSystemsBase.lft"><code>ControlSystemsBase.lft</code></a></li><li><a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPI</code></a></li><li><a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPID</code></a></li><li><a href="#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.lqr</code></a></li><li><a href="#ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.nyquistv</code></a></li><li><a href="#ControlSystemsBase.nyquistv-Tuple{LTISystem}"><code>ControlSystemsBase.nyquistv</code></a></li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_comp_sensitivity</code></a></li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_sensitivity</code></a></li><li><a href="#ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.parallel</code></a></li><li><a href="#ControlSystemsBase.pid"><code>ControlSystemsBase.pid</code></a></li><li><a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystemsBase.pidplots</code></a></li><li><a href="#ControlSystemsBase.place"><code>ControlSystemsBase.place</code></a></li><li><a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>ControlSystemsBase.placePI</code></a></li><li><a href="#ControlSystemsBase.place_knvd-Tuple{AbstractMatrix, Any, Any}"><code>ControlSystemsBase.place_knvd</code></a></li><li><a href="#ControlSystemsBase.resolvent-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.resolvent</code></a></li><li><a href="#ControlSystemsBase.rstc-Tuple"><code>ControlSystemsBase.rstc</code></a></li><li><a href="#ControlSystemsBase.rstd-Tuple"><code>ControlSystemsBase.rstd</code></a></li><li><a href="#ControlSystemsBase.sensitivity-Tuple"><code>ControlSystemsBase.sensitivity</code></a></li><li><a href="#ControlSystemsBase.series-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.series</code></a></li><li><a href="#ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.sigmav</code></a></li><li><a href="#ControlSystemsBase.sigmav-Tuple{LTISystem}"><code>ControlSystemsBase.sigmav</code></a></li><li><a href="#ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.sminreal</code></a></li><li><a href="#ControlSystemsBase.stabregionPID"><code>ControlSystemsBase.stabregionPID</code></a></li><li><a href="#ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystemsBase.starprod</code></a></li><li><a href="#ControlSystemsBase.zpconv-NTuple{4, Any}"><code>ControlSystemsBase.zpconv</code></a></li></ul><h1 id="Synthesis"><a class="docs-heading-anchor" href="#Synthesis">Synthesis</a><a id="Synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis" title="Permalink"></a></h1><p>For <span>$H_\infty$</span> and <span>$H_2$</span> synthesis as well as more advanced LQG design, see <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#H_\\\\infty-and-H_2-design">RobustAndOptimalControl</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystemsBase.kalman-Tuple{Any, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.kalman</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kalman(Continuous, A, C, R1, R2)
kalman(Discrete, A, C, R1, R2; direct = false)
kalman(sys, R1, R2; direct = false)</code></pre><p>Calculate the optimal asymptotic Kalman gain.</p><p>If <code>direct = true</code>, the observer gain is computed for the pair <code>(A, CA)</code> instead of <code>(A,C)</code>. This option is intended to be used together with the option <code>direct = true</code> to <a href="../analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a>. Ref: &quot;Computer-Controlled Systems&quot; pp 140. <code>direct = false</code> is sometimes referred to as a &quot;delayed&quot; estimator, while <code>direct = true</code> is a &quot;current&quot; estimator.</p><p>To obtain a discrete-time approximation to a continuous-time LQG problem, the function <a href="../constructors/#ControlSystemsBase.c2d"><code>c2d</code></a> can be used to obtain corresponding discrete-time covariance matrices.</p><p>To obtain an LTISystem that represents the Kalman filter, pass the obtained Kalman feedback gain into <a href="../analysis/#ControlSystemsBase.observer_filter-Tuple{AbstractStateSpace{&lt;:Discrete}, AbstractMatrix}"><code>observer_filter</code></a>. To obtain an LQG controller, pass the obtained Kalman feedback gain as well as a state-feedback gain computed using <a href="#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>lqr</code></a> into <a href="../analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a>.</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec/ared</code> for more help.</p><p><strong>FAQ</strong></p><p>This function requires</p><ul><li><code>R1</code> must be positive semi-definite</li><li><code>R2</code> must be positive definite</li><li>The pair <code>(A,R1)</code> must not have any uncontrollable modes on the imaginary axis (cont) / unit circle (disc), e.g., there must not be any integrating modes that are not affected through <code>R1</code>. if this condition does not hold, you may get the error &quot;The Hamiltonian matrix is not dichotomic&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/synthesis.jl#L82-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}" href="#ControlSystemsBase.lqr-Tuple{Union{Continuous, Type{Continuous}}, Any, Any, Any, Any, Vararg{Any}}"><code>ControlSystemsBase.lqr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lqr(sys, Q, R)
lqr(Continuous, A, B, Q, R, args...; kwargs...)
lqr(Discrete, A, B, Q, R, args...; kwargs...)</code></pre><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = -K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf) for the continuous-time model <code>dx = Ax + Bu</code>. J = sum(x&#39;Qx + u&#39;Ru, 0, inf) for the discrete-time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>The <code>args...; kwargs...</code> are sent to the Riccati solver, allowing specification of cross-covariance etc. See <code>?MatrixEquations.arec / ared</code> for more help.</p><p>To obtain also the solution to the Riccati equation and the eigenvalues of the closed-loop system as well, call <code>ControlSystemsBase.MatrixEquations.arec / ared</code> instead (note the different order of the arguments to these functions).</p><p>To obtain a discrete-time approximation to a continuous-time LQR problem, the function <a href="../constructors/#ControlSystemsBase.c2d"><code>c2d</code></a> can be used to obtain corresponding discrete-time cost matrices.</p><p><strong>Examples</strong></p><p>Continuous time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
A = [0 1; 0 0]
B = [0; 1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R) # lqr(Continuous,A,B,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot; &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre><p>Discrete time</p><pre><code class="language-julia hljs">using LinearAlgebra # For identity matrix I
using Plots
Ts = 0.1
A = [1 Ts; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A, B, C, 0, Ts)
Q = I
R = I
L = lqr(Discrete, A,B,Q,R) # lqr(sys,Q,R) can also be used

u(x,t) = -L*x # Form control law,
t=0:Ts:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0=x0)
plot(t,x&#39;, lab=[&quot;Position&quot;  &quot;Velocity&quot;], xlabel=&quot;Time [s]&quot;)</code></pre><p><strong>FAQ</strong></p><p>This function requires</p><ul><li><code>Q</code> must be positive semi-definite</li><li><code>R</code> must be positive definite</li><li>The pair <code>(Q,A)</code> must not have any unobservable modes on the imaginary axis (cont) / unit circle (disc), e.g., there must not be any integrating modes that are not penalized by <code>Q</code>. if this condition does not hold, you may get the error &quot;The Hamiltonian matrix is not dichotomic&quot;.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/synthesis.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.place" href="#ControlSystemsBase.place"><code>ControlSystemsBase.place</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">place(A, B, p, opt=:c; direct = false)
place(sys::StateSpace, p, opt=:c; direct = false)</code></pre><p>Calculate the gain matrix <code>K</code> such that <code>A - BK</code> has eigenvalues <code>p</code>.</p><pre><code class="nohighlight hljs">place(A, C, p, opt=:o)
place(sys::StateSpace, p, opt=:o)</code></pre><p>Calculate the observer gain matrix <code>L</code> such that <code>A - LC</code> has eigenvalues <code>p</code>.</p><p>If <code>direct = true</code> and <code>opt = :o</code>, the the observer gain <code>K</code> is calculated such that <code>A - KCA</code> has eigenvalues <code>p</code>, this option is to be used together with <code>direct = true</code> in <a href="../analysis/#ControlSystemsBase.observer_controller-Tuple{Any, AbstractMatrix, AbstractMatrix}"><code>observer_controller</code></a>. </p><p>Note: only apply <code>direct = true</code> to discrete-time systems.</p><p>Ref: &quot;Computer-Controlled Systems&quot; pp 140.</p><p>Uses Ackermann&#39;s formula for SISO systems and <a href="#ControlSystemsBase.place_knvd-Tuple{AbstractMatrix, Any, Any}"><code>place_knvd</code></a> for MIMO systems. </p><p>Please note that this function can be numerically sensitive, solving the placement problem in extended precision might be beneficial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/synthesis.jl#L122-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.place_knvd-Tuple{AbstractMatrix, Any, Any}" href="#ControlSystemsBase.place_knvd-Tuple{AbstractMatrix, Any, Any}"><code>ControlSystemsBase.place_knvd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">place_knvd(A::AbstractMatrix, B, λ; verbose = false, init = :s)</code></pre><p>Robust pole placement using the algorithm from</p><blockquote><p>&quot;Robust Pole Assignment in Linear State Feedback&quot;, Kautsky, Nichols, Van Dooren</p></blockquote><p>This implementation uses &quot;method 0&quot; for the X-step and the QR factorization for all factorizations.</p><p>This function will be called automatically when <a href="#ControlSystemsBase.place"><code>place</code></a> is called with a MIMO system.</p><p><strong>Arguments:</strong></p><ul><li><code>init</code>: Determines the initialization strategy for the iterations for find the <code>X</code> matrix. Possible choices are <code>:id</code> (default), <code>:rand</code>, <code>:s</code>. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/synthesis.jl#L218-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d" href="#ControlSystemsBase.c2d"><code>ControlSystemsBase.c2d</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysd = c2d(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)
Gd = c2d(G::TransferFunction{&lt;:Continuous}, Ts, method=:zoh)</code></pre><p>Convert the continuous-time system <code>sys</code> into a discrete-time system with sample time <code>Ts</code>, using the specified <code>method</code> (:<code>zoh</code>, <code>:foh</code>, <code>:fwdeuler</code> or <code>:tustin</code>).</p><p><code>method = :tustin</code> performs a bilinear transform with prewarp frequency <code>w_prewarp</code>.</p><ul><li><code>w_prewarp</code>: Frequency (rad/s) for pre-warping when using the Tustin method, has no effect for other methods.</li></ul><p>See also <code>c2d_x0map</code></p><p><strong>Extended help</strong></p><p>ZoH sampling is exact for linear systems with piece-wise constant inputs (step invariant), i.e., the solution obtained using <a href="../timefreqresponse/#ControlSystemsBase.lsim-Tuple{AbstractStateSpace, AbstractVecOrMat, AbstractVector}"><code>lsim</code></a> is not approximative (modulu machine precision). ZoH sampling is commonly used to discretize continuous-time plant models that are to be controlled using a discrete-time controller.</p><p>FoH sampling is exact for linear systems with piece-wise linear inputs (ramp invariant), this is a good choice for simulation of systems with smooth continuous inputs.</p><p>To approximate the behavior of a continuous-time system well in the frequency domain, the <code>:tustin</code> (trapezoidal / bilinear) method may be most appropriate. In this case, the pre-warping argument can be used to ensure that the frequency response of the discrete-time system matches the continuous-time system at a given frequency. The tustin transformation alters the meaning of the state components, while ZoH and FoH preserve the meaning of the state components. The Tustin method is commonly used to discretize a continuous-time controller.</p><p>The forward-Euler method generally requires the sample time to be very small relative to the time constants of the system, and its use is generally discouraged.</p><p>Classical rules-of-thumb for selecting the sample time for control design dictate that <code>Ts</code> should be chosen as <span>$0.2 ≤ ωgc⋅Ts ≤ 0.6$</span> where <span>$ωgc$</span> is the gain-crossover frequency (rad/s).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L5-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d-Tuple{AbstractStateSpace{&lt;:Continuous}, AbstractMatrix, Real}" href="#ControlSystemsBase.c2d-Tuple{AbstractStateSpace{&lt;:Continuous}, AbstractMatrix, Real}"><code>ControlSystemsBase.c2d</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Qd     = c2d(sys::StateSpace{Continuous}, Qc::Matrix, Ts;             opt=:o)
Qd, Rd = c2d(sys::StateSpace{Continuous}, Qc::Matrix, Rc::Matrix, Ts; opt=:o)
Qd     = c2d(sys::StateSpace{Discrete},   Qc::Matrix;                 opt=:o)
Qd, Rd = c2d(sys::StateSpace{Discrete},   Qc::Matrix, Rc::Matrix;     opt=:o)</code></pre><p>Sample a continuous-time covariance or LQR cost matrix to fit the provided discrete-time system.</p><p>If <code>opt = :o</code> (default), the matrix is assumed to be a covariance matrix. The measurement covariance <code>R</code> may also be provided. If <code>opt = :c</code>, the matrix is instead assumed to be a cost matrix for an LQR problem.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Measurement covariance (here called <code>Rc</code>) is usually estimated in discrete time, and is in this case not dependent on the sample rate. Discretization of the measurement covariance only makes sense when a continuous-time controller has been designed and the closest corresponding discrete-time controller is desired.</p></div></div><p>The method used comes from theorem 5 in the reference below.</p><p>Ref: &quot;Discrete-time Solutions to the Continuous-time Differential Lyapunov Equation With Applications to Kalman Filtering&quot;,  Patrik Axelsson and Fredrik Gustafsson</p><p>On singular covariance matrices: The traditional double integrator with covariance matrix <code>Q = diagm([0,σ²])</code> can not be sampled with this method. Instead, the input matrix (&quot;Cholesky factor&quot;) of <code>Q</code> must be manually kept track of, e.g., the noise of variance <code>σ²</code> enters like <code>N = [0, 1]</code> which is sampled using ZoH and becomes <code>Nd = [1/2 Ts^2; Ts]</code> which results in the covariance matrix <code>σ² * Nd * Nd&#39;</code>. </p><p><strong>Example:</strong></p><p>The following example designs a continuous-time LQR controller for a resonant system. This is simulated with OrdinaryDiffEq to allow the ODE integrator to also integrate the continuous-time LQR cost (the cost is added as an additional state variable). We then discretize both the system and the cost matrices and simulate the same thing. The discretization of an LQR contorller in this way is sometimes refered to as <code>lqrd</code>.</p><pre><code class="language-julia hljs">using ControlSystemsBase, LinearAlgebra, OrdinaryDiffEq, Test
sysc = DemoSystems.resonant()
x0 = ones(sysc.nx)
Qc = [1 0.01; 0.01 2] # Continuous-time cost matrix for the state
Rc = I(1)             # Continuous-time cost matrix for the input

L = lqr(sysc, Qc, Rc)
dynamics = function (xc, p, t)
    x = xc[1:sysc.nx]
    u = -L*x
    dx = sysc.A*x + sysc.B*u
    dc = dot(x, Qc, x) + dot(u, Rc, u)
    return [dx; dc]
end
prob = ODEProblem(dynamics, [x0; 0], (0.0, 10.0))
sol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)
cc = sol.u[end][end] # Continuous-time cost

# Discrete-time version
Ts = 0.01 
sysd = c2d(sysc, Ts)
Qd, Rd = c2d(sysd, Qc, Rc, opt=:c)
Ld = lqr(sysd, Qd, Rd)
sold = lsim(sysd, (x, t) -&gt; -Ld*x, 0:Ts:10, x0 = x0)
function cost(x, u, Q, R)
    dot(x, Q, x) + dot(u, R, u)
end
cd = cost(sold.x, sold.u, Qd, Rd) # Discrete-time cost
@test cc ≈ cd rtol=0.01           # These should be similar</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L166-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}" href="#ControlSystemsBase.c2d_poly2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_poly2poly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">c2d_poly2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given polynomial coefficients in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L459-L463">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}" href="#ControlSystemsBase.c2d_roots2poly-Tuple{Any, Any}"><code>ControlSystemsBase.c2d_roots2poly</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">c2d_roots2poly(ro, Ts)</code></pre><p>returns the polynomial coefficients in discrete time given a vector of roots in continuous time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L450-L454">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.c2d_x0map" href="#ControlSystemsBase.c2d_x0map"><code>ControlSystemsBase.c2d_x0map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sysd, x0map = c2d_x0map(sys::AbstractStateSpace{&lt;:Continuous}, Ts, method=:zoh; w_prewarp=0)</code></pre><p>Returns the discretization <code>sysd</code> of the system <code>sys</code> and a matrix <code>x0map</code> that transforms the initial conditions to the discrete domain by <code>x0_discrete = x0map*[x0; u0]</code></p><p>See <code>c2d</code> for further details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L35-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.d2c" href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Qc = d2c(sys::AbstractStateSpace{&lt;:Discrete}, Qd::AbstractMatrix; opt=:o)</code></pre><p>Resample discrete-time covariance matrix belonging to <code>sys</code> to the equivalent continuous-time matrix.</p><p>The method used comes from theorem 5 in the reference below.</p><p>If <code>opt = :c</code>, the matrix is instead assumed to be a cost matrix for an LQR problem.</p><p>Ref: Discrete-time Solutions to the Continuous-time Differential Lyapunov Equation With Applications to Kalman Filtering Patrik Axelsson and Fredrik Gustafsson</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L287-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.d2c" href="#ControlSystemsBase.d2c"><code>ControlSystemsBase.d2c</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d2c(sys::AbstractStateSpace{&lt;:Discrete}, method::Symbol = :zoh; w_prewarp=0)</code></pre><p>Convert discrete-time system to a continuous time system, assuming that the discrete-time system was discretized using <code>method</code>. Available methods are `:zoh, :fwdeuler´.</p><ul><li><code>w_prewarp</code>: Frequency for pre-warping when using the Tustin method, has no effect for other methods.</li></ul><p>See also <a href="#ControlSystemsBase.d2c_exact"><code>d2c_exact</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L88-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.d2c_exact" href="#ControlSystemsBase.d2c_exact"><code>ControlSystemsBase.d2c_exact</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d2c_exact(sys::AbstractStateSpace{&lt;:Discrete}, method = :causal)</code></pre><p>Translate a discrete-time system to a continuous-time system by one of the substitutions</p><ul><li><span>$z^{-1} = e^{-sT_s}$</span> if <code>method = :causal</code> (default)</li><li><span>$z = e^{sT_s}$</span>  if <code>method = :acausal</code></li></ul><p>The translation is exact in the frequency domain, i.e., the frequency response of the resulting continuous-time system is identical to the frequency response of the discrete-time system.</p><p>This method of translation is useful when analyzing hybrid continuous/discrete systems in the frequency domain and high accuracy is required.</p><p>The resulting system will be be a static system in feedback with pure delays. When <code>method = :causal</code>, the delays will be positive, resulting in a causal system that can be simulated in the time domain. When <code>method = :acausal</code>, the delays will be negative, resulting in an acausal system that <strong>can not</strong> be simulated in the time domain. The acausal translation results in a smaller system with half as many delay elements in the feedback path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L131-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.dab-Tuple{Any, Any, Any}" href="#ControlSystemsBase.dab-Tuple{Any, Any, Any}"><code>ControlSystemsBase.dab</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">X,Y = dab(A,B,C)</code></pre><p>Solves the Diophantine-Aryabhatta-Bezout identity</p><p><span>$AX + BY = C$</span>, where <span>$A, B, C, X$</span> and <span>$Y$</span> are polynomials and <span>$deg Y = deg A - 1$</span>.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L389-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.rstc-Tuple" href="#ControlSystemsBase.rstc-Tuple"><code>ControlSystemsBase.rstc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <code>?rstd</code> for the discrete case</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L351-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.rstd-Tuple" href="#ControlSystemsBase.rstd-Tuple"><code>ControlSystemsBase.rstd</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)
R,S,T = rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></pre><p>Polynomial synthesis in discrete time.</p><p>Polynomial synthesis according to &quot;Computer-Controlled Systems&quot; ch 10 to design a controller <span>$R(q) u(k) = T(q) r(k) - S(q) y(k)$</span></p><p>Inputs:</p><ul><li><code>BPLUS</code>  : Part of open loop numerator</li><li><code>BMINUS</code> : Part of open loop numerator</li><li><code>A</code>      : Open loop denominator</li><li><code>BM1</code>    : Additional zeros</li><li><code>AM</code>     : Closed loop denominator</li><li><code>AO</code>     : Observer polynomial</li><li><code>AR</code>     : Pre-specified factor of R,</li></ul><p>e.g integral part [1, -1]^k</p><ul><li><code>AS</code>     : Pre-specified factor of S,</li></ul><p>e.g notch filter [1, 0, w^2]</p><p>Outputs: <code>R,S,T</code>  : Polynomials in controller</p><p>See function <code>dab</code> how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L356-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.zpconv-NTuple{4, Any}" href="#ControlSystemsBase.zpconv-NTuple{4, Any}"><code>ControlSystemsBase.zpconv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zpc(a,r,b,s)</code></pre><p>form <code>conv(a,r) + conv(b,s)</code> where the lengths of the polynomials are equalized by zero-padding such that the addition can be carried out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/discrete.jl#L481-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.laglink-Tuple{Any, Any}" href="#ControlSystemsBase.laglink-Tuple{Any, Any}"><code>ControlSystemsBase.laglink</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">laglink(a, M; [Ts])</code></pre><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p><p class="math-container">\[\dfrac{s + a}{s + a/M} = M \dfrac{1 + s/a}{1 + sM/a}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.leadlink" href="#ControlSystemsBase.leadlink"><code>ControlSystemsBase.leadlink</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leadlink(b, N, K=1; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p class="math-container">\[KN \dfrac{s + b}{s + bN} = K \dfrac{1 + s/b}{1 + s/(bN)}\]</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L182-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.leadlinkat" href="#ControlSystemsBase.leadlinkat"><code>ControlSystemsBase.leadlinkat</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leadlinkat(ω, N, K=1; [Ts])</code></pre><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L207-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.leadlinkcurve" href="#ControlSystemsBase.leadlinkcurve"><code>ControlSystemsBase.leadlinkcurve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leadlinkcurve(start=1)</code></pre><p>Plot the phase advance as a function of <code>N</code> for a lead link (phase advance link) If an input argument <code>start</code> is given, the curve is plotted from <code>start</code> to 10, else from 1 to 10.</p><p>See also <code>leadlink, leadlinkat</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L225-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.loopshapingPI-Tuple{Any, Any}" href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C, kp, ki, fig, CF = loopshapingPI(P, ωp; ϕl, rl, phasemargin, form=:standard, doplot=false, Tf, F)</code></pre><p>Selects the parameters of a PI-controller (on parallel form) such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>The parameters can be returned as one of several common representations  chosen by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s) + T_d s)$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))(τ_d s + 1)$</span></li><li><code>:parallel</code> - <span>$K_p + K_i/s + K_d s$</span></li></ul><p>If <code>phasemargin</code> is supplied (in degrees), <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><ul><li><code>Tf</code>: An optional time constant for second-order measurement noise filter on the form <code>tf(1, [Tf^2, 2*Tf/sqrt(2), 1])</code> to make the controller strictly proper.</li><li><code>F</code>: A pre-designed filter to use instead of the default second-order filter that is used if <code>Tf</code> is given.</li><li><code>doplot</code> plot the <code>gangoffourplot</code> and <code>nyquistplot</code> of the system.</li></ul><p>See also <a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a>, <a href="#ControlSystemsBase.stabregionPID"><code>stabregionPID</code></a> and <a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>placePI</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L296-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.loopshapingPID-Tuple{Any, Any}" href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>ControlSystemsBase.loopshapingPID</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt = 1.3, ϕt=75, form=:standard, doplot=false, lb=-10, ub=10, Tf = 1/1000ω, F = nothing)</code></pre><p>Selects the parameters of a PID-controller such that the Nyquist curve of the loop-transfer function <span>$L = PC$</span> at the frequency <code>ω</code> is tangent to the circle where the magnitude of <span>$T = PC / (1+PC)$</span> equals <code>Mt</code>. <code>ϕt</code> denotes the positive angle in degrees between the real axis and the tangent point.</p><p>The default values for <code>Mt</code> and <code>ϕt</code> are chosen to give a good design for processes with inertia, and may need tuning for simpler processes.</p><p>The gain of the resulting controller is generally increasing with increasing <code>ω</code> and <code>Mt</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>P</code>: A SISO plant.</li><li><code>ω</code>: The specification frequency.</li><li><code>Mt</code>: The magnitude of the complementary sensitivity function at the specification frequency, <span>$|T(iω)|$</span>.</li><li><code>ϕt</code>: The positive angle in degrees between the real axis and the tangent point.</li><li><code>doplot</code>: If true, gang of four and Nyquist plots will be returned in <code>fig</code>.</li><li><code>lb</code>: log10 of lower bound for <code>kd</code>.</li><li><code>ub</code>: log10 of upper bound for <code>kd</code>.</li><li><code>Tf</code>: Time constant for second-order measurement noise filter on the form <code>tf(1, [Tf^2, 2*Tf/sqrt(2), 1])</code> to make the controller strictly proper. A practical controller typically sets this time constant slower than the default, e.g., <code>Tf = 1/100ω</code> or <code>Tf = 1/10ω</code></li><li><code>F</code>: A pre-designed filter to use instead of the default second-order filter.</li></ul><p>The parameters can be returned as one of several common representations  chosen by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s) + T_ds)$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))(τ_d s + 1)$</span></li><li><code>:parallel</code> - <span>$K_p + K_i/s + K_d s$</span></li></ul><p>See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a>, <a href="#ControlSystemsBase.stabregionPID"><code>stabregionPID</code></a> and <a href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>placePI</code></a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">P  = tf(1, [1,0,0]) # A double integrator
Mt = 1.3  # Maximum magnitude of complementary sensitivity
ω  = 1    # Frequency at which the specification holds
C, kp, ki, kd, fig, CF = loopshapingPID(P, ω; Mt, ϕt = 75, doplot=true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L398-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.pid" href="#ControlSystemsBase.pid"><code>ControlSystemsBase.pid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C = pid(param_p, param_i, [param_d]; form=:standard, state_space=false, [Tf], [Ts])</code></pre><p>Calculates and returns a PID controller. </p><p>The <code>form</code> can be chosen as one of the following</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>If <code>state_space</code> is set to <code>true</code>, either <code>Kd</code> has to be zero or a positive <code>Tf</code> has to be provided for creating a filter on  the input to allow for a state space realization.  The filter used is <code>1 / (1 + s*Tf + (s*Tf)^2/2)</code>, where <code>Tf</code> can typically  be chosen as <code>Ti/N</code> for a PI controller and <code>Td/N</code> for a PID controller, and <code>N</code> is commonly in the range 2 to 20.  The state space will be returned on controllable canonical form.</p><p>For a discrete controller a positive <code>Ts</code> can be supplied. In this case, the continuous-time controller is discretized using the Tustin method.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">C1 = pid(3.3, 1, 2)                             # Kd≠0 works without filter in tf form
C2 = pid(3.3, 1, 2; Tf=0.3, state_space=true)   # In statespace a filter is needed
C3 = pid(2., 3, 0; Ts=0.4, state_space=true)    # Discrete</code></pre><p>The functions <code>pid_tf</code> and <code>pid_ss</code> are also exported. They take the same parameters and is what is actually called in <code>pid</code> based on the <code>state_space</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L3-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}" href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>ControlSystemsBase.pidplots</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pidplots(P, args...; params_p, params_i, params_d=0, form=:standard, ω=0, grid=false, kwargs...)</code></pre><p>Display the relevant plots related to closing the loop around process <code>P</code> with a PID controller supplied in <code>params</code> on one of the following forms:</p><ul><li><code>:standard</code> - <code>Kp*(1 + 1/(Ti*s) + Td*s)</code> </li><li><code>:series</code> - <code>Kc*(1 + 1/(τi*s))*(τd*s + 1)</code></li><li><code>:parallel</code> - <code>Kp + Ki/s + Kd*s</code></li></ul><p>The sent in values can be arrays to evaluate multiple different controllers, and if <code>grid=true</code> it will be a grid search  over all possible combinations of the values.</p><p>Available plots are <code>:gof</code> for Gang of four, <code>:nyquist</code>, <code>:controller</code> for a bode plot of the controller TF and <code>:pz</code> for pole-zero maps and should be supplied as additional arguments to the function.</p><p>One can also supply a frequency vector <code>ω</code> to be used in Bode and Nyquist plots.</p><p>See also <code>loopshapingPI</code>, <code>stabregionPID</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L96-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T" href="#ControlSystemsBase.placePI-Union{Tuple{T}, Tuple{TransferFunction{&lt;:Continuous, &lt;:ControlSystemsBase.SisoRational{T}}, Any, Any}} where T"><code>ControlSystemsBase.placePI</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">C, kp, ki = placePI(P, ω₀, ζ; form=:standard)</code></pre><p>Selects the parameters of a PI-controller such that the poles of  closed loop between <code>P</code> and <code>C</code> are placed to match the poles of  <code>s^2 + 2ζω₀s + ω₀^2</code>.</p><p>The parameters can be returned as one of several common representations  chose by <code>form</code>, the options are</p><ul><li><code>:standard</code> - <span>$K_p(1 + 1/(T_i s))$</span></li><li><code>:series</code> - <span>$K_c(1 + 1/(τ_i s))$</span> (equivalent to above for PI controllers)</li><li><code>:parallel</code> - <span>$K_p + K_i/s$</span></li></ul><p><code>C</code> is the returned transfer function of the controller and <code>params</code>  is a named tuple containing the parameters. The parameters can be accessed as <code>params.Kp</code> or <code>params[&quot;Kp&quot;]</code> from the named tuple, or they can be unpacked using <code>Kp, Ti, Td = values(params)</code>.</p><p>See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L358-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.stabregionPID" href="#ControlSystemsBase.stabregionPID"><code>ControlSystemsBase.stabregionPID</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kp, ki, fig = stabregionPID(P, [ω]; kd=0, doplot=false, form=:standard)</code></pre><p>Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The provided derivative gain is expected on parallel form, i.e., the form kp + ki/s + kd s, but the result can be transformed to any form given by the <code>form</code> keyword. The curve is found by analyzing</p><p class="math-container">\[P(s)C(s) = -1 ⟹ \\
|PC| = |P| |C| = 1 \\
arg(P) + arg(C) = -π\]</p><p>If <code>P</code> is a function (e.g. s -&gt; exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions See also <a href="#ControlSystemsBase.loopshapingPI-Tuple{Any, Any}"><code>loopshapingPI</code></a>, <a href="#ControlSystemsBase.loopshapingPID-Tuple{Any, Any}"><code>loopshapingPID</code></a>, <a href="#ControlSystemsBase.pidplots-Tuple{LTISystem, Vararg{Any}}"><code>pidplots</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/pid_design.jl#L246-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.sminreal-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.sminreal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sminreal(sys)</code></pre><p>Compute the structurally minimal realization of the state-space system <code>sys</code>. A structurally minimal realization is one where only states that can be determined to be uncontrollable and unobservable based on the location of 0s in <code>sys</code> are removed.</p><p>Systems with numerical noise in the coefficients, e.g., noise on the order of <code>eps</code> require truncation to zero to be affected by structural simplification, e.g.,</p><pre><code class="language-julia hljs">trunc_zero!(A) = A[abs.(A) .&lt; 10eps(maximum(abs, A))] .= 0
trunc_zero!(sys.A); trunc_zero!(sys.B); trunc_zero!(sys.C)
sminreal(sys)</code></pre><p>In contrast to <a href="../constructors/#ControlSystemsBase.minreal"><code>minreal</code></a>, which performs pole-zero cancellation using linear-algebra operations, has an 𝑂(nₓ^3) complexity and is subject to numerical tolerances, <code>sminreal</code> is computationally very cheap and numerically exact (operates on integers). However, the ability of <code>sminreal</code> to reduce the order of the model is much less powerful.</p><p>See also <a href="../constructors/#ControlSystemsBase.minreal"><code>minreal</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/simplification.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.add_input" href="#ControlSystemsBase.add_input"><code>ControlSystemsBase.add_input</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_input(sys::AbstractStateSpace, B2::AbstractArray, D2 = 0)</code></pre><p>Add inputs to <code>sys</code> by forming</p><p class="math-container">\[\begin{aligned}
x&#39; &amp;= Ax + [B \; B_2]u \\
y  &amp;= Cx + [D \; D_2]u \\
\end{aligned}\]</p><p>If <code>B2</code> is an integer it will be interpreted as an index and an input matrix containing a single 1 at the specified index will be used.</p><p>Example: The following example forms an innovation model that takes innovations as inputs</p><pre><code class="language-julia hljs">G   = ssrand(2,2,3, Ts=1)
K   = kalman(G, I(G.nx), I(G.ny))
sys = add_input(G, K)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L141-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.add_output" href="#ControlSystemsBase.add_output"><code>ControlSystemsBase.add_output</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">add_output(sys::AbstractStateSpace, C2::AbstractArray, D2 = 0)</code></pre><p>Add outputs to <code>sys</code> by forming</p><p class="math-container">\[\begin{aligned}
x&#39; &amp;= Ax + Bu \\
y  &amp;= [C; C_2]x + [D; D_2]u \\
\end{aligned}\]</p><p>If <code>C2</code> is an integer it will be interpreted as an index and an output matrix containing a single 1 at the specified index will be used.</p><p>When called with <code>C2 = I(sys.nx)</code>, this function is in some settings known to as <code>augstate</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L175-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}" href="#ControlSystemsBase.append-Tuple{Vararg{AbstractStateSpace}}"><code>ControlSystemsBase.append</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append(systems::StateSpace...), append(systems::TransferFunction...)</code></pre><p>Append systems in block diagonal form</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}" href="#ControlSystemsBase.array2mimo-Tuple{AbstractArray{&lt;:LTISystem}}"><code>ControlSystemsBase.array2mimo</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">array2mimo(M::AbstractArray{&lt;:LTISystem})</code></pre><p>Take an array of <code>LTISystem</code>s and create a single MIMO system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}" href="#ControlSystemsBase.feedback-Tuple{AbstractStateSpace, AbstractStateSpace}"><code>ControlSystemsBase.feedback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback(sys1::AbstractStateSpace, sys2::AbstractStateSpace;
         U1=:, Y1=:, U2=:, Y2=:, W1=:, Z1=:, W2=Int[], Z2=Int[],
         Wperm=:, Zperm=:, pos_feedback::Bool=false)</code></pre><p><em>Basic use</em> <code>feedback(sys1, sys2)</code> forms the (negative) feedback interconnection</p><pre><code class="language-julia hljs">           ┌──────────────┐
◄──────────┤     sys1     │◄──── Σ ◄──────
    │      │              │      │
    │      └──────────────┘      -1
    │                            |
    │      ┌──────────────┐      │
    └─────►│     sys2     ├──────┘
           │              │
           └──────────────┘</code></pre><p>If no second system <code>sys2</code> is given, negative identity feedback (<code>sys2 = 1</code>) is assumed. The returned closed-loop system will have a state vector comprised of the state of <code>sys1</code> followed by the state of <code>sys2</code>.</p><p><em>Advanced use</em> <code>feedback</code> also supports more flexible use according to the figure below</p><pre><code class="language-julia hljs">              ┌──────────────┐
      z1◄─────┤     sys1     │◄──────w1
 ┌─── y1◄─────┤              │◄──────u1 ◄─┐
 │            └──────────────┘            │
 │                                        α
 │            ┌──────────────┐            │
 └──► u2─────►│     sys2     ├───────►y2──┘
      w2─────►│              ├───────►z2
              └──────────────┘</code></pre><ul><li><code>U1</code>, <code>W1</code> specify the indices of the input signals of <code>sys1</code> corresponding to <code>u1</code> and <code>w1</code>. <code>W1</code> contains the indices of the inputs of <code>sys1</code> that are included among the inputs to the returned system, i.e., external inputs.</li><li><code>Y1</code>, <code>Z1</code> specify the indices of the output signals of <code>sys1</code> corresponding to <code>y1</code> and <code>z1</code>. <code>Z1 contains the indices of the outputs of</code>sys1` that are included among the outputs of the returned system, i.e., external outputs.</li><li><code>U2</code>, <code>W2</code>, <code>Y2</code>, <code>Z2</code> specify the corresponding signals of <code>sys2</code>. <code>W2 contains the indices of the inputs of</code>sys2<code>that are included among the inputs to the returned system, i.e., external inputs.</code>Z2<code>contains the indices of the outputs of</code>sys2` that are included among the outputs of the returned system, i.e., external outputs.</li></ul><p>Specify  <code>Wperm</code> and <code>Zperm</code> to reorder the inputs (corresponding to [w1; w2]) and outputs (corresponding to [z1; z2]) in the resulting statespace model.</p><p>Negative feedback (α = -1) is the default. Specify <code>pos_feedback=true</code> for positive feedback (α = 1).</p><p>See also <code>lft</code>, <code>starprod</code>, <code>sensitivity</code>, <code>input_sensitivity</code>, <code>output_sensitivity</code>, <code>comp_sensitivity</code>, <code>input_comp_sensitivity</code>, <code>output_comp_sensitivity</code>, <code>G_PS</code>, <code>G_CS</code>.</p><p>The manual section <a href="https://juliacontrol.github.io/ControlSystems.jl/stable/man/creating_systems/#From-block-diagrams-to-code">From block diagrams to code</a> contains higher-level instructions on how to use this function. See also <a href="https://juliacontrol.github.io/RobustAndOptimalControl.jl/dev/#Connecting-systems-together">RobustAndOptimalControl.jl: Connections using named signals</a> for a higher-level interface.</p><p>See Zhou, Doyle, Glover (1996) for similar (somewhat less symmetric) formulas.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L275-L322">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback-Tuple{TransferFunction}" href="#ControlSystemsBase.feedback-Tuple{TransferFunction}"><code>ControlSystemsBase.feedback</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback(sys)
feedback(sys1, sys2)</code></pre><p>For a general LTI-system, <code>feedback</code> forms the negative feedback interconnection</p><pre><code class="language-julia hljs">&gt;-+ sys1 +--&gt;
  |      |
 (-)sys2 +</code></pre><p>If no second system is given, negative identity feedback is assumed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L218-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}" href="#ControlSystemsBase.feedback2dof-Tuple{TransferFunction, Any, Any, Any}"><code>ControlSystemsBase.feedback2dof</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P,R,S,T)
feedback2dof(B,A,R,S,T)</code></pre><ul><li>Return <code>BT/(AR+ST)</code> where B and A are the numerator and denominator polynomials of <code>P</code> respectively</li><li>Return <code>BT/(AR+ST)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L430-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE" href="#ControlSystemsBase.feedback2dof-Union{Tuple{TE}, Tuple{TransferFunction{TE}, TransferFunction{TE}, TransferFunction{TE}}} where TE"><code>ControlSystemsBase.feedback2dof</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">feedback2dof(P::TransferFunction, C::TransferFunction, F::TransferFunction)</code></pre><p>Return the transfer function <code>P(F+C)/(1+PC)</code> which is the closed-loop system with process <code>P</code>, controller <code>C</code> and feedforward filter <code>F</code> from reference to control signal (by-passing <code>C</code>).</p><pre><code class="nohighlight hljs">         +-------+
         |       |
   +-----&gt;   F   +----+
   |     |       |    |
   |     +-------+    |
   |     +-------+    |    +-------+
r  |  -  |       |    |    |       |    y
+--+-----&gt;   C   +----+----&gt;   P   +---+--&gt;
      |  |       |         |       |   |
      |  +-------+         +-------+   |
      |                                |
      +--------------------------------+</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L444-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.lft" href="#ControlSystemsBase.lft"><code>ControlSystemsBase.lft</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lft(G, Δ, type=:l)</code></pre><p>Lower and upper linear fractional transformation between systems <code>G</code> and <code>Δ</code>.</p><p>Specify <code>:l</code> lor lower LFT, and <code>:u</code> for upper LFT.</p><p><code>G</code> must have more inputs and outputs than <code>Δ</code> has outputs and inputs.</p><p>For details, see Chapter 9.1 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L476-L487">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.parallel-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.parallel</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallel(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in parallel, equivalent to <code>sys2+sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.series-Tuple{LTISystem, LTISystem}" href="#ControlSystemsBase.series-Tuple{LTISystem, LTISystem}"><code>ControlSystemsBase.series</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">series(sys1::LTISystem, sys2::LTISystem)</code></pre><p>Connect systems in series, equivalent to <code>sys2*sys1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}" href="#ControlSystemsBase.starprod-Tuple{Any, Any, Int64, Int64}"><code>ControlSystemsBase.starprod</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">starprod(sys1, sys2, dimu, dimy)</code></pre><p>Compute the Redheffer star product.</p><p><code>length(U1) = length(Y2) = dimu</code> and <code>length(Y1) = length(U2) = dimy</code></p><p>For details, see Chapter 9.3 in <strong>Zhou, K. and JC Doyle</strong>. Essentials of robust control, Prentice hall (NJ), 1998</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/connections.jl#L504-L513">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.G_CS-Tuple{Any, Any}" href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>ControlSystemsBase.G_CS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G_CS(P, C)</code></pre><p>The closed-loop transfer function from (-) measurement noise or (+) reference to control signal. Technically, the transfer function is given by <code>(1 + CP)⁻¹C</code> so <code>SC</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.G_PS-Tuple{Any, Any}" href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>ControlSystemsBase.G_PS</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G_PS(P, C)</code></pre><p>The closed-loop transfer function from load disturbance to plant output. Technically, the transfer function is given by <code>(1 + PC)⁻¹P</code> so <code>SP</code> would be a better, but nonstandard name.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.comp_sensitivity-Tuple" href="#ControlSystemsBase.comp_sensitivity-Tuple"><code>ControlSystemsBase.comp_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a></p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.extended_gangoffour" href="#ControlSystemsBase.extended_gangoffour"><code>ControlSystemsBase.extended_gangoffour</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extended_gangoffour(P, C, pos=true)</code></pre><p>Returns a single statespace system that maps </p><ul><li><code>w1</code> reference or measurement noise</li><li><code>w2</code> load disturbance</li></ul><p>to</p><ul><li><code>z1</code> control error</li><li><code>z2</code> control input</li></ul><pre><code class="nohighlight hljs">      z1          z2
      ▲  ┌─────┐  ▲      ┌─────┐
      │  │     │  │      │     │
w1──+─┴─►│  C  ├──┴───+─►│  P  ├─┐
    │    │     │      │  │     │ │
    │    └─────┘      │  └─────┘ │
    │                 w2         │
    └────────────────────────────┘</code></pre><p>The returned system has the transfer-function matrix</p><p class="math-container">\[\begin{bmatrix}
I \\ C
\end{bmatrix} (I + PC)^{-1} \begin{bmatrix}
I &amp; P
\end{bmatrix}\]</p><p>or in code</p><pre><code class="language-julia hljs"># For SISO P
S  = G[1, 1]
PS = G[1, 2]
CS = G[2, 1]
T  = G[2, 2]

# For MIMO P
S  = G[1:P.ny,     1:P.nu]
PS = G[1:P.ny,     P.ny+1:end]
CS = G[P.ny+1:end, 1:P.ny]
T  = G[P.ny+1:end, P.ny+1:end] # Input complimentary sensitivity function</code></pre><p>The gang of four can be plotted like so</p><pre><code class="language-julia hljs">Gcl = extended_gangoffour(G, C) # Form closed-loop system
bodeplot(Gcl, lab=[&quot;S&quot; &quot;CS&quot; &quot;PS&quot; &quot;T&quot;], plotphase=false) |&gt; display # Plot gang of four</code></pre><p>Note, the last input of Gcl is the negative of the <code>PS</code> and <code>T</code> transfer functions from <code>gangoffour2</code>. To get a transfer matrix with the same sign as <a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> and <a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a>, call <code>extended_gangoffour(P, C, pos=false)</code>. See <code>glover_mcfarlane</code> from RobustAndOptimalControl.jl for an extended example. See also <code>ncfmargin</code> and <code>feedback_control</code> from RobustAndOptimalControl.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L113-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_comp_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_comp_sensitivity(P,C)</code></pre><p>Transfer function from load disturbance to control signal.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case controller output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L89-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.input_resolvent-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.input_resolvent-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.input_resolvent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_resolvent(sys::AbstractStateSpace)</code></pre><p>Return the input-mapped resolvent of <code>sys</code></p><p class="math-container">\[(sI - A)^{-1}B\]</p><p>i.e., the system <code>ss(A, B, I, 0)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L176-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.input_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.input_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_sensitivity(P, C)</code></pre><p>Transfer function from load disturbance to total plant input.</p><ul><li>&quot;Input&quot; signifies that the transfer function is from the input of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_comp_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">output_comp_sensitivity(P,C)</code></pre><p>Transfer function from measurement noise / reference to plant output.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li><li>&quot;Complimentary&quot; signifies that the transfer function is to an output (in this case plant output)</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.output_sensitivity-Tuple{Any, Any}" href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>ControlSystemsBase.output_sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">output_sensitivity(P, C)</code></pre><p>Transfer function from measurement noise / reference to control error.</p><ul><li>&quot;output&quot; signifies that the transfer function is from the output of the plant.</li></ul><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L76-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.resolvent-Tuple{AbstractStateSpace}" href="#ControlSystemsBase.resolvent-Tuple{AbstractStateSpace}"><code>ControlSystemsBase.resolvent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">resolvent(sys::AbstractStateSpace)</code></pre><p>Return the resolvent of <code>sys</code></p><p class="math-container">\[(sI - A)^{-1}\]</p><p>i.e., the system <code>ss(A, I, I, 0)</code>.</p><p>See also <a href="#ControlSystemsBase.input_resolvent-Tuple{AbstractStateSpace}"><code>input_resolvent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L190-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.sensitivity-Tuple" href="#ControlSystemsBase.sensitivity-Tuple"><code>ControlSystemsBase.sensitivity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>See <a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a></p><p>The output <a href="https://en.wikipedia.org/wiki/Sensitivity_(control_systems)">sensitivity function</a> <span>$S_o = (I + PC)^{-1}$</span> is the transfer function from a reference input to control error, while the input sensitivity function <span>$S_i = (I + CP)^{-1}$</span> is the transfer function from a disturbance at the plant input to the total plant input. For SISO systems, input and output sensitivity functions are equal. In general, we want to minimize the sensitivity function to improve robustness and performance, but practical constraints always cause the sensitivity function to tend to 1 for high frequencies. A robust design minimizes the peak of the sensitivity function, <span>$M_S$</span>. The peak magnitude of <span>$S$</span> is the inverse of the distance between the open-loop Nyquist curve and the critical point -1. Upper bounding the sensitivity peak <span>$M_S$</span> gives lower-bounds on phase and gain margins according to</p><p class="math-container">\[ϕ_m ≥ 2\text{sin}^{-1}(\frac{1}{2M_S}), g_m ≥ \frac{M_S}{M_S-1}\]</p><p>Generally, bounding <span>$M_S$</span> is a better objective than looking at gain and phase margins due to the possibility of combined gain and pahse variations, which may lead to poor robustness despite large gain and pahse margins.</p><pre><code class="nohighlight hljs">         ▲
         │e₁
         │  ┌─────┐
d₁────+──┴──►  P  ├─────┬──►e₄
      │     └─────┘     │
      │                 │
      │     ┌─────┐    -│
 e₂◄──┴─────┤  C  ◄──┬──+───d₂
            └─────┘  │
                     │e₃
                     ▼</code></pre><ul><li><a href="#ControlSystemsBase.input_sensitivity-Tuple{Any, Any}"><code>input_sensitivity</code></a> is the transfer function from d₁ to e₁,       (I + CP)⁻¹</li><li><a href="#ControlSystemsBase.output_sensitivity-Tuple{Any, Any}"><code>output_sensitivity</code></a> is the transfer function from d₂ to e₃,      (I + PC)⁻¹</li><li><a href="#ControlSystemsBase.input_comp_sensitivity-Tuple{Any, Any}"><code>input_comp_sensitivity</code></a> is the transfer function from d₁ to e₂,  (I + CP)⁻¹CP</li><li><a href="#ControlSystemsBase.output_comp_sensitivity-Tuple{Any, Any}"><code>output_comp_sensitivity</code></a> is the transfer function from d₂ to e₄, (I + PC)⁻¹PC</li><li><a href="#ControlSystemsBase.G_PS-Tuple{Any, Any}"><code>G_PS</code></a> is the transfer function from d₁ to e₄,                    (1 + PC)⁻¹P</li><li><a href="#ControlSystemsBase.G_CS-Tuple{Any, Any}"><code>G_CS</code></a> is the transfer function from d₂ to e₂,                    (1 + CP)⁻¹C</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/sensitivity_functions.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.bodev-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.bodev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>bodev(sys::LTISystem, w::AbstractVector; $(Expr(:kw, :unwrap, true)))</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.bodev-Tuple{LTISystem}" href="#ControlSystemsBase.bodev-Tuple{LTISystem}"><code>ControlSystemsBase.bodev</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>bodev(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>bode</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.freqrespv-Tuple{AbstractMatrix, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>freqrespv(G::AbstractMatrix, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}" href="#ControlSystemsBase.freqrespv-Tuple{Number, AbstractVector{&lt;:Real}}"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>freqrespv(G::Number, w_vec::AbstractVector{&lt;:Real}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#450#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#450#W&quot;}}} where var&quot;#450#W&quot;&lt;:Real" href="#ControlSystemsBase.freqrespv-Union{Tuple{var&quot;#450#W&quot;}, Tuple{LTISystem, AbstractVector{var&quot;#450#W&quot;}}} where var&quot;#450#W&quot;&lt;:Real"><code>ControlSystemsBase.freqrespv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>freqrespv(sys::LTISystem, w_vec::AbstractVector{W}; )</code></p><p>For use with SISO systems where it acts the same as <code>freqresp</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.nyquistv-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.nyquistv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>nyquistv(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.nyquistv-Tuple{LTISystem}" href="#ControlSystemsBase.nyquistv-Tuple{LTISystem}"><code>ControlSystemsBase.nyquistv</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>nyquistv(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>nyquist</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}" href="#ControlSystemsBase.sigmav-Tuple{LTISystem, AbstractVector}"><code>ControlSystemsBase.sigmav</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>sigmav(sys::LTISystem, w::AbstractVector; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ControlSystemsBase.sigmav-Tuple{LTISystem}" href="#ControlSystemsBase.sigmav-Tuple{LTISystem}"><code>ControlSystemsBase.sigmav</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p><code>sigmav(sys::LTISystem; )</code></p><p>For use with SISO systems where it acts the same as <code>sigma</code> but with the extra dimensions removed in the returned values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/ceb9ff92b05a31ab54d3b69da4c7ac88aadd4715/lib/ControlSystemsBase/src/utilities.jl#L187-L192">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analysis/">« Analysis</a><a class="docs-footer-nextpage" href="../timefreqresponse/">Time and Frequency response »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 11 January 2025 10:06">Saturday 11 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
